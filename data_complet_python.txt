Niveau debuant

Chap 1. Introduction à Python
Qu'est-ce que Python ?
Python est un langage de programmation de haut niveau, ce qui signifie qu'il est conçu pour être proche du langage humain et de l'abstraction des systèmes matériels sous-jacents. Cela le rend relativement facile à lire et à comprendre, surtout par rapport à des langages plus complexes, comme le C ou le C++.

Il a été créé à la fin des années 1980 par Guido van Rossum aux Pays-Bas. La première version publique, Python 0.9.0, a été lancée en 1991. L'objectif principal de Python était de rendre la programmation plus accessible et agréable grâce à une syntaxe claire et simple. Python est aujourd'hui l'un des langages les plus populaires dans le monde de la programmation.

Caractéristiques principales de Python
Interprété : Python est un langage interprété, ce qui signifie qu'il n'est pas nécessaire de le compiler avant de l'exécuter. Le code Python est directement exécuté par un interpréteur Python. Cela facilite le processus de développement, car il n'est pas nécessaire de passer par une phase de compilation chaque fois que le code est modifié.
Facilité d'apprentissage : Python est conçu pour être facile à apprendre, même pour les débutants. Sa syntaxe est minimaliste et proche de l'anglais, ce qui permet de se concentrer sur la logique du programme plutôt que sur des règles syntaxiques complexes.
Portabilité : Python est multi-plateforme, ce qui signifie qu'un programme écrit en Python peut être exécuté sur différents systèmes d'exploitation (Windows, macOS, Linux, etc.) sans modifications majeures du code.
Communauté active : Python bénéficie d'une communauté active qui contribue constamment au langage en ajoutant de nouvelles bibliothèques et frameworks. Cela rend Python particulièrement adapté à une multitude d'applications.
Extensibilité : Bien que Python soit un langage de haut niveau, il peut être étendu par des modules écrits en d'autres langages comme C ou C++ pour augmenter ses performances lorsque cela est nécessaire.
Pourquoi utiliser Python ?
Simplicité et lisibilité :

Python met l'accent sur une syntaxe claire et lisible, ce qui facilite l'écriture de programmes et leur compréhension par d'autres développeurs. Contrairement à d'autres langages qui nécessitent des symboles ou des parenthèses complexes, Python privilégie la lisibilité, ce qui permet à de nouveaux programmeurs de commencer rapidement.
Dynamique et flexible :

Python est un langage dynamique. Vous n'avez pas besoin de déclarer explicitement les types de variables avant de les utiliser. Par exemple, vous pouvez assigner un nombre à une variable, puis une chaîne de caractères dans la même variable sans aucune restriction.
Support des paradigmes multiples :

Python est multi-paradigme, ce qui signifie qu'il prend en charge différents styles de programmation, tels que la programmation impérative, orientée objet et fonctionnelle. Cela offre une grande flexibilité dans la manière dont vous concevez vos programmes.
Large écosystème de bibliothèques :

Python possède un vaste écosystème de bibliothèques et de frameworks qui facilitent le développement. Par exemple :
Pour le développement web : Django, Flask.
Pour l'analyse de données : Pandas, NumPy, Matplotlib.
Pour l'intelligence artificielle et l'apprentissage automatique : TensorFlow, Keras, PyTorch.
Pour l'automatisation : Selenium, PyAutoGUI.
Pour les tests : PyTest, UnitTest.
Pour les applications GUI : Tkinter, PyQt.
Utilisation dans de nombreux domaines :

Python est utilisé dans une grande variété de domaines, allant de l'automatisation des tâches répétitives, au développement web, en passant par l'analyse de données, l'intelligence artificielle, le machine learning, les applications de bureau, et bien plus encore.
Domaine d'application de Python
Développement Web : Python est largement utilisé pour créer des sites web dynamiques et des applications web grâce à des frameworks tels que Django et Flask. Ces frameworks facilitent la gestion de bases de données, la sécurité, et la création d'interfaces utilisateurs.

Analyse de données et science des données : Grâce à des bibliothèques comme Pandas, NumPy et Matplotlib, Python est devenu un choix populaire pour l'analyse de données. Il est utilisé pour traiter, analyser et visualiser de grandes quantités de données dans des domaines comme la finance, la biologie, et le marketing.

Automatisation et scripts : Python est un excellent choix pour l'automatisation de tâches répétitives, comme le traitement de fichiers, l'envoi d'emails, la gestion de systèmes ou encore la collecte de données sur le web (par exemple, le web scraping).

Intelligence artificielle et apprentissage automatique : Python est le langage le plus utilisé dans le domaine de l'intelligence artificielle (IA) et de l'apprentissage automatique (ML), grâce à des bibliothèques telles que TensorFlow, Keras, Scikit-learn, et PyTorch. Ces outils permettent de construire des modèles d'IA et d'optimiser des algorithmes d'apprentissage.

Développement d'applications de bureau : Python permet de développer des applications graphiques avec des interfaces utilisateur, grâce à des outils comme Tkinter, PyQt ou Kivy. Ces applications peuvent être déployées sur différentes plateformes sans modification du code source.

Sécurité et cybersécurité : Python est largement utilisé dans le domaine de la cybersécurité pour écrire des scripts de test de pénétration (pentests), automatiser la détection des vulnérabilités et analyser les systèmes. Des bibliothèques comme Scapy et Requests sont souvent utilisées pour interagir avec les réseaux.

Jeux vidéo et simulations : Python est également utilisé dans la création de jeux vidéo simples et dans les simulations. Le module Pygame permet de développer des jeux en 2D rapidement, tandis que des bibliothèques comme PyOpenGL peuvent être utilisées pour des applications graphiques en 3D.

Pourquoi choisir Python ?
Accessibilité : Python est idéal pour les débutants. La simplicité de sa syntaxe et son langage naturel en font un excellent choix pour ceux qui commencent la programmation.
Communauté : Python bénéficie d'une grande communauté de développeurs, ce qui signifie une aide disponible facilement via des forums, des tutoriels en ligne, et une documentation exhaustive.
Adaptabilité : Python peut être utilisé pour des projets simples mais aussi pour des applications complexes dans des domaines aussi variés que le big data, la visualisation, la robotique, et plus encore.
En conclusion, Python est un langage puissant, polyvalent, et très accessible, qui permet aux développeurs de créer des applications de manière rapide et efficace tout en bénéficiant d'une grande richesse de bibliothèques et de ressources.


Bien sûr ! Je vais développer les concepts en détail tout en ajoutant des exemples et un script lorsque cela sera nécessaire pour illustrer les points clés.

1. Introduction à Python
Qu'est-ce que Python ?
Python est un langage de programmation de haut niveau, interprété, et orienté vers la lisibilité du code. Il est conçu pour faciliter le développement logiciel grâce à une syntaxe simple et intuitive, ce qui le rend accessible même aux débutants.

Le créateur de Python, Guido van Rossum, l'a conçu à la fin des années 1980 pour améliorer la productivité des développeurs. Il a été conçu en tenant compte de plusieurs principes clés, notamment la lisibilité du code, la simplicité et la facilité de maintenance.

Caractéristiques principales de Python
Langage interprété :

Python est un langage interprété, ce qui signifie qu'il n'est pas nécessaire de compiler le code avant de l'exécuter. Le programme est directement interprété ligne par ligne par l'interpréteur Python.
Exemple : Si vous créez un fichier exemple.py et que vous l'exécutez avec la commande python exemple.py, l'interpréteur Python l'exécutera directement sans étape de compilation préalable.
Facilité d'apprentissage :

Python est conçu pour être simple à lire et à écrire. Sa syntaxe est conçue pour être proche du langage naturel, ce qui permet à un développeur de comprendre rapidement un programme même s'il est écrit par quelqu'un d'autre.
Exemple : Contrairement à des langages comme C ou Java, Python n'utilise pas de points-virgules pour marquer la fin d'une ligne de code, et les blocs de code sont délimités par l'indentation (espaces ou tabulations), rendant le code visuellement plus intuitif.
Portabilité :

Python est multi-plateforme : un programme Python peut être exécuté sur n'importe quel système d'exploitation (Windows, macOS, Linux) sans modification du code.
Exemple : Un script Python qui fonctionne sur Windows peut être exécuté de manière identique sur Linux ou macOS.
Communauté active :

Python bénéficie d'une communauté active de développeurs qui contribuent régulièrement au langage en développant des bibliothèques, des outils et des frameworks. Cela fait de Python un langage extrêmement bien soutenu.
Pourquoi choisir Python ?
Python est utilisé pour résoudre une multitude de problèmes dans différents domaines. Voici quelques raisons pour lesquelles il est si populaire :

Accessibilité :

Python est particulièrement adapté aux débutants en programmation grâce à sa syntaxe claire et son absence de complexité syntaxique inutile. Il permet aux programmeurs de se concentrer sur la logique du programme plutôt que sur des règles de syntaxe complexes.
Exemple : En Python, la déclaration d'une variable se fait simplement comme suit :

x = 5

Contrairement à des langages comme C ou Java, où il faut d'abord déclarer le type de la variable (int x = 5; en C par exemple), Python gère automatiquement les types de données.
Polyvalence :

Python peut être utilisé dans de nombreux domaines, tels que :
Développement web : avec des frameworks comme Django ou Flask.
Analyse de données : avec des bibliothèques comme Pandas, NumPy, Matplotlib pour la manipulation et la visualisation des données.
Automatisation : pour automatiser des tâches répétitives, comme le traitement de fichiers ou l'envoi d'emails.
Intelligence Artificielle et Machine Learning : avec des bibliothèques comme TensorFlow, Keras et PyTorch.
Richesse des bibliothèques :

Python dispose d'un grand nombre de bibliothèques permettant d'étendre ses fonctionnalités. Cela facilite le développement d'applications complexes sans avoir à réinventer la roue.
Exemple : Pour l'analyse de données, la bibliothèque Pandas permet de charger, manipuler et analyser des données rapidement avec des structures de données adaptées. Voici un exemple simple d'utilisation de Pandas pour lire un fichier CSV et afficher les premières lignes :

import pandas as pd

df = pd.read_csv("fichier.csv")
print(df.head())  # Affiche les 5 premières lignes

Productivité accrue :

Python permet de développer rapidement des applications, notamment grâce à son absence de déclarations complexes et à sa syntaxe intuitive. Cela rend Python adapté à des projets où la rapidité de développement est essentielle.
Intégration facile :

Python peut être facilement intégré avec d'autres langages comme C, C++ ou Java. Cela permet d'utiliser Python pour les parties du code qui nécessitent une productivité rapide tout en s'appuyant sur d'autres langages pour les performances critiques.
Exemple : Si une partie du programme nécessite des calculs très intensifs, il est possible d'intégrer un code C dans un programme Python pour améliorer les performances.
Domaine d'application de Python
Python est utilisé dans une vaste gamme d'applications, ce qui contribue à sa popularité :

Développement web :

Python permet de créer des sites web dynamiques grâce à des frameworks comme Django et Flask. Ces outils simplifient le développement des applications web en fournissant des fonctionnalités telles que la gestion des bases de données et la création de pages interactives.
Exemple : Avec Flask, un simple serveur web peut être lancé en quelques lignes de code.

from flask import Flask

app = Flask(__name__)

@app.route('/')
def home():
    return "Bonjour, monde !"

if __name__ == '__main__':
    app.run(debug=True)

Analyse de données :

Python est le langage privilégié pour l'analyse de données grâce à des bibliothèques comme NumPy (pour les calculs numériques), Pandas (pour la manipulation des données) et Matplotlib (pour la visualisation des données). Par exemple, pour effectuer des analyses statistiques sur un jeu de données, Python offre des outils puissants et accessibles.
Exemple : La bibliothèque Matplotlib permet de créer des graphiques pour visualiser des données.

import matplotlib.pyplot as plt

x = [1, 2, 3, 4, 5]
y = [1, 4, 9, 16, 25]

plt.plot(x, y)
plt.title("Graphique simple")
plt.xlabel("x")
plt.ylabel("y")
plt.show()

Automatisation et script :

Python est un excellent choix pour automatiser des tâches répétitives, comme la gestion de fichiers, l'envoi d'emails, ou la récupération de données sur internet (web scraping). L'utilisation de Selenium ou BeautifulSoup permet de récupérer facilement des informations sur des pages web.
Machine Learning et Intelligence Artificielle :

Python est largement utilisé dans les domaines de l'intelligence artificielle et du machine learning. Des bibliothèques comme Scikit-learn, TensorFlow, Keras et PyTorch permettent de développer des modèles d'apprentissage automatique (par exemple, des réseaux neuronaux).
Exemple : Voici un exemple simple de régression linéaire avec Scikit-learn :

from sklearn.linear_model import LinearRegression
import numpy as np

# Données d'exemple
X = np.array([[1], [2], [3], [4], [5]])  # Entrées
y = np.array([1, 2, 3, 4, 5])            # Sorties

model = LinearRegression()
model.fit(X, y)  # Entraînement du modèle

prediction = model.predict([[6]])  # Prédiction pour une nouvelle entrée
print(prediction)  # Affiche la prédiction

Conclusion
Python est un langage extrêmement versatile, utilisé dans de nombreux domaines allant du développement web à l'analyse de données, en passant par l'automatisation et l'intelligence artificielle. Sa simplicité, sa large communauté et ses bibliothèques puissantes en font un choix idéal tant pour les débutants que pour les experts. Grâce à sa facilité d'apprentissage et son adaptabilité, Python est un excellent point de départ pour toute personne désireuse de se lancer dans la programmation ou de travailler sur des projets complexes.

### Chap 2. **Syntaxe de base**

La **syntaxe** en Python désigne les règles qui régissent la structure d'un programme, c'est-à-dire la manière dont vous devez organiser le code pour que Python puisse l'interpréter correctement. Deux aspects fondamentaux de la syntaxe de Python sont les **commentaires** et l'**indentation**.

#### **1. Commentaires**

Les **commentaires** sont des lignes dans le code qui ne sont pas exécutées par l’interpréteur Python. Ils servent uniquement à expliquer ou clarifier le code pour le programmeur ou pour d'autres personnes qui pourraient lire le code. Les commentaires permettent de rendre le code plus compréhensible, d'expliquer des choix de conception ou d'indiquer des parties à revisiter ou à améliorer.

- **Syntaxe** :

  Un commentaire commence par le symbole `#` et continue jusqu'à la fin de la ligne.
  ```python
  # Ceci est un commentaire
  ```

- Exemple :

  ```python
  # Déclaration d'une variable
  x = 10  # Initialisation de x à 10
  ```

  Ici, `# Déclaration d'une variable` et `# Initialisation de x à 10` sont des commentaires. Python ignore ces lignes lorsqu'il exécute le programme.

- **Commentaires multi-lignes** :
  Python ne dispose pas d'une syntaxe spécifique pour les commentaires multi-lignes comme d'autres langages (par exemple, `/*...*/` en C ou Java), mais il existe des alternatives. La plus courante consiste à utiliser plusieurs lignes commençant chacune par `#` :

  ```python
  # Ce code initialise la variable x à 10
  # et la variable y à 20
  # ensuite, il effectue une addition et affiche le résultat.
  x = 10
  y = 20
  print(x + y)
  ```

  Une autre méthode consiste à utiliser des chaînes de caractères entre triples guillemets (`""" ... """`) pour les commentaires multi-lignes. Toutefois, cela est techniquement une chaîne de caractères et non un véritable commentaire. C’est souvent utilisé pour les **docstrings**, qui servent à documenter les fonctions, classes ou modules.

  ```python
  """
  Ce script fait une addition
  entre deux variables x et y
  et affiche le résultat.
  """
  x = 10
  y = 20
  print(x + y)
  ```

#### **2. Indentation**

L'**indentation** est un aspect essentiel de la syntaxe de Python. Elle désigne l'utilisation d'espaces ou de tabulations pour décaler le texte du code à différents niveaux, ce qui permet de définir les blocs de code, notamment dans les structures conditionnelles, les boucles et les fonctions. Python utilise l'indentation pour déterminer la structure du programme, contrairement à d'autres langages de programmation qui utilisent des accolades `{}` ou des mots-clés comme `begin` et `end`.

- **Règles de base** :
  - L'indentation doit être cohérente dans tout le programme. Il est recommandé d'utiliser **4 espaces** par niveau d'indentation, bien que l'utilisation de tabulations soit également possible (mais généralement déconseillée, car elle peut entraîner des erreurs si elle est mal utilisée).
  - Un bloc de code commence après une structure de contrôle (par exemple, `if`, `for`, `while`), et il doit être indenté.
  - L'indentation détermine la portée du bloc de code, c'est-à-dire les instructions qui appartiennent à une condition, une boucle ou une fonction.

- **Exemple avec condition `if`** :

  ```python
  x = 10
  if x > 5:
      print("x est plus grand que 5")  # Ceci est indenteé
  print("Ce message sera toujours affiché")
  ```

  Dans cet exemple :
  - La ligne `print("x est plus grand que 5")` est indentée pour indiquer qu'elle fait partie du bloc de code à exécuter si la condition `x > 5` est vraie.
  - La ligne `print("Ce message sera toujours affiché")` n'est pas indentée, donc elle est exécutée indépendamment de la condition.

- **Exemple avec boucle `for`** :

  ```python
  for i in range(3):
      print("Itération", i)  # Cette ligne est indentée
  print("Fin de la boucle")  # Cette ligne n'est pas indentée
  ```

  Ici, `print("Itération", i)` est dans la boucle `for` car elle est indentée. La ligne `print("Fin de la boucle")` est en dehors de la boucle, car elle n'est pas indentée.

- **Erreur due à une mauvaise indentation** :
  Si vous oubliez d’indenter correctement votre code ou si vous mélangez espaces et tabulations, Python lèvera une erreur de **IndentationError**.

  Exemple :

  ```python
  x = 10
  if x > 5:
  print("x est plus grand que 5")  # Erreur d'indentation
  ```

  Cela produira une erreur comme :
  ```
  IndentationError: expected an indented block
  ```

#### **3. Pourquoi l'indentation est-elle importante en Python ?**

Contrairement à d'autres langages de programmation comme Java, C ou C++, où les blocs de code sont délimités par des accolades `{ }`, Python repose sur l'indentation pour délimiter les blocs de code. Cela rend le code Python plus lisible et concis, tout en évitant la surcharge d'accolades.

Par exemple, dans un langage comme Java, on pourrait écrire une condition comme suit :

```java
if (x > 5) {
    System.out.println("x est plus grand que 5");
}
```

En Python, cela devient :

```python
if x > 5:
    print("x est plus grand que 5")
```

Cela permet d'éviter des éléments syntaxiques supplémentaires et force une meilleure lisibilité du code.

#### **Conclusion**

La syntaxe de base en Python est relativement simple, mais elle nécessite une attention particulière à l'indentation et à l'utilisation des commentaires. Les **commentaires** facilitent la compréhension du code, tandis que l'**indentation** définit la structure et la hiérarchie des instructions dans un programme. Une indentation correcte est donc essentielle pour que le code soit exécuté correctement.

Chap 3. Variables et types de données
Les variables en Python
Une variable est un nom qui est associé à une valeur dans la mémoire de l'ordinateur. Vous pouvez utiliser ce nom pour faire référence à la valeur stockée. Les variables en Python sont dynamiques, c'est-à-dire qu'elles peuvent contenir n'importe quel type de données, et leur type peut changer pendant l'exécution du programme. L'attribution d'une valeur à une variable se fait simplement en utilisant le signe égal (=).

Déclaration de variables
Contrairement à d'autres langages de programmation, Python n'exige pas de déclaration explicite des variables. Vous n'avez pas besoin de spécifier le type de la variable au moment de sa création. Python déduit le type de la variable en fonction de la valeur qui lui est attribuée.

Exemple :

x = 10  # x est une variable de type entier
y = "Bonjour"  # y est une variable de type chaîne de caractères
z = 3.14  # z est une variable de type flottant

Les types de données de base
Python offre plusieurs types de données de base pour stocker différentes sortes d'informations. Les types les plus courants sont les suivants :

int (Entiers) :

Le type int est utilisé pour stocker des nombres entiers. Un entier est un nombre sans décimales.
Exemple :

age = 25  # 25 est un entier

Les entiers peuvent être positifs, négatifs ou nuls.

Exemple :

nombre1 = 100  # Un entier positif
nombre2 = -45  # Un entier négatif
nombre3 = 0    # Un entier nul

float (Nombres à virgule flottante) :

Le type float est utilisé pour les nombres décimaux ou nombres à virgule flottante.

Exemple :

pi = 3.14159  # Pi est un nombre flottant
temperature = -12.5  # Température négative avec une décimale

Les floats sont représentés par des nombres avec une partie entière et une partie fractionnaire, séparées par un point (pas une virgule).
str (Chaînes de caractères) :

Le type str est utilisé pour stocker des chaînes de caractères (du texte). En Python, une chaîne peut être délimitée par des guillemets simples (') ou doubles (").

Exemple :

nom = "Alice"  # Une chaîne de caractères entre guillemets doubles
message = 'Bonjour tout le monde'  # Une chaîne de caractères entre guillemets simples

Vous pouvez aussi utiliser des guillemets triples pour des chaînes multilignes :

description = '''Ceci est une chaîne
qui s'étend sur plusieurs lignes.'''
bool (Booléens) :

Le type bool représente les valeurs de vérité : soit True (vrai) soit False (faux).

Exemple :

is_active = True  # Variable booléenne avec la valeur True
is_completed = False  # Variable booléenne avec la valeur False

Conversion de types
En Python, il est possible de convertir une variable d'un type à un autre. Ces conversions sont utiles dans de nombreuses situations, comme lorsque vous devez effectuer des calculs sur différents types de données ou lorsque vous souhaitez afficher une valeur sous un format spécifique.

Conversion de int en float :

Vous pouvez convertir un entier en nombre flottant avec la fonction float().

Exemple :

entier = 5
flottant = float(entier)  # Convertit l'entier 5 en flottant
print(flottant)  # Affiche 5.0
Conversion de float en int :

Vous pouvez convertir un flottant en entier avec la fonction int(). Cette conversion supprime la partie décimale.

Exemple :

flottant = 7.89
entier = int(flottant)  # Convertit 7.89 en 7
print(entier)  # Affiche 7
Conversion de int ou float en str :

Vous pouvez convertir un nombre en chaîne de caractères avec la fonction str(). Cela est souvent utile si vous souhaitez afficher des résultats sous forme de texte.

Exemple :

entier = 42
chaine = str(entier)  # Convertit l'entier 42 en chaîne de caractères
print(chaine)  # Affiche "42"
Conversion de str en int ou float :

Si vous avez une chaîne de caractères représentant un nombre, vous pouvez la convertir en entier ou en flottant avec int() ou float().
Exemple de conversion de chaîne en entier :

texte = "123"
entier = int(texte)  # Convertit la chaîne "123" en entier
print(entier)  # Affiche 123

Exemple de conversion de chaîne en flottant :

texte = "45.67"
flottant = float(texte)  # Convertit la chaîne "45.67" en flottant
print(flottant)  # Affiche 45.67

Vérification du type d'une variable
Parfois, il peut être utile de vérifier le type d'une variable avant de la manipuler. Python offre la fonction type() qui renvoie le type de la variable.

Exemple :

python
Copier le code
x = 10
print(type(x))  # Affiche <class 'int'>

y = "Bonjour"
print(type(y))  # Affiche <class 'str'>
Cela vous permet de vérifier les types de vos variables et de vous assurer que vous manipulez les bons types au bon moment dans votre programme.

Opérations sur les types de données
Chaque type de donnée en Python prend en charge certaines opérations spécifiques. Par exemple, vous pouvez additionner des entiers ou des flottants, concaténer des chaînes de caractères, ou effectuer des comparaisons logiques avec des booléens.

Opérations sur les entiers (int) :

Addition, soustraction, multiplication, division, etc.

Exemple :

a = 10
b = 3
print(a + b)  # Affiche 13 (addition)
print(a - b)  # Affiche 7 (soustraction)
print(a * b)  # Affiche 30 (multiplication)
print(a / b)  # Affiche 3.333... (division)

Opérations sur les flottants (float) :

Similaire aux entiers, mais avec des résultats en virgule flottante.

Exemple :

a = 5.5
b = 2.2
print(a + b)  # Affiche 7.7
Opérations sur les chaînes (str) :

Concatenation (addition) et répétition.

Exemple :

texte1 = "Hello"
texte2 = "World"
print(texte1 + " " + texte2)  # Affiche "Hello World"
print(texte1 * 3)  # Affiche "HelloHelloHello"
Opérations sur les booléens (bool) :

Vous pouvez utiliser les opérateurs logiques comme and, or et not pour manipuler des booléens.

Exemple :

a = True
b = False
print(a and b)  # Affiche False
print(a or b)   # Affiche True
print(not a)    # Affiche False

Conclusion
Les variables et les types de données sont les fondamentaux de tout programme Python. Comprendre comment utiliser les différents types (int, float, str, bool) et comment les convertir entre eux vous permettra de manipuler efficacement des données et d'écrire des programmes robustes. Python étant un langage dynamique, il est facile d'expérimenter avec différents types et de laisser Python s'occuper de la gestion de la mémoire et des types. Ce système simplifié favorise une programmation plus rapide et plus intuitive.

### Chap 4. **Opérateurs**

Les **opérateurs** en Python sont des symboles utilisés pour effectuer des opérations sur des valeurs ou des variables. Ils permettent de manipuler les données de manière variée, que ce soit pour des calculs mathématiques, des comparaisons ou la combinaison de conditions logiques. Les opérateurs sont essentiels pour tout programme et peuvent être regroupés en plusieurs catégories : opérateurs arithmétiques, de comparaison, et logiques.

#### **Opérateurs arithmétiques**

Les **opérateurs arithmétiques** sont utilisés pour effectuer des calculs mathématiques. Ils permettent de manipuler des nombres (entiers ou flottants) en réalisant des opérations de base comme l'addition, la soustraction, la multiplication, la division, etc.

1. **Addition (`+`)** : Additionne deux nombres.

   - Exemple :

     ```python
     a = 10
     b = 5
     print(a + b)  # Affiche 15
     ```

2. **Soustraction (`-`)** : Soustrait un nombre d'un autre.

   - Exemple :

     ```python
     a = 10
     b = 5
     print(a - b)  # Affiche 5
     ```

3. **Multiplication (`*`)** : Multiplie deux nombres.

   - Exemple :

     ```python
     a = 10
     b = 5
     print(a * b)  # Affiche 50
     ```

4. **Division (`/`)** : Divise un nombre par un autre. Le résultat est toujours un **float**.

   - Exemple :

     ```python
     a = 10
     b = 5
     print(a / b)  # Affiche 2.0 (float)
     ```

5. **Division entière (`//`)** : Effectue une division entière, c'est-à-dire qu'elle renvoie le quotient entier sans la partie décimale.

   - Exemple :

     ```python
     a = 10
     b = 3
     print(a // b)  # Affiche 3 (division entière)
     ```

6. **Modulo (`%`)** : Renvoie le reste de la division d'un nombre par un autre.

   - Exemple :

     ```python
     a = 10
     b = 3
     print(a % b)  # Affiche 1 (reste de la division 10/3)
     ```

7. **Exposant (`**`)** : Élévation d'un nombre à la puissance d'un autre.

   - Exemple :

     ```python
     a = 2
     b = 3
     print(a ** b)  # Affiche 8 (2 élevé à la puissance 3)
     ```

#### **Opérateurs de comparaison**

Les **opérateurs de comparaison** sont utilisés pour comparer deux valeurs afin de déterminer si elles sont égales, si l'une est supérieure à l'autre, ou si elles satisfont d'autres conditions de comparaison.

1. **Égalité (`==`)** : Vérifie si deux valeurs sont égales.

   - Exemple :

     ```python
     a = 10
     b = 10
     print(a == b)  # Affiche True
     ```

2. **Inégalité (`!=`)** : Vérifie si deux valeurs sont différentes.

   - Exemple :

     ```python
     a = 10
     b = 5
     print(a != b)  # Affiche True
     ```

3. **Supérieur à (`>`)** : Vérifie si la première valeur est supérieure à la seconde.

   - Exemple :

     ```python
     a = 10
     b = 5
     print(a > b)  # Affiche True
     ```

4. **Inférieur à (`<`)** : Vérifie si la première valeur est inférieure à la seconde.

   - Exemple :

     ```python
     a = 10
     b = 15
     print(a < b)  # Affiche True
     ```

5. **Supérieur ou égal à (`>=`)** : Vérifie si la première valeur est supérieure ou égale à la seconde.

   - Exemple :

     ```python
     a = 10
     b = 10
     print(a >= b)  # Affiche True
     ```

6. **Inférieur ou égal à (`<=`)** : Vérifie si la première valeur est inférieure ou égale à la seconde.

   - Exemple :

     ```python
     a = 10
     b = 15
     print(a <= b)  # Affiche True
     ```

#### **Opérateurs logiques**

Les **opérateurs logiques** permettent de combiner des conditions booléennes. Ils sont très utiles dans les structures conditionnelles pour tester plusieurs conditions à la fois.

1. **`and`** : Renvoie `True` si **les deux conditions** sont vraies. Si l'une des conditions est fausse, il renvoie `False`.

   - Exemple :

     ```python
     a = 10
     b = 5
     print(a > 5 and b < 10)  # Affiche True, car les deux conditions sont vraies
     print(a > 15 and b < 10)  # Affiche False, car la première condition est fausse
     ```

2. **`or`** : Renvoie `True` si **au moins l'une des conditions** est vraie. Si les deux conditions sont fausses, il renvoie `False`.

   - Exemple :

     ```python
     a = 10
     b = 5
     print(a > 5 or b < 10)  # Affiche True, car les deux conditions sont vraies
     print(a < 5 or b < 10)  # Affiche True, car la deuxième condition est vraie
     ```

3. **`not`** : Renverse la valeur booléenne d'une condition. Si la condition est `True`, elle renvoie `False` et vice-versa.

   - Exemple :

     ```python
     a = 10
     print(not a < 5)  # Affiche True, car a < 5 est faux et not renverse la valeur
     ```

#### **Opérateurs d'affectation**

Bien qu'ils ne soient pas strictement logiques ou arithmétiques, les **opérateurs d'affectation** sont utilisés pour attribuer des valeurs aux variables. Ces opérateurs modifient la valeur d'une variable en fonction d'une opération.

1. **Affectation simple (`=`)** : Attribue une valeur à une variable.

   - Exemple :

     ```python
     a = 10
     ```

2. **Affectation avec addition (`+=`)** : Ajoute une valeur à la variable et affecte le résultat à la même variable.

   - Exemple :

     ```python
     a = 10
     a += 5  # Equivalent à a = a + 5
     print(a)  # Affiche 15
     ```

3. **Affectation avec soustraction (`-=`)** : Soustrait une valeur à la variable et affecte le résultat à la même variable.

   - Exemple :

     ```python
     a = 10
     a -= 3  # Equivalent à a = a - 3
     print(a)  # Affiche 7
     ```

4. **Affectation avec multiplication (`*=`)** : Multiplie la variable par une valeur et affecte le résultat à la même variable.

   - Exemple :

     ```python
     a = 10
     a *= 2  # Equivalent à a = a * 2
     print(a)  # Affiche 20
     ```

5. **Affectation avec division (`/=`)** : Divise la variable par une valeur et affecte le résultat à la même variable.

   - Exemple :

     ```python
     a = 10
     a /= 2  # Equivalent à a = a / 2
     print(a)  # Affiche 5.0 (division flottante)
     ```

#### **Conclusion**

Les opérateurs en Python jouent un rôle fondamental dans les calculs, les comparaisons et la gestion des conditions logiques. Que vous effectuiez des calculs mathématiques, que vous compariez des valeurs ou que vous combiniez des conditions, comprendre et utiliser les opérateurs de manière appropriée est essentiel pour écrire des programmes efficaces. Les opérateurs arithmétiques, de comparaison et logiques sont les outils de base pour toute programmation Python et sont utilisés dans une grande variété de situations.

### Chap 5. **Structures conditionnelles**

Les **structures conditionnelles** sont des éléments fondamentaux de la programmation qui permettent de tester des conditions et d'exécuter différentes actions en fonction de ces conditions. En Python, les principales structures conditionnelles sont `if`, `elif`, et `else`. Ces instructions permettent de contrôler le flux du programme en fonction des valeurs des conditions.

#### **1. L'instruction `if`**

L'instruction `if` (si) est utilisée pour tester une condition. Si cette condition est **vraie**, alors le bloc de code qui suit l'instruction `if` sera exécuté.

- **Syntaxe** :

  ```python
  if condition:
      # code à exécuter si la condition est vraie
  ```

- Exemple :

  ```python
  age = 18
  if age >= 18:
      print("Vous êtes majeur.")
  ```

  Dans cet exemple, si la variable `age` est supérieure ou égale à 18, le message "Vous êtes majeur." sera affiché.

#### **2. L'instruction `else`**

L'instruction `else` (sinon) est utilisée en complément d'un `if`. Elle définit un bloc de code à exécuter si la condition testée par l'instruction `if` est **fausse**. 

- **Syntaxe** :

  ```python
  if condition:
      # code à exécuter si la condition est vraie
  else:
      # code à exécuter si la condition est fausse
  ```

- Exemple :

  ```python
  age = 16
  if age >= 18:
      print("Vous êtes majeur.")
  else:
      print("Vous êtes mineur.")
  ```

  Ici, si la condition `age >= 18` est fausse (ce qui est le cas puisque `age = 16`), le message "Vous êtes mineur." sera affiché.

#### **3. L'instruction `elif`**

L'instruction `elif` (else if) permet de tester plusieurs conditions successivement. Elle est utilisée lorsque vous avez plusieurs tests conditionnels à effectuer, mais que vous ne voulez tester qu'une seule condition parmi plusieurs.

- **Syntaxe** :

  ```python
  if condition1:
      # code à exécuter si condition1 est vraie
  elif condition2:
      # code à exécuter si condition2 est vraie
  else:
      # code à exécuter si aucune des conditions n'est vraie
  ```

- Exemple :

  ```python
  age = 16
  if age >= 18:
      print("Vous êtes majeur.")
  elif age >= 13:
      print("Vous êtes un adolescent.")
  else:
      print("Vous êtes un enfant.")
  ```

  Dans cet exemple, le programme vérifie d'abord si la condition `age >= 18` est vraie. Si elle est fausse, il passe à la condition suivante, `age >= 13`. Si cette condition est vraie, le message "Vous êtes un adolescent." est affiché. Si aucune des conditions n'est vraie, le message "Vous êtes un enfant." sera affiché.

#### **4. Combinaison de `if`, `elif`, et `else`**

Les instructions `if`, `elif`, et `else` peuvent être combinées pour gérer plusieurs conditions complexes. Vous pouvez empiler plusieurs `elif` pour tester des cas différents, et à la fin, un `else` peut être utilisé comme une solution par défaut lorsque toutes les autres conditions échouent.

- Exemple :

  ```python
  score = 85
  if score >= 90:
      print("A")
  elif score >= 80:
      print("B")
  elif score >= 70:
      print("C")
  else:
      print("D")
  ```

  Dans cet exemple, le score est comparé à plusieurs seuils pour déterminer la lettre associée. Si le score est supérieur ou égal à 90, "A" est affiché. Si le score est compris entre 80 et 89, "B" est affiché, et ainsi de suite.

#### **5. Conditions multiples avec `and`, `or`, et `not`**

Les conditions dans un `if` peuvent être combinées avec les opérateurs logiques comme `and`, `or`, et `not` pour tester plusieurs critères à la fois.

- **`and`** : La condition sera vraie si **toutes** les sous-conditions sont vraies.
- **`or`** : La condition sera vraie si **au moins l'une** des sous-conditions est vraie.
- **`not`** : Inverse le résultat de la condition.

- Exemple avec `and` :

  ```python
  age = 25
  citoyennete = True
  if age >= 18 and citoyennete:
      print("Vous êtes éligible.")
  ```

  Ici, la condition ne sera vraie que si `age >= 18` et `citoyennete` est aussi vraie (c'est-à-dire que la personne est citoyenne).

- Exemple avec `or` :

  ```python
  jour = "dimanche"
  temps = "ensoleillé"
  if jour == "dimanche" or temps == "ensoleillé":
      print("C'est un bon jour pour sortir.")
  ```

  La condition sera vraie si c'est dimanche **ou** si le temps est ensoleillé.

- Exemple avec `not` :

  ```python
  est_malade = False
  if not est_malade:
      print("Vous pouvez aller travailler.")
  ```

  Si la variable `est_malade` est fausse, alors le message "Vous pouvez aller travailler." sera affiché.

#### **6. Utilisation des conditions imbriquées**

Les conditions peuvent être imbriquées, c'est-à-dire que vous pouvez placer une instruction `if` à l'intérieur d'une autre. Cela permet de tester des conditions plus complexes.

- Exemple :

  ```python
  age = 20
  citoyennete = True
  if age >= 18:
      if citoyennete:
          print("Vous êtes éligible pour voter.")
      else:
          print("Vous devez être citoyen pour voter.")
  else:
      print("Vous devez avoir 18 ans ou plus pour voter.")
  ```

  Ici, la première condition teste si la personne a l'âge requis pour voter, puis, si c'est le cas, la condition imbriquée vérifie si la personne est citoyenne.

#### **Conclusion**

Les structures conditionnelles (`if`, `elif`, et `else`) sont essentielles pour contrôler le flux d'exécution d'un programme Python. Elles permettent de tester des conditions et d'exécuter différentes actions en fonction des résultats de ces tests. Vous pouvez utiliser ces structures pour créer des programmes plus dynamiques et réactifs, en ajustant leur comportement selon les données ou les entrées utilisateurs.

### Chap 6. **Boucles**

Les **boucles** sont des structures de contrôle qui permettent de répéter une action plusieurs fois sans avoir à dupliquer le même code. Elles sont essentielles dans la programmation pour automatiser les tâches répétitives. En Python, il existe principalement deux types de boucles : la boucle `for` et la boucle `while`. Ces boucles permettent de parcourir des séquences d'éléments ou de répéter une action tant qu'une condition est vraie.

#### **1. La boucle `for`**

La **boucle `for`** est utilisée pour itérer (parcourir) une séquence d'éléments, comme une liste, une chaîne de caractères, un dictionnaire, ou même un ensemble de nombres générés. C'est l'une des boucles les plus couramment utilisées en Python, car elle est très simple à utiliser pour répéter une tâche un nombre déterminé de fois ou sur des éléments spécifiques.

- **Syntaxe** :
  ```python
  for element in sequence:
      # code à exécuter pour chaque élément de la séquence
  ```

  - **`element`** est une variable qui prend successivement les valeurs de chaque élément de la séquence.
  - **`sequence`** est l'objet que vous souhaitez parcourir, comme une liste, une chaîne de caractères ou une plage de nombres.

- Exemple :
  ```python
  # Exemple avec une liste
  fruits = ["pomme", "banane", "cerise"]
  for fruit in fruits:
      print(fruit)
  ```

  Dans cet exemple, la boucle `for` parcourt la liste `fruits` et affiche chaque fruit un par un :
  ```
  pomme
  banane
  cerise
  ```

- Exemple avec une **plage de nombres** :
  ```python
  for i in range(5):
      print(i)
  ```

  Ici, la fonction `range(5)` génère une séquence de nombres de 0 à 4 (5 n'est pas inclus), et la boucle `for` affiche chaque nombre sur une ligne :
  ```
  0
  1
  2
  3
  4
  ```

#### **2. La boucle `while`**

La **boucle `while`** répète une action tant qu'une condition est vraie. Contrairement à la boucle `for`, qui parcourt une séquence d'éléments, la boucle `while` dépend d'une condition logique. Elle est utile lorsque vous ne savez pas à l'avance combien de fois vous devez répéter une action, mais vous savez qu'une condition spécifique doit être remplie pour arrêter la boucle.

- **Syntaxe** :
  ```python
  while condition:
      # code à exécuter tant que la condition est vraie
  ```

  - **`condition`** est une expression qui est évaluée à chaque itération de la boucle. Tant qu'elle est vraie, le code à l'intérieur de la boucle est exécuté.

- Exemple :
  ```python
  compteur = 0
  while compteur < 5:
      print(compteur)
      compteur += 1
  ```

  Ici, la boucle s'exécutera tant que `compteur` est inférieur à 5. À chaque itération, `compteur` est incrémenté de 1, et la boucle s'arrête lorsque `compteur` atteint 5.

  Le résultat sera :
  ```
  0
  1
  2
  3
  4
  ```

- Exemple avec une **condition qui devient fausse** :
  ```python
  nombre = 10
  while nombre > 0:
      print(nombre)
      nombre -= 2
  ```

  Dans cet exemple, la boucle continuera tant que `nombre` est supérieur à 0. À chaque itération, `nombre` est diminué de 2, et la boucle s'arrête lorsque `nombre` devient inférieur ou égal à 0.

  Le résultat sera :
  ```
  10
  8
  6
  4
  2
  ```

#### **3. La clause `break`**

La **clause `break`** permet de sortir immédiatement d'une boucle, qu'il s'agisse d'une boucle `for` ou `while`, dès qu'une condition particulière est remplie. Cela permet d'arrêter la boucle prématurément, ce qui peut être utile dans certaines situations.

- Exemple avec une boucle `for` :
  ```python
  for i in range(10):
      if i == 5:
          break
      print(i)
  ```

  Dans cet exemple, dès que `i` atteint 5, la boucle `for` est interrompue, et le programme affiche :
  ```
  0
  1
  2
  3
  4
  ```

- Exemple avec une boucle `while` :
  ```python
  compteur = 0
  while True:
      if compteur == 3:
          break
      print(compteur)
      compteur += 1
  ```

  Ici, la boucle `while` est une boucle infinie (elle continuerait indéfiniment si aucune condition d'arrêt n'était définie). Toutefois, dès que `compteur` atteint 3, la boucle s'arrête grâce au `break`.

  Le résultat sera :
  ```
  0
  1
  2
  ```

#### **4. La clause `continue`**

La **clause `continue`** permet de sauter une itération de la boucle en cours et de passer directement à l'itération suivante, sans exécuter le reste du code de la boucle pour l'itération actuelle.

- Exemple avec une boucle `for` :
  ```python
  for i in range(5):
      if i == 3:
          continue
      print(i)
  ```

  Ici, lorsque `i` vaut 3, la boucle passe directement à l'itération suivante sans afficher 3. Le résultat sera :
  ```
  0
  1
  2
  4
  ```

- Exemple avec une boucle `while` :
  ```python
  compteur = 0
  while compteur < 5:
      compteur += 1
      if compteur == 3:
          continue
      print(compteur)
  ```

  Dans cet exemple, dès que `compteur` atteint 3, la boucle passe à l'itération suivante sans afficher le nombre 3. Le résultat sera :
  ```
  1
  2
  4
  5
  ```

#### **5. Boucles imbriquées**

Les **boucles imbriquées** sont des boucles placées à l'intérieur d'une autre boucle. Cela permet de parcourir des structures de données multidimensionnelles (par exemple, une liste de listes).

- Exemple :
  ```python
  for i in range(3):
      for j in range(2):
          print(f"i = {i}, j = {j}")
  ```

  Ce code affiche toutes les combinaisons possibles de `i` et `j` dans les plages données :
  ```
  i = 0, j = 0
  i = 0, j = 1
  i = 1, j = 0
  i = 1, j = 1
  i = 2, j = 0
  i = 2, j = 1
  ```

#### **Conclusion**

Les boucles en Python, `for` et `while`, sont des outils puissants pour répéter des actions automatiquement. Elles permettent d'itérer sur des séquences d'éléments ou de répéter des actions tant qu'une condition est vraie. Vous pouvez combiner les boucles avec des commandes comme `break` et `continue` pour contrôler le flux de votre programme de manière plus précise, et utiliser des boucles imbriquées pour parcourir des structures de données complexes.

### Chap 7. **Fonctions**

Les **fonctions** sont des blocs de code qui accomplissent une tâche spécifique. Elles sont l'un des concepts les plus importants dans tout langage de programmation, y compris Python, car elles permettent de structurer un programme de manière modulaire et réutilisable. Une fonction prend des **arguments** en entrée et peut renvoyer une **valeur** en sortie.

#### **1. Définition d'une fonction**

En Python, une fonction est définie à l'aide du mot-clé `def`, suivi du nom de la fonction, puis de parenthèses contenant les arguments (si la fonction en prend). Le corps de la fonction est ensuite indenté sous cette ligne de définition.

- **Syntaxe de base** :

  ```python
  def nom_de_la_fonction(parametres):
      # corps de la fonction
      # traitement de la tâche
      return valeur_de_retour
  ```

- **Détails** :
  - Le mot-clé `def` marque le début de la définition de la fonction.
  - `nom_de_la_fonction` est le nom que l'on attribue à la fonction, et ce nom doit respecter les règles de dénomination de Python (commencer par une lettre ou un underscore et ne pas contenir d'espaces).
  - `parametres` sont les valeurs que vous passez à la fonction pour qu'elle effectue son travail (les arguments).
  - Le **corps de la fonction** est l'ensemble des instructions à exécuter lorsque la fonction est appelée.
  - **`return`** est utilisé pour renvoyer une valeur du résultat de la fonction, bien que ce ne soit pas obligatoire.

#### **2. Exemple de fonction simple**

Voici un exemple simple d'une fonction qui additionne deux nombres et renvoie le résultat.

```python
def addition(a, b):
    result = a + b
    return result
```

Ici :
- `addition` est le nom de la fonction.
- `a` et `b` sont les **paramètres** (ou arguments) de la fonction.
- `result` est une variable qui contient la somme de `a` et `b`.
- La fonction renvoie le résultat de l'addition avec le mot-clé `return`.

#### **3. Appeler une fonction**

Une fois qu'une fonction est définie, vous pouvez l'utiliser (ou l'appeler) en écrivant son nom suivi des arguments nécessaires dans des parenthèses.

- **Exemple d'appel** :

  ```python
  somme = addition(5, 3)
  print(somme)  # Cela affichera 8
  ```

Ici, `addition(5, 3)` appelle la fonction `addition` avec les valeurs `5` et `3` comme arguments. La fonction renvoie la somme de ces deux nombres, qui est ensuite affichée.

#### **4. Arguments et paramètres**

Les **paramètres** d'une fonction sont les variables qui sont définies lors de la déclaration de la fonction. Les **arguments**, en revanche, sont les valeurs que l'on passe à la fonction lors de son appel. En Python, les fonctions peuvent avoir différents types d'arguments.

- **Arguments positionnels** : Ce sont les arguments qui sont passés à la fonction dans un ordre précis.
  
  ```python
  def multipler(a, b):
      return a * b

  # Appel de la fonction avec des arguments positionnels
  result = multipler(4, 5)  # a=4, b=5
  ```

- **Arguments nommés (ou keyword arguments)** : Ce sont des arguments où vous spécifiez les noms des paramètres lors de l'appel de la fonction, ce qui permet de passer les arguments dans un ordre quelconque.
  
  ```python
  def saluer(nom, age):
      print(f"Bonjour {nom}, tu as {age} ans.")

  # Appel avec des arguments nommés
  saluer(age=25, nom="Alice")
  ```

  Ici, même si `age` et `nom` sont passés dans un ordre différent, cela fonctionne car ils sont spécifiés par leur nom.

- **Argument par défaut** : Un paramètre de fonction peut avoir une valeur par défaut. Si aucun argument n'est passé pour ce paramètre lors de l'appel, la valeur par défaut sera utilisée.
  
  ```python
  def saluer(nom, age=30):
      print(f"Bonjour {nom}, tu as {age} ans.")

  # Appel avec un argument, l'autre utilise la valeur par défaut
  saluer("Alice")  # Affichera : "Bonjour Alice, tu as 30 ans."
  ```

- **Arguments variables** : Parfois, vous ne savez pas à l'avance combien d'arguments seront passés à la fonction. Python permet d’accepter un nombre variable d’arguments grâce à l’opérateur `*` (pour les arguments positionnels) et `**` (pour les arguments nommés).

  - **`*args`** permet de récupérer un nombre indéfini d'arguments positionnels sous forme de tuple :

    ```python
    def addition(*args):
        return sum(args)

    # Appel avec un nombre variable d'arguments
    print(addition(1, 2, 3))  # Affichera 6
    ```

  - **`**kwargs`** permet de récupérer un nombre indéfini d'arguments nommés sous forme de dictionnaire :

    ```python
    def afficher_info(**kwargs):
        for cle, valeur in kwargs.items():
            print(f"{cle}: {valeur}")

    # Appel avec des arguments nommés variables
    afficher_info(nom="Alice", age=25)
    ```

#### **5. Valeur de retour**

Le mot-clé **`return`** est utilisé pour renvoyer une valeur d'une fonction. Lorsqu'une fonction appelle `return`, l'exécution de la fonction s'arrête immédiatement et la valeur spécifiée après `return` est envoyée à l'appelant.

- **Exemple avec retour d'une valeur** :

  ```python
  def carre(x):
      return x * x

  # Appel de la fonction et capture du résultat
  result = carre(4)
  print(result)  # Affichera 16
  ```

  Dans cet exemple, la fonction `carre` renvoie le carré de `x`, et cette valeur est assignée à la variable `result` pour être utilisée plus tard.

#### **6. Fonctions sans valeur de retour**

Une fonction peut aussi ne pas renvoyer de valeur. Dans ce cas, `return` est omis, ou bien `return` est utilisé sans spécifier de valeur, ce qui renvoie implicitement `None`.

- **Exemple de fonction sans retour** :

  ```python
  def saluer(nom):
      print(f"Bonjour {nom}")

  saluer("Alice")  # Affichera "Bonjour Alice" sans retour
  ```

#### **Conclusion**

Les **fonctions** sont essentielles pour organiser et structurer un programme en Python. Elles permettent de découper le code en morceaux réutilisables, facilitant ainsi la gestion du programme et sa maintenance. Une fonction peut prendre des **arguments** pour personnaliser son comportement et renvoyer des **valeurs** via `return`. L'utilisation des fonctions rend votre code plus propre, plus lisible et plus modulable.

### Chap 8. **Listes et autres collections**

Python propose plusieurs structures de données permettant de stocker des collections d'éléments. Ces structures incluent des **listes**, des **tuples**, des **dictionnaires** et des **sets**. Chacune de ces collections a des caractéristiques uniques qui les rendent utiles pour différents types d'opérations et de cas d'utilisation.

#### **1. Listes**

Les **listes** en Python sont des collections d'éléments **ordonnés**, **modifiables** et **indexées**. Elles peuvent contenir des éléments de types différents (entiers, chaînes de caractères, objets, etc.) et sont définies en plaçant les éléments entre crochets `[ ]`.

- **Syntaxe de base** :

  ```python
  ma_liste = [1, 2, 3, 4, 5]
  ```

- **Détails** :
  - Les éléments d'une liste sont accessibles par leur **index**, qui commence à 0. Par exemple, l'élément à l'index 2 dans la liste `[1, 2, 3]` est `3`.
  - Vous pouvez **ajouter**, **supprimer**, ou **modifier** les éléments d'une liste. 
  - Les listes peuvent être **imbriquées**, c'est-à-dire contenir d'autres listes comme éléments.

- **Opérations courantes sur les listes** :

  - **Ajouter un élément** avec `append()` ou `insert()` :

    ```python
    ma_liste.append(6)  # Ajoute 6 à la fin de la liste
    ma_liste.insert(2, 10)  # Insère 10 à la position 2
    ```

  - **Accéder à un élément** par son index :

    ```python
    print(ma_liste[0])  # Affiche le premier élément de la liste
    ```

  - **Modifier un élément** :

    ```python
    ma_liste[2] = 12  # Modifie l'élément à l'index 2
    ```

  - **Supprimer un élément** avec `remove()` ou `pop()` :

    ```python
    ma_liste.remove(10)  # Supprime le premier élément avec la valeur 10
    ma_liste.pop(1)  # Supprime l'élément à l'index 1
    ```

  - **Obtenir la longueur** de la liste avec `len()` :

    ```python
    print(len(ma_liste))  # Affiche le nombre d'éléments dans la liste
    ```

- **Exemple** :

  ```python
  fruits = ["pomme", "banane", "cerise"]
  fruits.append("orange")
  print(fruits)  # Affichera ['pomme', 'banane', 'cerise', 'orange']
  ```

#### **2. Tuples**

Un **tuple** est une collection d'éléments **ordonnés**, mais contrairement à une liste, un tuple est **immuable**. Cela signifie qu'une fois qu'un tuple est créé, vous ne pouvez pas modifier, ajouter ou supprimer des éléments.

- **Syntaxe de base** :

  ```python
  mon_tuple = (1, 2, 3)
  ```

- **Détails** :
  - Les tuples sont souvent utilisés lorsque vous souhaitez garantir que les données ne soient pas modifiées.
  - Les éléments d'un tuple sont accessibles par leur **index**, comme dans une liste.
  - Un tuple peut contenir des éléments de différents types, tout comme une liste.

- **Opérations courantes sur les tuples** :

  - **Accéder à un élément** par son index :

    ```python
    print(mon_tuple[0])  # Affiche 1
    ```

  - **Les tuples ne supportent pas les modifications** :

    ```python
    # mon_tuple[1] = 5  # Cela provoque une erreur car les tuples sont immuables
    ```

- **Exemple** :

  ```python
  couleurs = ("rouge", "vert", "bleu")
  print(couleurs[1])  # Affichera 'vert'
  ```

#### **3. Dictionnaires**

Un **dictionnaire** est une collection **non ordonnée** de paires **clé-valeur**. Chaque élément du dictionnaire est composé d'une **clé** unique et d'une **valeur** associée à cette clé. Les dictionnaires sont utilisés pour stocker des données où l'accès rapide à une valeur est nécessaire en utilisant la clé.

- **Syntaxe de base** :

  ```python
  mon_dictionnaire = {"clé1": "valeur1", "clé2": "valeur2", "clé3": "valeur3"}
  ```

- **Détails** :
  - Les dictionnaires ne sont pas ordonnés (avant Python 3.7), ce qui signifie que l'ordre des éléments n'est pas garanti.
  - Les clés dans un dictionnaire doivent être **immuables** (par exemple, des chaînes de caractères, des nombres ou des tuples immuables) et doivent être **uniques**.
  - Les valeurs peuvent être de n'importe quel type.

- **Opérations courantes sur les dictionnaires** :

  - **Accéder à une valeur** par sa clé :

    ```python
    print(mon_dictionnaire["clé1"])  # Affichera 'valeur1'
    ```

  - **Ajouter ou modifier une paire clé-valeur** :

    ```python
    mon_dictionnaire["clé4"] = "valeur4"  # Ajoute une nouvelle paire ou modifie une existante
    ```

  - **Supprimer une paire clé-valeur** avec `del` :

    ```python
    del mon_dictionnaire["clé2"]  # Supprime l'élément avec la clé "clé2"
    ```

- **Exemple** :

  ```python
  employe = {"nom": "Alice", "poste": "Développeur", "age": 30}
  print(employe["nom"])  # Affichera 'Alice'
  employe["age"] = 31  # Modifie l'âge
  ```

#### **4. Sets**

Un **set** (ensemble) est une collection **non ordonnée** d'éléments **uniques**. Les sets ne contiennent pas de doublons et ne maintiennent pas l'ordre des éléments.

- **Syntaxe de base** :

  ```python
  mon_set = {1, 2, 3, 4}
  ```

- **Détails** :
  - Les sets ne permettent pas de dupliquer les éléments. Si vous tentez d'ajouter un élément déjà présent, Python l'ignorera.
  - Un set est utile pour vérifier l'appartenance d'un élément ou effectuer des opérations de théorie des ensembles (union, intersection, etc.).

- **Opérations courantes sur les sets** :

  - **Ajouter un élément** avec `add()` :

    ```python
    mon_set.add(5)  # Ajoute 5 à l'ensemble
    ```

  - **Supprimer un élément** avec `remove()` ou `discard()` :

    ```python
    mon_set.remove(3)  # Supprime 3 de l'ensemble
    mon_set.discard(6)  # Ne fait rien si 6 n'est pas présent
    ```

  - **Effectuer des opérations de sets** (union, intersection) :

    ```python
    autre_set = {3, 4, 5, 6}
    union_set = mon_set.union(autre_set)  # Union des deux ensembles
    intersection_set = mon_set.intersection(autre_set)  # Intersection des deux ensembles
    ```

- **Exemple** :

  ```python
  fruits = {"pomme", "banane", "cerise"}
  fruits.add("orange")  # Ajoute 'orange'
  print(fruits)  # Affichera {'pomme', 'banane', 'cerise', 'orange'}
  ```

#### **Conclusion**

Les collections en Python offrent une grande flexibilité pour stocker et manipuler des données. Chaque structure a ses propres avantages et utilisations spécifiques :

- Les **listes** sont idéales pour les données ordonnées et modifiables.
- Les **tuples** sont utilisés lorsque vous souhaitez que les données restent inchangées après leur création.
- Les **dictionnaires** sont parfaits pour les associations clé-valeur, permettant un accès rapide aux données.
- Les **sets** sont utiles pour les collections d'éléments uniques où l'ordre ne compte pas.

Bien comprendre et maîtriser ces structures vous aidera à écrire des programmes plus efficaces et modulaires.

### Chap 9. **Gestion des erreurs**

La gestion des erreurs dans un programme est essentielle pour garantir son bon fonctionnement, même lorsque des imprévus se produisent. En Python, ce mécanisme est principalement basé sur les **exceptions**. Une exception est un événement qui se produit pendant l'exécution d'un programme et qui interrompt son flux normal. Python offre une structure pour capturer ces erreurs et définir des actions à prendre lorsqu'une erreur se produit, ce qui permet de gérer les erreurs de manière élégante et de maintenir la stabilité de l'application.

#### **1. Exceptions en Python**

Les exceptions sont des objets qui représentent des erreurs. Lorsqu'une erreur survient dans une partie du programme, Python "lance" une exception. Vous pouvez choisir de **capturer** cette exception et de définir un comportement spécifique plutôt que d'arrêter le programme.

- **Exemple d'exception** :

  ```python
  x = 10
  y = 0
  result = x / y  # Division par zéro, générera une exception ZeroDivisionError
  ```

- Dans l'exemple ci-dessus, la division par zéro génère une exception `ZeroDivisionError`. Si vous ne gérez pas cette exception, le programme s'arrêtera et affichera une erreur.

#### **2. Utilisation de `try` et `except`**

Le mécanisme de gestion des erreurs repose sur deux blocs principaux : `try` et `except`. Le bloc `try` contient le code qui peut potentiellement générer une erreur. Si une erreur survient dans ce bloc, l'exécution est transférée au bloc `except`, où vous pouvez spécifier comment gérer l'erreur.

- **Syntaxe de base** :

  ```python
  try:
      # Code susceptible de causer une erreur
      x = 10
      y = 0
      result = x / y  # Cette ligne va générer une exception

  except ZeroDivisionError:

      # Code exécuté si une erreur de type ZeroDivisionError se produit
      print("Erreur : Division par zéro.")
  ```

- **Détails** :
  - Le bloc `try` contient le code à exécuter normalement.
  - Le bloc `except` contient le code qui sera exécuté si une exception est levée dans le bloc `try`.
  - Vous pouvez **spécifier** le type d'exception que vous souhaitez capturer, comme dans l'exemple où `ZeroDivisionError` est capturé.
  
#### **3. Types d'exceptions**

En Python, il existe différents types d'exceptions qui représentent diverses erreurs, telles que :

- `ZeroDivisionError` : Levée lorsque vous tentez de diviser un nombre par zéro.
- `ValueError` : Levée lorsqu'une opération reçoit un argument de type incorrect.
- `IndexError` : Levée lorsque vous accédez à un index hors des limites d'une séquence (comme une liste).
- `KeyError` : Levée lorsque vous tentez d'accéder à une clé inexistante dans un dictionnaire.

Vous pouvez également capturer des exceptions de manière générale sans spécifier un type particulier.

- **Exemple de capture d'exception générale** :

  ```python
  try:
      x = 10
      y = "string"
      result = x + y  # Cette ligne générera une exception TypeError
  except Exception as e:
      print(f"Une erreur s'est produite : {e}")
  ```

Dans ce cas, `Exception` capte toutes les exceptions possibles, et l'objet `e` contiendra l'information sur l'erreur survenue.

#### **4. Bloc `else`**

Le bloc `else` est optionnel et est exécuté uniquement si aucune exception n'est levée dans le bloc `try`. Cela vous permet de spécifier un comportement à exécuter lorsque tout se passe bien, sans erreurs.

- **Exemple avec `else`** :

  ```python
  try:
      x = 10
      y = 2
      result = x / y
  except ZeroDivisionError:
      print("Erreur : Division par zéro.")
  else:
      print(f"Le résultat est {result}.")  # S'exécute seulement si aucune erreur n'est survenue
  ```

#### **5. Bloc `finally`**

Le bloc `finally` est également optionnel. Quel que soit le résultat des blocs `try` et `except` (même en cas d'exception), le bloc `finally` est toujours exécuté. Cela est utile pour des actions de nettoyage, comme fermer des fichiers ou libérer des ressources.

- **Exemple avec `finally`** :

  ```python
  try:
      f = open("exemple.txt", "r")
      content = f.read()
  except FileNotFoundError:
      print("Le fichier n'a pas été trouvé.")
  finally:
      f.close()  # Ce code sera toujours exécuté, même si une erreur est levée
      print("Fichier fermé.")
  ```

#### **6. Levée d'exceptions avec `raise`**

Vous pouvez également **lancer** vos propres exceptions avec le mot-clé `raise`. Cela est utile si vous souhaitez signaler une erreur dans votre programme lorsque certaines conditions sont remplies, mais que Python ne lance pas automatiquement une exception.

- **Exemple de levée d'exception** :

  ```python
  def diviser(x, y):
      if y == 0:
          raise ValueError("Erreur : Division par zéro.")
      return x / y

  try:
      result = diviser(10, 0)  # Cette ligne va lever une exception
  except ValueError as e:
      print(e)  # Affichera "Erreur : Division par zéro."
  ```

#### **7. Gestion d'exceptions multiples**

Vous pouvez capturer plusieurs types d'exceptions en utilisant plusieurs blocs `except`. Vous pouvez également capturer différentes exceptions dans un même bloc `except` en les séparant par des virgules.

- **Exemple de gestion d'exceptions multiples** :

  ```python
  try:
      x = int(input("Entrez un nombre : "))
      y = int(input("Entrez un autre nombre : "))
      result = x / y
  except (ZeroDivisionError, ValueError) as e:
      print(f"Erreur : {e}")
  ```

#### **Conclusion**

La gestion des erreurs avec les exceptions permet à un programme de rester robuste face aux imprévus. Plutôt que de voir votre programme se bloquer complètement, vous pouvez capturer et gérer les erreurs de manière à offrir une meilleure expérience utilisateur ou à permettre au programme de continuer à fonctionner. Voici les points principaux à retenir :

- Utiliser `try` et `except` pour capturer des erreurs spécifiques.
- Ajouter des blocs `else` pour exécuter du code lorsque tout se passe bien.
- Utiliser `finally` pour garantir l'exécution de certaines actions.
- Lever des exceptions personnalisées avec `raise`.
- Capturer plusieurs exceptions à la fois avec des blocs `except` multiples.

### Chap 10. **Modules et bibliothèques**

L'un des grands avantages de Python est son écosystème riche en **modules** et **bibliothèques**. Ces modules sont des fichiers Python qui contiennent des définitions et des implémentations de fonctions, de classes, et d'autres éléments qui vous permettent de réutiliser du code et d'étendre les capacités de Python. Les bibliothèques, quant à elles, sont des collections de modules regroupés pour faciliter un domaine d'application spécifique, comme les calculs mathématiques, le traitement des données, ou la création d'interfaces graphiques.

Python vous permet de **diviser votre code en modules** pour mieux l'organiser et de **réutiliser** des modules externes afin de simplifier des tâches complexes.

#### **1. Utilisation des modules**

Python inclut de nombreux modules standard qui sont intégrés au langage et prêts à l'emploi. Ces modules couvrent une large gamme de fonctionnalités, de la manipulation des fichiers à l'exécution de calculs mathématiques.

- **Exemple d'importation d'un module** :

  ```python
  import math
  result = math.sqrt(16)  # Utilisation du module math pour calculer la racine carrée
  print(result)  # Affiche 4.0
  ```

Dans cet exemple, le module `math` est un module standard de Python qui fournit des fonctions mathématiques, comme `sqrt()` pour calculer la racine carrée d'un nombre.

#### **2. Création et utilisation de vos propres modules**

En plus des modules externes, vous pouvez également créer vos propres modules pour organiser votre code. Par exemple, si vous avez une fonction qui calcule l'aire d'un cercle, vous pouvez la mettre dans un fichier appelé `math_utils.py` et l'importer dans d'autres fichiers.

- **Exemple de création d'un module** (`math_utils.py`) :

  ```python
  def aire_cercle(rayon):
      return 3.14 * rayon * rayon
  ```

- **Utilisation de ce module** :

  ```python
  import math_utils
  rayon = 5
  print(math_utils.aire_cercle(rayon))  # Utilise la fonction aire_cercle du module math_utils
  ```

Ici, le fichier `math_utils.py` est un module que vous pouvez réutiliser dans d'autres scripts Python.

#### **3. Installation de modules externes**

Bien que Python inclut de nombreux modules standards, vous aurez souvent besoin d'installer des modules externes pour accomplir des tâches plus complexes, comme manipuler des données, créer des applications web, ou travailler avec des bases de données. Ces modules externes sont souvent installés via **pip**, le gestionnaire de paquets de Python.

- **Installation d'un module avec `pip`** :

  Si vous souhaitez installer une bibliothèque comme `numpy`, utilisée pour les calculs numériques, vous pouvez l'installer en exécutant la commande suivante dans votre terminal ou ligne de commande :
  ```bash
  pip install numpy
  ```

- **Utilisation du module après installation** :

  Une fois installé, vous pouvez importer et utiliser ce module dans votre code Python :

  ```python
  import numpy as np
  array = np.array([1, 2, 3, 4, 5])
  print(array)  # Affiche [1 2 3 4 5]
  ```

#### **4. Modules populaires et leurs usages**

Voici quelques modules populaires et leurs usages :

- **`os`** : Permet d'interagir avec le système d'exploitation, comme la gestion des fichiers et des répertoires.
  - Exemple : `os.listdir()` pour lister les fichiers dans un répertoire.
  
- **`sys`** : Utilisé pour interagir avec l'environnement Python, comme les arguments de la ligne de commande.
  - Exemple : `sys.argv` pour récupérer les arguments passés au script Python.
  
- **`math`** : Fournit des fonctions mathématiques avancées, comme les trigonométrie et les puissances.
  - Exemple : `math.pi` pour obtenir la valeur de π.
  
- **`datetime`** : Utilisé pour manipuler les dates et heures.
  - Exemple : `datetime.datetime.now()` pour obtenir la date et l'heure actuelles.

- **`random`** : Utilisé pour générer des nombres aléatoires et effectuer des choix aléatoires dans une séquence.
  - Exemple : `random.choice()` pour sélectionner un élément aléatoire d'une liste.

- **`requests`** : Utilisé pour faire des requêtes HTTP afin de récupérer des données depuis des sites web.
  - Exemple : `requests.get("https://api.example.com")` pour envoyer une requête GET à une API.

- **`pandas`** : Une bibliothèque puissante pour la manipulation des données, surtout pour les données tabulaires (comme les fichiers CSV).
  - Exemple : `import pandas as pd` pour importer la bibliothèque et travailler avec des DataFrames.

- **`matplotlib`** : Utilisé pour créer des visualisations graphiques.
  - Exemple : `import matplotlib.pyplot as plt` pour tracer des graphiques.

#### **5. Recherche et documentation des modules**

Lorsque vous souhaitez utiliser un module externe, il est essentiel de savoir où trouver sa documentation. Chaque module Python a généralement une documentation officielle que vous pouvez consulter pour comprendre son fonctionnement.

- **Documentation Python officielle** : [https://docs.python.org/3/](https://docs.python.org/3/)
- **PyPI (Python Package Index)** : [https://pypi.org/](https://pypi.org/) pour rechercher et télécharger des modules externes.

Les bibliothèques les plus populaires comme `numpy`, `requests`, ou `pandas` disposent de documentations détaillées pour expliquer comment les utiliser.

#### **Conclusion**

L'utilisation des modules et bibliothèques en Python est un moyen puissant d'étendre ses capacités sans avoir à réinventer la roue. Vous pouvez tirer parti des modules internes de Python pour accomplir des tâches courantes et installer des bibliothèques externes pour des fonctionnalités plus avancées. Grâce à la richesse de l'écosystème Python, vous pouvez facilement ajouter des fonctionnalités complexes à vos programmes en utilisant des modules bien conçus.

Les points clés à retenir sont :

- Python dispose de modules standard pour de nombreuses tâches courantes.
- Vous pouvez créer vos propres modules pour organiser et réutiliser du code.
- Les modules externes peuvent être installés via `pip` et étendre les fonctionnalités de Python.
- La documentation est essentielle pour comprendre et exploiter pleinement un module.

### Chap 11. **Entrées et sorties**

En Python, les entrées et sorties (E/S) sont des éléments essentiels permettant à un programme d'interagir avec l'utilisateur. Vous pouvez demander à l'utilisateur de saisir des données (entrées) et afficher des résultats (sorties). Ces interactions sont fondamentales dans la plupart des applications, qu'il s'agisse de simples programmes ou d'applications plus complexes.

#### **1. Entrées : Demander à l'utilisateur de saisir des informations**

En Python, la fonction principale pour obtenir des entrées de l'utilisateur est `input()`. Elle permet de capturer ce que l'utilisateur tape au clavier. La valeur saisie est retournée sous forme de **chaîne de caractères** (`str`).

- **Exemple d'entrée simple** :

  ```python
  nom = input("Quel est ton nom ? ")
  print("Bonjour, " + nom + " !")
  ```

Dans cet exemple, Python affiche le message "Quel est ton nom ?" et attend que l'utilisateur saisisse une réponse. Une fois que l'utilisateur appuie sur "Entrée", cette réponse est stockée dans la variable `nom` et affichée dans un message de bienvenue.

#### **2. Conversion des entrées**

Comme les données saisies avec `input()` sont toujours des chaînes de caractères, vous pouvez avoir besoin de les convertir dans d'autres types de données. Par exemple, si vous voulez que l'utilisateur saisisse un nombre entier, vous devrez convertir la chaîne en un entier avec la fonction `int()`.

- **Exemple de conversion pour un nombre entier** :

  ```python
  age = input("Quel est ton âge ? ")
  age = int(age)  # Conversion de la chaîne en entier
  print("Dans 5 ans, tu auras", age + 5, "ans.")
  ```

Ici, l'entrée est d'abord capturée sous forme de chaîne, puis convertie en entier avec `int()`, et enfin, l'âge est utilisé dans un calcul pour afficher une réponse.

Si l'utilisateur saisit quelque chose qui ne peut pas être converti en entier (par exemple "jeune"), une **erreur** se produira. Il est donc recommandé de gérer ces erreurs avec une structure de contrôle comme **`try...except`**.

- **Exemple avec gestion d'erreur** :

  ```python
  try:
      age = int(input("Quel est ton âge ? "))
      print("Dans 5 ans, tu auras", age + 5, "ans.")
  except ValueError:
      print("L'âge doit être un nombre entier.")
  ```

Si l'utilisateur saisit quelque chose qui n'est pas un nombre, le programme affichera un message d'erreur personnalisé au lieu de planter.

#### **3. Sorties : Afficher des résultats à l'écran**

Pour afficher des informations à l'écran, on utilise la fonction **`print()`**. Cette fonction prend un ou plusieurs arguments et affiche leur valeur sur la console. Vous pouvez imprimer des chaînes de texte, des variables, des résultats d'opérations, etc.

- **Exemple d'affichage simple** :

  ```python
  print("Hello, world!")
  ```

Ce programme affiche simplement le texte `Hello, world!` sur l'écran.

- **Exemple d'affichage avec une variable** :

  ```python
  nom = "Alice"
  print("Bonjour,", nom)  # Affiche "Bonjour, Alice"
  ```

- **Exemple d'affichage avec des calculs** :

  ```python
  a = 10
  b = 5
  print("La somme de", a, "et", b, "est", a + b)  # Affiche "La somme de 10 et 5 est 15"
  ```

#### **4. Formatage des sorties**

En Python, il existe plusieurs façons de formater les sorties pour rendre le texte plus lisible ou pour insérer des valeurs dans des chaînes de caractères de manière plus élégante.

- **Concatenation (concatenation de chaînes)** :

  Vous pouvez utiliser l'opérateur `+` pour combiner des chaînes de caractères et des variables :

  ```python
  nom = "Alice"
  age = 25
  print("Bonjour, " + nom + ". Tu as " + str(age) + " ans.")
  ```

- **Utilisation de f-strings (à partir de Python 3.6)** :

  L'une des manières les plus modernes et lisibles de formater des chaînes est l'utilisation des **f-strings**. Vous pouvez inclure directement des variables dans des chaînes en les encadrant de `{}` à l'intérieur de la chaîne, précédée de la lettre `f`.

  ```python
  nom = "Alice"
  age = 25
  print(f"Bonjour, {nom}. Tu as {age} ans.")
  ```

  Cela affiche la même chose que l'exemple précédent, mais d'une manière plus lisible et plus concise.

- **Méthode `.format()`** :

  Avant l'introduction des f-strings, la méthode `.format()` était couramment utilisée pour insérer des valeurs dans une chaîne.

  ```python
  nom = "Alice"
  age = 25
  print("Bonjour, {}. Tu as {} ans.".format(nom, age))
  ```

#### **5. Rediriger les sorties vers un fichier**

Python vous permet également d'écrire des sorties dans un fichier au lieu de les afficher à l'écran. Pour ce faire, vous pouvez ouvrir un fichier en mode écriture et utiliser la fonction `print()` pour envoyer des données dans ce fichier.

- **Exemple d'écriture dans un fichier** :

  ```python
  with open("sortie.txt", "w") as fichier:
      print("Ceci est une sortie vers un fichier.", file=fichier)
  ```

Le code ci-dessus ouvre un fichier `sortie.txt` en mode écriture (`"w"`), et tout ce qui est envoyé à `print()` sera écrit dans ce fichier au lieu d'être affiché sur l'écran.

#### **Conclusion**

Les entrées et sorties en Python permettent d'interagir de manière dynamique avec l'utilisateur et de rendre vos programmes interactifs. Voici les points clés à retenir :

- **Entrée** : Utilisez `input()` pour capturer des données saisies par l'utilisateur.
- **Conversion** : Convertissez les entrées en types appropriés, comme avec `int()` ou `float()`.
- **Sortie** : Utilisez `print()` pour afficher des informations à l'écran.
- **Formatage des sorties** : Utilisez des techniques comme la concaténation, les f-strings ou `.format()` pour formater vos sorties de manière claire.
- **Gestion des erreurs** : Utilisez `try...except` pour gérer les erreurs lors de la conversion des entrées.
- **Redirection** : Vous pouvez rediriger les sorties vers des fichiers pour enregistrer des résultats.

### Chap 12. **Manipulation des chaînes de caractères**

Les chaînes de caractères (ou `str` en Python) sont l'un des types de données les plus utilisés. Elles permettent de stocker et de manipuler du texte dans un programme. Python propose une riche palette de méthodes et d'opérations pour manipuler ces chaînes de manière efficace.

#### **1. Concatenation de chaînes**

La **concaténation** permet d'assembler plusieurs chaînes de caractères pour en créer une nouvelle. Pour cela, on utilise l'opérateur `+`.

- **Exemple de concaténation** :

  ```python
  prenom = "Alice"
  nom = "Dupont"
  full_name = prenom + " " + nom  # "Alice Dupont"
  print(full_name)
  ```

Ici, les variables `prenom` et `nom` sont combinées avec un espace entre elles pour former `full_name`.

#### **2. Répétition de chaînes**

L'opérateur `*` permet de répéter une chaîne un certain nombre de fois.

- **Exemple de répétition** :

  ```python
  mot = "hello"
  repetition = mot * 3  # "hellohellohello"
  print(repetition)
  ```

Cela permet d'imprimer le mot "hello" trois fois de suite.

#### **3. Découpage de chaînes (slicing)**

Le **découpage** (ou **slicing**) est un moyen puissant de sélectionner une sous-partie d'une chaîne. En Python, cela se fait en utilisant les indices de la chaîne dans la notation `[start:end]`.

- **Exemple de découpage** :

  ```python
  texte = "Bonjour tout le monde"
  sous_texte = texte[0:7]  # "Bonjour"
  print(sous_texte)
  ```

- **Explication** :
  - `texte[0:7]` sélectionne la portion de texte allant de l'indice 0 à 6 (l'indice 7 étant exclus).
  - Si vous ne spécifiez pas l'indice de départ, il commence par défaut à 0. Si vous ne spécifiez pas l'indice de fin, il va jusqu'à la fin de la chaîne.

- **Autres variations de découpage** :
  - `texte[:7]` : Prend les caractères de l'indice 0 jusqu'à l'indice 6.
  - `texte[7:]` : Prend les caractères à partir de l'indice 7 jusqu'à la fin.
  - `texte[::2]` : Prend chaque deuxième caractère de la chaîne.

#### **4. Recherche de sous-chaînes**

Il est possible de **rechercher** une sous-chaîne dans une chaîne principale. La méthode `find()` retourne l'indice de la première occurrence de la sous-chaîne, ou `-1` si elle n'est pas trouvée.

- **Exemple de recherche avec `find()`** :

  ```python
  texte = "Python est génial"
  position = texte.find("génial")  # Retourne 10
  print(position)
  ```

Si la sous-chaîne existe, cette méthode renverra son indice de début. Sinon, elle renverra `-1`.

- **Méthode `in`** :
  L'opérateur `in` permet de vérifier rapidement si une sous-chaîne existe dans une chaîne donnée.

  ```python
  texte = "Python est génial"
  if "génial" in texte:
      print("Le mot 'génial' est dans la chaîne.")
  ```

#### **5. Remplacement de texte**

La méthode `replace()` permet de remplacer une sous-chaîne par une autre.

- **Exemple de remplacement** :

  ```python
  texte = "Python est génial"
  texte_modifie = texte.replace("génial", "super")
  print(texte_modifie)  # "Python est super"
  ```

Cela remplace toutes les occurrences de "génial" par "super" dans la chaîne.

#### **6. Conversion de la casse des chaînes**

Il existe plusieurs méthodes pour modifier la **casse** d'une chaîne, c'est-à-dire pour la mettre en minuscules, majuscules, ou pour capitaliser la première lettre de chaque mot.

- **`lower()`** : Convertit tous les caractères en minuscules.

  ```python
  texte = "Python"
  print(texte.lower())  # "python"
  ```

- **`upper()`** : Convertit tous les caractères en majuscules.

  ```python
  texte = "Python"
  print(texte.upper())  # "PYTHON"
  ```

- **`title()`** : Met la première lettre de chaque mot en majuscule.

  ```python
  texte = "python est génial"
  print(texte.title())  # "Python Est Génial"
  ```

- **`capitalize()`** : Met la première lettre du premier mot en majuscule.

  ```python
  texte = "python est génial"
  print(texte.capitalize())  # "Python est génial"
  ```

#### **7. Suppression des espaces**

Les chaînes peuvent contenir des espaces au début ou à la fin, que vous pouvez supprimer avec la méthode `strip()`.

- **Exemple de suppression des espaces** :

  ```python
  texte = "  Bonjour   "
  print(texte.strip())  # "Bonjour"
  ```

Les méthodes `lstrip()` et `rstrip()` suppriment respectivement les espaces à gauche et à droite de la chaîne.

#### **8. Vérification de la chaîne**

Python offre plusieurs méthodes pour tester certaines propriétés d'une chaîne :

- **`startswith()`** : Vérifie si une chaîne commence par un préfixe donné.

  ```python
  texte = "Python est génial"
  print(texte.startswith("Python"))  # True
  ```

- **`endswith()`** : Vérifie si une chaîne se termine par un suffixe donné.

  ```python
  texte = "Python est génial"
  print(texte.endswith("génial"))  # True
  ```

- **`isalnum()`** : Vérifie si tous les caractères de la chaîne sont alphanumériques (lettres et chiffres).

  ```python
  texte = "Python123"
  print(texte.isalnum())  # True
  ```

- **`isalpha()`** : Vérifie si tous les caractères sont des lettres.

  ```python
  texte = "Python"
  print(texte.isalpha())  # True
  ```

- **`isdigit()`** : Vérifie si tous les caractères sont des chiffres.

  ```python
  texte = "12345"
  print(texte.isdigit())  # True
  ```

#### **9. Longueur de la chaîne**

La fonction `len()` permet de connaître la **longueur** d'une chaîne de caractères, c'est-à-dire le nombre d'éléments qu'elle contient (espaces compris).

- **Exemple de longueur** :

  ```python
  texte = "Python est génial"
  print(len(texte))  # 18
  ```

#### **10. Conclusion**

La manipulation des chaînes de caractères est une compétence clé pour travailler avec du texte en Python. Voici les points importants à retenir :

- **Concatenation** : Utilisation de l'opérateur `+` pour assembler des chaînes.
- **Découpage** : Utilisation du slicing pour extraire des sous-chaînes avec `[start:end]`.
- **Recherche** : Méthodes comme `find()` et l'opérateur `in` pour rechercher des sous-chaînes.
- **Remplacement** : Utilisation de `replace()` pour remplacer des sous-chaînes.
- **Conversion de la casse** : Méthodes comme `lower()`, `upper()`, `title()`, et `capitalize()`.
- **Suppression des espaces** : `strip()`, `lstrip()`, et `rstrip()` pour manipuler les espaces.
- **Vérification** : Méthodes comme `startswith()`, `endswith()`, `isalnum()`, et `isdigit()` pour tester des propriétés de la chaîne.

### Chap 13 **Développement de Jeux et Graphique 3D**

Python est une excellente plateforme pour se lancer dans le développement de jeux, qu'il s'agisse de projets simples en 2D ou de bases pour des interfaces graphiques et applications interactives. Deux bibliothèques populaires pour ces tâches sont **Pygame** et **Kivy**.

---

#### **1. Développement de Jeux 2D avec Pygame**

**Pygame** est une bibliothèque Python spécialement conçue pour le développement de jeux en 2D. Elle offre des outils pour gérer les graphiques, le son, les événements et les interactions utilisateur.

##### **Installation**
Pour installer Pygame, utilisez la commande suivante :
```bash
pip install pygame
```

##### **Fonctionnalités principales**
- Création de fenêtres et gestion des graphiques.
- Gestion des événements utilisateur (clavier, souris, etc.).
- Chargement et manipulation d'images et de sons.
- Animation et gestion de collisions.

##### **Exemple de jeu simple avec Pygame**
Voici un exemple d'application simple où un cercle rouge se déplace dans une fenêtre :
```python
import pygame
from pygame.locals import QUIT

# Initialisation de Pygame
pygame.init()

# Dimensions de la fenêtre
largeur, hauteur = 800, 600
fenetre = pygame.display.set_mode((largeur, hauteur))
pygame.display.set_caption("Exemple de jeu avec Pygame")

# Couleurs
rouge = (255, 0, 0)
blanc = (255, 255, 255)

# Position initiale
x, y = largeur // 2, hauteur // 2
vitesse = 5

# Boucle principale
running = True
while running:
    for event in pygame.event.get():
        if event.type == QUIT:
            running = False

    # Récupération des touches pressées
    touches = pygame.key.get_pressed()
    if touches[pygame.K_UP]:
        y -= vitesse
    if touches[pygame.K_DOWN]:
        y += vitesse
    if touches[pygame.K_LEFT]:
        x -= vitesse
    if touches[pygame.K_RIGHT]:
        x += vitesse

    # Dessin
    fenetre.fill(blanc)  # Efface l'écran
    pygame.draw.circle(fenetre, rouge, (x, y), 30)  # Dessine un cercle
    pygame.display.update()  # Met à jour l'écran

# Quitter Pygame
pygame.quit()
```

##### **Applications typiques de Pygame**
- Développement de jeux simples (plateformes, puzzles, jeux de tir, etc.).
- Création de simulations ou visualisations interactives.
- Projets éducatifs pour apprendre la programmation.

---

#### **2. Bases des Interfaces Graphiques avec Kivy**

**Kivy** est une bibliothèque Python open-source pour le développement d'applications interactives et multi-touch. Elle est adaptée pour créer des interfaces graphiques modernes, y compris pour les applications mobiles et les outils interactifs.

##### **Installation**
Pour installer Kivy, utilisez :
```bash
pip install kivy
```

##### **Fonctionnalités principales**
- Prise en charge multiplateforme (Windows, macOS, Linux, Android, iOS).
- Widgets interactifs (boutons, champs de texte, curseurs, etc.).
- Prise en charge du multi-touch pour les écrans tactiles.
- Système de layout flexible pour organiser les éléments d'interface.

##### **Exemple d'interface simple avec Kivy**
Voici un exemple basique d'application Kivy avec un bouton et un événement associé :
```python
from kivy.app import App
from kivy.uix.button import Button
from kivy.uix.boxlayout import BoxLayout

class MonApplication(App):
    def build(self):
        # Créer un layout vertical
        layout = BoxLayout(orientation='vertical')

        # Ajouter un bouton avec un événement
        bouton = Button(text="Cliquez-moi !")
        bouton.bind(on_press=self.afficher_message)
        layout.add_widget(bouton)

        return layout

    def afficher_message(self, instance):
        print("Bouton cliqué !")

# Lancer l'application
if __name__ == '__main__':
    MonApplication().run()
```

##### **Applications typiques de Kivy**
- Développement d'applications mobiles multiplateformes.
- Création d'interfaces utilisateur interactives pour des outils graphiques ou des jeux.
- Interfaces tactiles pour écrans interactifs.

---

### **Conclusion**

- **Pygame** est parfait pour créer des jeux 2D simples ou des projets interactifs éducatifs.
- **Kivy** est un outil polyvalent pour concevoir des interfaces graphiques modernes et des applications tactiles.

### Chap 14 ** Outils de Développement et Pratiques**

Python offre un écosystème riche en outils pour améliorer la productivité et la qualité du code. Voici un aperçu des outils de développement essentiels et des pratiques importantes pour les débutants.

---

#### **1. Utilisation basique des Environnements de Développement (IDE)**

Les Environnements de Développement Intégrés (IDE) sont des outils qui rendent l'écriture et la gestion du code Python plus efficaces. Deux des plus populaires pour Python sont **PyCharm** et **VSCode**.

##### **PyCharm**
- **Présentation** : Un IDE puissant conçu spécifiquement pour Python. Il offre des fonctionnalités avancées comme l'auto-complétion, le débogage intégré, et la gestion des environnements virtuels.
- **Installation** : Téléchargez depuis [jetbrains.com/pycharm](https://www.jetbrains.com/pycharm/).
- **Caractéristiques principales** :
  - Auto-complétion et suggestions de code.
  - Vérification syntaxique et mise en évidence des erreurs en temps réel.
  - Intégration facile des outils comme Git et les environnements virtuels.
  - Debugger graphique.

##### **VSCode (Visual Studio Code)**
- **Présentation** : Un éditeur de code léger et polyvalent, qui peut être étendu pour le développement Python avec l'extension officielle **Python**.
- **Installation** : Téléchargez depuis [code.visualstudio.com](https://code.visualstudio.com/).
- **Caractéristiques principales** :
  - Interface légère avec de nombreuses extensions.
  - Terminal intégré.
  - Débogage interactif.
  - Intégration facile avec d'autres langages et outils.

##### **Pourquoi utiliser un IDE ?**
- Augmente la productivité grâce aux outils intégrés.
- Facilite la gestion des projets avec des fonctionnalités comme la navigation dans le code, la gestion des dépendances et des outils de test.

---

#### **2. Introduction aux Tests Unitaires**

Les tests unitaires sont une pratique essentielle pour garantir que le code fonctionne comme prévu. Ils permettent de vérifier que les fonctions ou modules individuels produisent les résultats attendus.

##### **Unittest**
- **Présentation** : Une bibliothèque standard Python pour les tests unitaires.
- **Caractéristiques** :
  - Structuré et basé sur des classes.
  - Facile à intégrer dans des projets.
  - Permet de tester des cas normaux et des cas limites.

**Exemple de test unitaire avec `unittest`** :
```python
import unittest

# Fonction à tester
def addition(a, b):
    return a + b

# Classe de test
class TestAddition(unittest.TestCase):
    def test_positifs(self):
        self.assertEqual(addition(2, 3), 5)

    def test_negatifs(self):
        self.assertEqual(addition(-2, -3), -5)

if __name__ == '__main__':
    unittest.main()
```

##### **Pytest**
- **Présentation** : Une bibliothèque externe pour les tests, plus simple et plus puissante que `unittest`.
- **Caractéristiques** :
  - Moins de code pour écrire les tests.
  - Support des tests paramétrés.
  - Extensions disponibles pour des fonctionnalités avancées.

**Exemple de test avec `pytest`** :
```python
# Fonction à tester
def multiplication(a, b):
    return a * b

# Test
def test_multiplication():
    assert multiplication(2, 3) == 6
    assert multiplication(-2, 3) == -6
```

##### **Pourquoi utiliser des tests unitaires ?**
- Assure que le code fonctionne comme prévu.
- Réduit les risques d'erreurs lors des modifications.
- Simplifie la maintenance des projets.

---

#### **3. Débogage interactif avec pdb**

**Pdb** est le débogueur interactif intégré à Python. Il permet de repérer et de résoudre les erreurs dans le code en explorant son état en cours d'exécution.

##### **Principales commandes de pdb**
- **`pdb.set_trace()`** : Insérer un point d'arrêt dans le code.
- **Commandes essentielles** :
  - **`n`** (next) : Exécuter la ligne suivante.
  - **`c`** (continue) : Continuer jusqu'au prochain point d'arrêt.
  - **`l`** (list) : Afficher le code autour du point d'arrêt.
  - **`p`** (print) : Afficher la valeur d'une variable.

**Exemple de débogage avec `pdb`** :
```python
import pdb

def division(a, b):
    pdb.set_trace()  # Point d'arrêt
    return a / b

resultat = division(10, 2)
print(resultat)
```

##### **Avantages du débogage interactif**
- Exploration approfondie du comportement du code.
- Identification rapide des bugs.
- Permet de visualiser les variables et leur évolution.

---

### **Conclusion**

- **IDE** comme PyCharm et VSCode améliorent la productivité avec des outils intégrés.
- Les **tests unitaires** (avec `unittest` ou `pytest`) assurent la fiabilité du code.
- **Pdb** est un outil puissant pour identifier et résoudre les bugs.

### Chp 15 **Fichiers JSON : Lecture et Écriture**

#### **Qu’est-ce que JSON ?**
JSON (JavaScript Object Notation) est un format léger d'échange de données, largement utilisé dans les applications modernes pour transmettre des informations entre un client et un serveur. Il est lisible par les humains et facilement manipulable par les machines.

---

### **1. Le module `json` en Python**
Python inclut un module standard appelé `json`, utilisé pour lire et écrire des données au format JSON.

---

#### **2. Lire un fichier JSON**
Lire un fichier JSON signifie convertir son contenu en un objet Python manipulable (par exemple, dictionnaire ou liste).

**Méthode :**
- Utilisez `json.load()` pour lire le contenu d'un fichier JSON.
- Le résultat sera une structure Python native (dictionnaire, liste, etc.).

**Exemple :**

Supposons que le fichier `donnees.json` contient :

```json
{
    "nom": "Jean Dupont",
    "age": 30,
    "profession": "Développeur"
}
```

Code pour lire ce fichier :

```python
import json

# Lecture du fichier JSON
with open('donnees.json', 'r') as fichier:
    donnees = json.load(fichier)

print(donnees)  # {'nom': 'Jean Dupont', 'age': 30, 'profession': 'Développeur'}
print(donnees['nom'])  # Jean Dupont
```

---

#### **3. Écrire dans un fichier JSON**
Pour écrire des données Python dans un fichier JSON, utilisez `json.dump()`. 

**Méthode :**
- Préparez un dictionnaire ou une liste Python.
- Ouvrez un fichier en mode écriture (`w`).
- Utilisez `json.dump()` pour écrire les données dans le fichier.

**Exemple :**

Code pour écrire un fichier JSON :

```python
import json

# Dictionnaire Python à écrire dans un fichier JSON
donnees = {
    "nom": "Marie Curie",
    "age": 35,
    "profession": "Scientifique"
}

# Écriture dans un fichier JSON
with open('nouveau_fichier.json', 'w') as fichier:
    json.dump(donnees, fichier, indent=4)  # indent=4 pour un formatage lisible
```
**Résultat dans le fichier `nouveau_fichier.json` :**
```json
{
    "nom": "Marie Curie",
    "age": 35,
    "profession": "Scientifique"
}
```

---

#### **4. Manipuler JSON sous forme de chaîne**
Si vous travaillez avec des données JSON en tant que chaînes (sans fichier), utilisez :
- **`json.loads()`** : Convertit une chaîne JSON en un objet Python.
- **`json.dumps()`** : Convertit un objet Python en une chaîne JSON.

**Exemple :**

```python
import json

# Chaîne JSON
chaine_json = '{"ville": "Paris", "population": 2140526}'

# Conversion en dictionnaire Python
donnees = json.loads(chaine_json)
print(donnees['ville'])  # Paris

# Conversion inverse : dictionnaire Python en chaîne JSON
chaine_convertie = json.dumps(donnees, indent=2)
print(chaine_convertie)
```

---

### **5. Importance de JSON dans les applications modernes**
JSON est crucial pour :
- **Les API Web** : La plupart des services en ligne (comme les réseaux sociaux, les plateformes de paiement, etc.) utilisent JSON pour échanger des données.
- **Stockage léger** : JSON est souvent utilisé comme format de fichier pour des configurations ou des bases de données simples (ex. : MongoDB).
- **Interopérabilité** : JSON est compatible avec presque tous les langages de programmation.

---

### **6. Exemple complet d'utilisation**

Un exemple pratique pour gérer une liste de tâches avec JSON :

```python
import json

# Liste de tâches
taches = [
    {"id": 1, "titre": "Faire les courses", "status": "Non terminé"},
    {"id": 2, "titre": "Envoyer le rapport", "status": "Terminé"}
]

# Écriture dans un fichier JSON
with open('taches.json', 'w') as fichier:
    json.dump(taches, fichier, indent=4)

# Lecture du fichier JSON
with open('taches.json', 'r') as fichier:
    donnees = json.load(fichier)

# Afficher toutes les tâches
for tache in donnees:
    print(f"Tâche : {tache['titre']} - Status : {tache['status']}")
```

**Sortie :**

```
Tâche : Faire les courses - Status : Non terminé
Tâche : Envoyer le rapport - Status : Terminé
```

---

### **Conclusion**
La manipulation de JSON avec Python est simple grâce au module `json`. Cette compétence est indispensable pour interagir avec des APIs, gérer des fichiers de configuration, ou structurer des données de manière portable et lisible.

### Chap 16 **Modules Intégrés Importants en Python**

Python est livré avec une bibliothèque standard riche, qui contient des modules pour effectuer des tâches courantes. Voici une présentation rapide de quatre modules clés : **os**, **sys**, **random**, et **math**. Chacun joue un rôle essentiel dans différents domaines de la programmation.

---

### **1. Module `os`**
Le module **`os`** fournit des fonctions pour interagir avec le système d'exploitation. Il est utilisé pour manipuler les fichiers, les répertoires, et d'autres tâches liées au système.

**Fonctionnalités clés :**
- **Gérer les fichiers et répertoires :**
  - `os.mkdir()` : Créer un nouveau répertoire.
  - `os.remove()` : Supprimer un fichier.
  - `os.listdir()` : Lister les fichiers et dossiers dans un répertoire.
  - `os.rename()` : Renommer un fichier ou un répertoire.

- **Obtenir des informations système :**
  - `os.getcwd()` : Obtenir le répertoire de travail actuel.
  - `os.path` : Effectuer des opérations sur les chemins de fichiers (par exemple, vérifier si un chemin existe avec `os.path.exists()`).

**Exemple :**

```python
import os

# Obtenir le répertoire de travail actuel
print("Répertoire actuel :", os.getcwd())

# Créer un nouveau répertoire
os.mkdir("exemple_dossier")
print("Dossier créé :", os.listdir())
```

---

### **2. Module `sys`**
Le module **`sys`** fournit des fonctions et des variables utilisées pour manipuler l'environnement Python en cours d'exécution.

**Fonctionnalités clés :**
- **Gérer les arguments de la ligne de commande :**
  - `sys.argv` : Liste des arguments passés au script Python depuis la ligne de commande.

- **Gérer l'environnement Python :**
  - `sys.exit()` : Quitter le programme.
  - `sys.version` : Obtenir la version actuelle de Python.
  - `sys.path` : Liste des chemins où Python recherche des modules.

**Exemple :**

```python
import sys

# Afficher les arguments passés au script
print("Arguments :", sys.argv)

# Afficher la version de Python
print("Version de Python :", sys.version)
```

---

### **3. Module `random`**
Le module **`random`** est utilisé pour générer des nombres aléatoires et effectuer des opérations aléatoires sur des séquences.

**Fonctionnalités clés :**
- **Générer des nombres aléatoires :**
  - `random.randint(a, b)` : Générer un entier aléatoire entre `a` et `b`.
  - `random.uniform(a, b)` : Générer un nombre flottant aléatoire entre `a` et `b`.

- **Mélanger ou sélectionner dans une liste :**
  - `random.shuffle()` : Mélanger les éléments d'une liste.
  - `random.choice()` : Sélectionner un élément aléatoire dans une liste.

**Exemple :**

```python
import random

# Générer un entier aléatoire entre 1 et 10
nombre = random.randint(1, 10)
print("Nombre aléatoire :", nombre)

# Mélanger une liste
liste = [1, 2, 3, 4, 5]
random.shuffle(liste)
print("Liste mélangée :", liste)
```

---

### **4. Module `math`**
Le module **`math`** fournit des fonctions mathématiques avancées, telles que les calculs trigonométriques, logarithmiques et les manipulations de nombres.

**Fonctionnalités clés :**
- **Calculs mathématiques de base :**
  - `math.sqrt(x)` : Racine carrée de `x`.
  - `math.pow(x, y)` : `x` élevé à la puissance `y`.
  - `math.ceil(x)` : Arrondir vers le haut.
  - `math.floor(x)` : Arrondir vers le bas.

- **Constantes mathématiques :**
  - `math.pi` : La valeur de π (3,14159...).
  - `math.e` : La base des logarithmes naturels (2,718...).

- **Fonctions trigonométriques :**
  - `math.sin(x)`, `math.cos(x)`, `math.tan(x)` : Calculs trigonométriques (en radians).

**Exemple :**

```python
import math

# Calculer la racine carrée
print("Racine carrée de 16 :", math.sqrt(16))

# Calculer la valeur de π
print("Valeur de pi :", math.pi)

# Arrondir vers le haut et vers le bas
print("Arrondi vers le haut de 4.3 :", math.ceil(4.3))
print("Arrondi vers le bas de 4.7 :", math.floor(4.7))
```

---

### **Conclusion**
Ces modules intégrés couvrent des besoins essentiels pour :
- **`os`** : Gérer le système d'exploitation.
- **`sys`** : Interagir avec l'environnement Python.
- **`random`** : Introduire des éléments aléatoires dans vos programmes.
- **`math`** : Effectuer des calculs mathématiques avancés.

### Chap 18 **Erreurs et Exceptions en Python**

En Python, les erreurs se produisent lorsqu'une opération ou une instruction n'est pas exécutée correctement. Les **exceptions** sont un mécanisme qui permet de gérer ces erreurs de manière contrôlée, évitant que le programme ne se termine brutalement.

---

### **1. Introduction à la Gestion des Erreurs**

Python propose des blocs spécifiques pour détecter et gérer les erreurs dans le code. Les principaux mots-clés utilisés pour gérer les exceptions sont **`try`**, **`except`**, **`else`**, et **`finally`**.

- **`try`** : Contient le code susceptible de provoquer une erreur.
- **`except`** : Permet de capturer et de traiter une exception spécifique ou générale.
- **`else`** : (optionnel) Exécute du code si aucune exception ne survient.
- **`finally`** : (optionnel) Exécute du code, qu'une exception survienne ou non. Utile pour les opérations de nettoyage, comme fermer un fichier.

---

### **2. Exemple de Gestion Basique des Exceptions**

Voici un exemple simple qui montre comment utiliser un bloc `try` et `except` :

```python
try:
    nombre = int(input("Entrez un nombre : "))
    print("Le double de votre nombre est :", nombre * 2)
except ValueError:
    print("Erreur : Vous devez entrer un nombre valide.")
```

**Explications :**
- Si l'utilisateur entre une valeur non numérique, une exception de type **`ValueError`** est levée.
- Le programme capture cette erreur et affiche un message personnalisé au lieu de planter.

---

### **3. Utilisation de `else` et `finally`**

Les blocs **`else`** et **`finally`** permettent une gestion plus fine des opérations.

**Exemple :**

```python
try:
    fichier = open("exemple.txt", "r")
    contenu = fichier.read()
    print("Contenu du fichier :", contenu)
except FileNotFoundError:
    print("Erreur : Le fichier n'existe pas.")
else:
    print("Le fichier a été lu avec succès.")
finally:
    print("Fin de l'opération.")
    if 'fichier' in locals() and not fichier.closed:
        fichier.close()
```

**Fonctionnement :**
- Si le fichier est lu avec succès, le bloc `else` s'exécute.
- Le bloc `finally` est toujours exécuté, qu'une erreur survienne ou non, pour garantir que le fichier est fermé proprement.

---

### **4. Exceptions Courantes**

Voici une liste d'exceptions fréquentes en Python et leurs significations :

1. **`ValueError`** : Survient lorsque le type de donnée fourni n'est pas valide pour une opération.
   - Exemple : Convertir une chaîne non numérique en entier.

2. **`KeyError`** : Survient lorsque l'on tente d'accéder à une clé inexistante dans un dictionnaire.

   - Exemple :

     ```python
     d = {"clé1": "valeur1"}
     print(d["clé2"])  # Lève une KeyError
     ```

3. **`IndexError`** : Se produit lorsque l'on tente d'accéder à un index inexistant dans une liste.

   - Exemple :

     ```python
     liste = [1, 2, 3]
     print(liste[5])  # Lève une IndexError
     ```

4. **`TypeError`** : Survient lorsque l'on effectue une opération entre types incompatibles.
   - Exemple : Ajouter un nombre et une chaîne de caractères.

5. **`ZeroDivisionError`** : Se produit lorsqu'une division par zéro est tentée.

   - Exemple :

     ```python
     print(10 / 0)  # Lève une ZeroDivisionError
     ```

---

### **5. Lever des Exceptions Personnalisées**

Il est également possible de lever ses propres exceptions à l'aide du mot-clé **`raise`**.

**Exemple :**

```python
def verifier_age(age):
    if age < 0:
        raise ValueError("L'âge ne peut pas être négatif.")
    else:
        print("Âge valide :", age)

try:
    verifier_age(-5)
except ValueError as e:
    print("Erreur :", e)
```

---

### **6. Conseils pour Gérer les Exceptions**

1. **Évitez les `except` trop généraux** :
   - Évitez de capturer toutes les exceptions avec un simple `except:`. Spécifiez le type d'erreur attendu.

2. **Utilisez plusieurs blocs `except` si nécessaire** :
   - Vous pouvez capturer plusieurs types d'erreurs spécifiques dans un seul bloc `try`.

3. **Nettoyez les ressources dans `finally`** :
   - Lorsque vous travaillez avec des fichiers, des connexions réseau, ou des bases de données, utilisez `finally` pour vous assurer que les ressources sont libérées correctement.

---

### **Conclusion**

La gestion des erreurs et des exceptions est essentielle pour écrire des programmes robustes. En anticipant les erreurs possibles et en les gérant avec soin, vous pouvez éviter des comportements inattendus et offrir une meilleure expérience utilisateur.

### Chap 19 **Approfondissement sur les Listes en Python**

Les **listes** sont une structure de données essentielle en Python. Elles permettent de stocker une collection d'éléments ordonnés, qui peuvent être modifiés à tout moment. Voici un aperçu détaillé de leurs fonctionnalités, avec des méthodes courantes et des concepts avancés comme les compréhensions de liste.

---

### **1. Méthodes Courantes des Listes**

Les listes offrent de nombreuses méthodes intégrées pour manipuler leurs éléments. Voici les principales :

#### **Ajouter des éléments**

- **`append(x)`** : Ajoute un élément à la fin de la liste.

  ```python
  fruits = ["pomme", "banane"]
  fruits.append("orange")
  # Résultat : ["pomme", "banane", "orange"]
  ```

- **`extend(iterable)`** : Ajoute plusieurs éléments à la liste à partir d'un autre iterable (comme une autre liste ou un tuple).

  ```python
  fruits.extend(["kiwi", "mangue"])
  # Résultat : ["pomme", "banane", "kiwi", "mangue"]
  ```

- **`insert(index, x)`** : Insère un élément à une position spécifique.

  ```python
  fruits.insert(1, "cerise")
  # Résultat : ["pomme", "cerise", "banane"]
  ```

---

#### **Supprimer des éléments**

- **`pop(index)`** : Supprime et renvoie l'élément à la position donnée (par défaut, le dernier élément).

  ```python
  fruits.pop(1)
  # Résultat après suppression : ["pomme", "banane"]
  ```

- **`remove(x)`** : Supprime la première occurrence d'un élément donné.

  ```python
  fruits.remove("pomme")
  # Résultat : ["banane"]
  ```

- **`clear()`** : Vide complètement la liste.

  ```python
  fruits.clear()
  # Résultat : []
  ```

---

#### **Autres Méthodes Utiles**

- **`index(x, start, end)`** : Renvoie l'index de la première occurrence de l'élément `x` entre les indices `start` et `end`.

  ```python
  fruits = ["pomme", "banane", "orange"]
  print(fruits.index("banane"))  # Résultat : 1
  ```

- **`count(x)`** : Compte le nombre de fois qu'un élément apparaît dans la liste.

  ```python
  print(fruits.count("pomme"))  # Résultat : 1
  ```

- **`sort(reverse=False)`** : Trie la liste en place (ordre croissant par défaut).

  ```python
  fruits.sort()
  # Résultat : ["banane", "orange", "pomme"]
  ```

- **`reverse()`** : Inverse l'ordre des éléments.

  ```python
  fruits.reverse()
  # Résultat : ["orange", "banane", "pomme"]
  ```

- **`copy()`** : Renvoie une copie de la liste.

  ```python
  copie_fruits = fruits.copy()
  ```

---

### **2. Compréhensions de Liste**

Les compréhensions de liste sont une manière concise et élégante de créer des listes en Python. Elles permettent de générer des listes à partir d'itérables existants tout en appliquant des conditions ou des transformations.

#### **Syntaxe Générale :**

```python
nouvelle_liste = [expression for élément in iterable if condition]
```

#### **Exemples :**

1. **Créer une liste à partir d'une plage de nombres** :

   ```python
   carrés = [x**2 for x in range(5)]
   # Résultat : [0, 1, 4, 9, 16]
   ```

2. **Filtrer les éléments avec une condition** :

   ```python
   pairs = [x for x in range(10) if x % 2 == 0]
   # Résultat : [0, 2, 4, 6, 8]
   ```

3. **Transformer les éléments d'une liste existante** :

   ```python
   fruits = ["pomme", "banane", "orange"]
   fruits_maj = [fruit.upper() for fruit in fruits]
   # Résultat : ["POMME", "BANANE", "ORANGE"]
   ```

4. **Combiner plusieurs itérables** :
   ```python
   produits = [(x, y) for x in range(2) for y in range(3)]
   # Résultat : [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)]
   ```

---

### **3. Manipulations Avancées**

#### **Vérifications**

- **Vérifier si un élément est présent** :

  ```python
  print("pomme" in fruits)  # Résultat : True
  ```

- **Longueur de la liste** :

  ```python
  print(len(fruits))  # Renvoie le nombre d'éléments.
  ```

#### **Slicing (Découpage)**

- Obtenir une partie d'une liste :

  ```python
  sous_liste = fruits[1:3]
  # Résultat : ["banane", "orange"]
  ```

- Inverser une liste avec le slicing :

  ```python
  fruits_inverse = fruits[::-1]
  # Résultat : ["orange", "banane", "pomme"]
  ```

---

### **4. Conseils pour Utiliser les Listes**

1. **Évitez les copies inutiles** : Si vous avez besoin d'une copie, utilisez **`copy()`** pour éviter de modifier l'original.
2. **Privilégiez les compréhensions de liste** : Elles sont plus rapides et plus lisibles que les boucles classiques pour transformer des listes.
3. **Utilisez des types adaptés** : Si vous avez besoin d'une structure immuable, envisagez d'utiliser un **tuple**.

---

### **Conclusion**

Les listes sont une structure de données puissante et polyvalente en Python. Grâce à leurs nombreuses méthodes et à la possibilité d'utiliser les compréhensions, elles permettent de manipuler les données de manière efficace. Apprendre à maîtriser les listes est un pas essentiel pour progresser en Python.

### Chap 20 **Introduction aux Types de Collections Avancées en Python**

Le module **`collections`** de Python propose plusieurs types de collections avancées qui étendent les fonctionnalités des structures de données de base comme les listes et les dictionnaires. Parmi ces outils, les **`deque`**, **`Counter`**, et **`defaultdict`** sont particulièrement utiles pour résoudre des problèmes spécifiques de manière efficace.

---

### **1. `deque` (Double-Ended Queue)**

La **`deque`** est une structure de données optimisée pour ajouter ou retirer des éléments à ses deux extrémités (gauche ou droite). Elle est plus performante que les listes pour ce type d'opérations grâce à son implémentation basée sur des blocs de mémoire.

#### **Caractéristiques principales :**
- Accès rapide pour les opérations en **O(1)** (ajout/suppression) aux deux extrémités.
- Peut être utilisée comme une pile, une file d'attente ou une file d'attente circulaire.

#### **Exemple d'utilisation :**

```python
from collections import deque

# Création d'une deque
d = deque(["pomme", "banane", "cerise"])

# Ajouter à droite et à gauche
d.append("orange")       # ["pomme", "banane", "cerise", "orange"]
d.appendleft("kiwi")     # ["kiwi", "pomme", "banane", "cerise", "orange"]

# Supprimer à droite et à gauche
d.pop()                  # ["kiwi", "pomme", "banane", "cerise"]
d.popleft()              # ["pomme", "banane", "cerise"]

# Rotation des éléments
d.rotate(1)              # ["cerise", "pomme", "banane"] (rotation à droite)
d.rotate(-2)             # ["banane", "cerise", "pomme"] (rotation à gauche)
```

---

### **2. `Counter`**

Le **`Counter`** est une collection spécialisée pour compter les occurrences des éléments dans un iterable. Il fonctionne comme un dictionnaire où les clés sont les éléments et les valeurs sont leurs fréquences.

#### **Exemple d'utilisation :**

```python
from collections import Counter

# Compter les occurrences dans une liste
fruits = ["pomme", "banane", "pomme", "orange", "banane", "pomme"]
compteur = Counter(fruits)

# Résultat : Counter({'pomme': 3, 'banane': 2, 'orange': 1})
print(compteur)

# Méthodes utiles
print(compteur.most_common(1))  # Élément le plus fréquent : [('pomme', 3)]
print(list(compteur.elements()))  # Liste des éléments répétés selon leur fréquence

# Mise à jour des comptes
compteur.update(["pomme", "kiwi"])  # Ajoute 1 pour chaque élément de la liste
print(compteur)  # Counter({'pomme': 4, 'banane': 2, 'orange': 1, 'kiwi': 1})
```

#### **Applications courantes :**
- Analyse de texte (compter les mots ou caractères).
- Recherche des éléments les plus fréquents dans des données.

---

### **3. `defaultdict`**

Le **`defaultdict`** est une sous-classe de `dict` qui fournit une valeur par défaut pour une clé inexistante. Cela évite d'avoir à vérifier si une clé est présente avant d'ajouter ou de modifier sa valeur.

#### **Exemple d'utilisation :**

```python
from collections import defaultdict

# Création d'un defaultdict avec une valeur par défaut (ici, une liste vide)
d = defaultdict(list)

# Ajouter des éléments sans vérifier l'existence de la clé
d["fruits"].append("pomme")
d["fruits"].append("banane")
d["légumes"].append("carotte")

print(d)
# Résultat : defaultdict(<class 'list'>, {'fruits': ['pomme', 'banane'], 'légumes': ['carotte']})
```

#### **Valeurs par défaut courantes :**

- **`int`** : Pour compter les occurrences.
  ```python
  compteur = defaultdict(int)
  compteur["pomme"] += 1  # Ajoute automatiquement 1 à une clé inexistante
  print(compteur)  # {'pomme': 1}
  ```

- **`set`** : Pour stocker des éléments uniques.

  ```python
  groupes = defaultdict(set)
  groupes["groupe1"].add("Alice")
  groupes["groupe1"].add("Bob")
  print(groupes)  # {'groupe1': {'Alice', 'Bob'}}
  ```

---

### **Comparaison des Trois Collections**

| **Type**         | **Usage Principal**                          | **Avantages**                                     |
|-------------------|---------------------------------------------|--------------------------------------------------|
| `deque`          | Ajouter/supprimer aux deux extrémités        | Performances optimales pour files d'attente/piles|
| `Counter`        | Compter les occurrences d'éléments           | Syntaxe simple pour statistiques et analyses     |
| `defaultdict`    | Associer des valeurs par défaut aux clés      | Évite les vérifications explicites des clés      |

---

### **Conclusion**

Les types de collections avancées du module **`collections`** offrent des solutions élégantes et performantes pour des problèmes spécifiques. En intégrant ces outils dans vos programmes Python, vous pouvez simplifier votre code tout en améliorant son efficacité. Ces structures sont particulièrement utiles dans le traitement des données, les algorithmes, et la manipulation de grandes collections.

### Chap 21 **Chaînes de Caractères Avancées en Python**

Les chaînes de caractères (**`str`**) en Python offrent de nombreuses fonctionnalités avancées pour manipuler, rechercher, et formater du texte. Ces outils permettent de travailler de manière efficace avec des données textuelles.

---

### **1. Méthodes Avancées sur les Chaînes**

#### **Méthodes pour vérifier le début ou la fin d'une chaîne :**

- **`startswith(substring)`** : Vérifie si la chaîne commence par un sous-texte spécifique.

  ```python
  texte = "Bonjour tout le monde"
  print(texte.startswith("Bonjour"))  # True
  print(texte.startswith("tout"))     # False
  ```

- **`endswith(substring)`** : Vérifie si la chaîne se termine par un sous-texte spécifique.

  ```python
  print(texte.endswith("monde"))      # True
  print(texte.endswith("tout"))       # False
  ```

#### **Méthodes pour rechercher dans une chaîne :**

- **`find(substring)`** : Retourne l'index de la première occurrence d'une sous-chaîne. Si elle n'existe pas, retourne `-1`.

  ```python
  texte = "Python est un langage puissant"
  print(texte.find("langage"))  # 12 (l'index où commence "langage")
  print(texte.find("Java"))     # -1 (non trouvé)
  ```

- **`rfind(substring)`** : Comme `find`, mais recherche la dernière occurrence.

  ```python
  texte = "Le soleil se lève à l'est"
  print(texte.rfind("e"))  # 23 (dernière occurrence de "e")
  ```

#### **Méthodes pour vérifier le contenu :**

- **`isalpha()`** : Vérifie si la chaîne contient uniquement des lettres.
- **`isdigit()`** : Vérifie si la chaîne contient uniquement des chiffres.
- **`isspace()`** : Vérifie si la chaîne contient uniquement des espaces.
  ```python
  print("123".isdigit())   # True
  print("Hello".isalpha()) # True
  print("   ".isspace())   # True
  ```

---

### **2. Formatage Avancé des Chaînes**

Le formatage des chaînes permet de créer du texte dynamique en y insérant des variables ou des résultats de calculs.

#### **`f-strings` (Formatage Littéral)**

Introduites dans Python 3.6, les **`f-strings`** sont une manière concise et efficace de formater des chaînes.

- **Exemple de base :**

  ```python
  nom = "Alice"
  age = 25
  print(f"Je m'appelle {nom} et j'ai {age} ans.")  # Je m'appelle Alice et j'ai 25 ans.
  ```

- **Expressions dans les f-strings :**

  ```python
  print(f"Dans 5 ans, j'aurai {age + 5} ans.")  # Calcul dans une f-string
  ```

- **Formatage de nombres :**

  ```python
  pi = 3.14159
  print(f"La valeur de pi est {pi:.2f}")  # La valeur de pi est 3.14 (2 décimales)
  ```

#### **`str.format()`**


Une méthode plus ancienne mais toujours utilisée pour formater des chaînes.

- **Exemple de base :**

  ```python
  texte = "Je m'appelle {} et j'ai {} ans.".format("Alice", 25)
  print(texte)  # Je m'appelle Alice et j'ai 25 ans.
  ```

- **Références par position ou nom :**

  ```python
  print("Bonjour {1}, {0} ans.".format(25, "Alice"))  # Bonjour Alice, 25 ans.
  print("Nom : {nom}, Âge : {age}".format(nom="Alice", age=25))
  ```

#### **Comparaison entre `f-strings` et `str.format` :**

- **`f-strings`** : Plus lisibles et performantes.
- **`str.format`** : Plus flexibles dans certains cas (par exemple, dans des configurations dynamiques).

---

### **3. Cas d'Utilisation Courants**

#### **Concaténation de chaînes :**

Combinez plusieurs chaînes en une seule.

```python
nom = "Python"
version = "3.10"
chaine = "Langage: " + nom + ", Version: " + version
print(chaine)  # Langage: Python, Version: 3.10
```

#### **Découpe de chaînes (`split`) et assemblage (`join`) :**

- Découper une chaîne en une liste de mots :

  ```python
  texte = "Un texte avec plusieurs mots"
  mots = texte.split()  # ['Un', 'texte', 'avec', 'plusieurs', 'mots']
  ```
- Réassembler une liste en chaîne :

  ```python
  nouvelle_chaine = " ".join(mots)
  print(nouvelle_chaine)  # Un texte avec plusieurs mots
  ```

#### **Nettoyage de chaînes (`strip`) :**

- Supprimer les espaces inutiles au début ou à la fin :

  ```python
  chaine = "   Python   "
  print(chaine.strip())  # "Python"
  ```

---

### **Conclusion**

Les chaînes de caractères en Python sont extrêmement puissantes et flexibles grâce à leurs nombreuses méthodes intégrées. En combinant des techniques comme la recherche, le formatage, et la manipulation, vous pouvez gérer efficacement des données textuelles pour une large gamme d'applications, du traitement de texte simple à l'analyse de données avancée.

### Chap 22 **Modules Standards Courants en Python**

Python propose une vaste bibliothèque standard contenant des modules qui simplifient le développement de nombreuses tâches courantes. Voici une présentation des modules **`math`**, **`random`**, et **`os`**, accompagnée de leurs principales fonctionnalités.

---

### **1. Module `math` : Opérations Mathématiques**

Le module **`math`** fournit des fonctions pour effectuer des calculs mathématiques avancés.

#### **Fonctionnalités principales :**

- **Opérations de base :**
  - **`math.sqrt(x)`** : Racine carrée de `x`.
  - **`math.pow(x, y)`** : Exponentiation, retourne `x^y`.
- **Constantes mathématiques :**
  - **`math.pi`** : Approximation de π.
  - **`math.e`** : Base du logarithme naturel.
- **Trigonométrie :**
  - **`math.sin(x)`, `math.cos(x)`, `math.tan(x)`** : Fonctions trigonométriques (en radians).
  - **`math.radians(x)`** : Convertit des degrés en radians.
  - **`math.degrees(x)`** : Convertit des radians en degrés.
- **Arrondi et manipulation :**
  - **`math.ceil(x)`** : Arrondi au supérieur.
  - **`math.floor(x)`** : Arrondi à l'inférieur.

#### **Exemple d'utilisation :**

```python
import math

angle = 45
radians = math.radians(angle)
print(f"Sinus de {angle}° : {math.sin(radians)}")
print(f"Valeur de pi : {math.pi}")
```

---

### **2. Module `random` : Génération Aléatoire**

Le module **`random`** permet de générer des nombres aléatoires ou de manipuler des séquences de manière aléatoire.

#### **Fonctionnalités principales :**

- **Nombres aléatoires :**
  - **`random.random()`** : Retourne un nombre flottant entre 0.0 et 1.0.
  - **`random.randint(a, b)`** : Retourne un entier aléatoire entre `a` et `b` inclus.
  - **`random.uniform(a, b)`** : Retourne un flottant aléatoire entre `a` et `b`.
- **Manipulation de séquences :**
  - **`random.choice(seq)`** : Retourne un élément aléatoire d'une séquence (liste, chaîne, etc.).
  - **`random.shuffle(seq)`** : Mélange les éléments d'une liste.
  - **`random.sample(seq, k)`** : Sélectionne aléatoirement `k` éléments d'une séquence.
- **Fonctions avancées :**
  - **`random.seed(x)`** : Définit une graine pour obtenir des résultats reproductibles.

#### **Exemple d'utilisation :**

```python
import random

# Génération d'un nombre aléatoire
print(f"Nombre entier aléatoire entre 1 et 10 : {random.randint(1, 10)}")

# Mélange d'une liste
liste = [1, 2, 3, 4, 5]
random.shuffle(liste)
print(f"Liste mélangée : {liste}")
```

---

### **3. Module `os` : Interaction avec le Système d'Exploitation**

Le module **`os`** fournit des outils pour interagir avec le système d'exploitation, tels que la gestion des fichiers, des dossiers, et des variables d'environnement.

#### **Fonctionnalités principales :**

- **Informations système :**
  - **`os.name`** : Retourne le nom du système d'exploitation (par exemple, `'posix'` pour Linux/Mac et `'nt'` pour Windows).
  - **`os.getcwd()`** : Retourne le répertoire de travail actuel.
- **Gestion des répertoires :**
  - **`os.mkdir(path)`** : Crée un nouveau répertoire.
  - **`os.listdir(path)`** : Liste le contenu d'un répertoire.
  - **`os.chdir(path)`** : Change le répertoire de travail actuel.
- **Manipulation des fichiers :**
  - **`os.remove(path)`** : Supprime un fichier.
  - **`os.rename(old, new)`** : Renomme un fichier ou un répertoire.
- **Variables d'environnement :**
  - **`os.environ`** : Accède aux variables d'environnement.

#### **Exemple d'utilisation :**

```python
import os

# Obtenir le répertoire actuel
print(f"Répertoire actuel : {os.getcwd()}")

# Créer un répertoire
os.mkdir("NouveauDossier")
print(f"Contenu du répertoire : {os.listdir()}")
```

---

### **Conclusion**

Ces modules standard sont essentiels pour résoudre des problèmes courants en Python. En maîtrisant des modules comme **`math`**, **`random`**, et **`os`**, vous pouvez effectuer des calculs avancés, manipuler des données aléatoires, et interagir avec le système d'exploitation de manière simple et efficace.

### Chap 23 **Gestion des Erreurs Simples en Python**

La gestion des erreurs est une compétence essentielle en programmation. Elle permet de capturer des situations imprévues, d'éviter des interruptions brusques du programme et de fournir des messages d'erreur informatifs.

---

### **1. Pourquoi gérer les erreurs ?**

Lorsqu'une erreur survient dans un programme Python, celui-ci s'interrompt par défaut et affiche un message d'erreur (exception). Exemple :

```python
print(10 / 0)  # Provoque une ZeroDivisionError
```

Pour éviter de tels arrêts brutaux, Python propose une structure pour gérer ces erreurs : **`try`** et **`except`**.

---

### **2. Syntaxe de base de la gestion d'erreurs**

La gestion d'erreurs en Python suit une structure simple :

```python
try:
    # Code susceptible de provoquer une erreur
    opération_risqueuse
except TypeErreur:
    # Code exécuté si l'erreur spécifique survient
    action_corrigée
```

#### **Étapes :**
1. **`try`** : Contient le code qui pourrait générer une erreur.
2. **`except`** : Capture l'erreur si elle survient.
3. (Facultatif) **`else`** : Contient le code à exécuter si aucune erreur n'est levée.
4. (Facultatif) **`finally`** : Contient le code qui s'exécute dans tous les cas, qu'une erreur soit levée ou non.

---

### **3. Gestion des erreurs courantes**

#### **Exemple 1 : Division par zéro**

```python
try:
    résultat = 10 / 0
except ZeroDivisionError:
    print("Erreur : Division par zéro non permise.")
```

#### **Exemple 2 : Conversion invalide**

```python
try:
    nombre = int("abc")  # Tentative de conversion invalide
except ValueError:
    print("Erreur : Impossible de convertir la chaîne en entier.")
```

#### **Exemple 3 : Accès à une clé manquante dans un dictionnaire**

```python
mon_dict = {"clé1": "valeur1"}
try:
    print(mon_dict["clé2"])
except KeyError:
    print("Erreur : La clé demandée n'existe pas dans le dictionnaire.")
```

---

### **4. Gestion multiple d'erreurs**

Vous pouvez capturer différents types d'erreurs dans le même bloc **`try`**.

```python
try:
    x = int(input("Entrez un nombre : "))
    résultat = 10 / x
except ValueError:
    print("Erreur : Vous devez entrer un nombre.")
except ZeroDivisionError:
    print("Erreur : Division par zéro non permise.")
```

---

### **5. Blocs `else` et `finally`**

#### **`else`** : Exécuté uniquement si aucune erreur n'est survenue dans le bloc `try`.

```python
try:
    x = int(input("Entrez un nombre : "))
except ValueError:
    print("Erreur : Entrée invalide.")
else:
    print(f"Vous avez entré : {x}")
```

#### **`finally`** : Exécuté dans tous les cas (utilisé pour les tâches de nettoyage, comme fermer un fichier).

```python
try:
    fichier = open("test.txt", "r")
    contenu = fichier.read()
except FileNotFoundError:
    print("Erreur : Fichier non trouvé.")
finally:
    print("Bloc finally exécuté.")
    fichier.close()
```

---

### **6. Erreurs courantes et leurs significations**

- **`ValueError`** : Tentative d'utiliser une valeur incorrecte pour une opération (exemple : conversion).
- **`ZeroDivisionError`** : Division par zéro.
- **`KeyError`** : Accès à une clé inexistante dans un dictionnaire.
- **`IndexError`** : Tentative d'accéder à un index en dehors des limites d'une liste.
- **`TypeError`** : Utilisation d'un type de données incorrect dans une opération.
- **`FileNotFoundError`** : Tentative d'ouvrir un fichier inexistant.

---

### **7. Bonnes pratiques**

1. **Spécifiez les types d'erreurs :** Évitez les **`except`** génériques, qui masquent les erreurs imprévues.

   ```python
   try:
       résultat = 10 / "abc"
   except Exception:  # Mauvaise pratique
       print("Erreur.")
   ```

   Préférez capturer des erreurs spécifiques :

   ```python
   except TypeError:
       print("Erreur de type détectée.")
   ```

2. **Messages d'erreur informatifs :** Fournissez des explications claires à l'utilisateur.
3. **Limitez la portée des blocs `try`:** Placez uniquement le code potentiellement risqué dans le bloc `try`.

---

### **Conclusion**

La gestion des erreurs avec **`try`** et **`except`** est indispensable pour rendre un programme robuste et facile à déboguer. En capturant des exceptions courantes comme **`ValueError`** ou **`KeyError`**, vous pouvez prévenir des comportements imprévus et améliorer l'expérience utilisateur.

Niveau Intermédiaire 

### Chap 1 **Compréhension de liste (List Comprehension)**

La **compréhension de liste** est une technique puissante et concise pour créer de nouvelles listes en appliquant des expressions et des conditions de manière déclarative. Elle permet de générer des listes rapidement tout en améliorant la lisibilité du code et en réduisant le nombre de lignes nécessaires par rapport à l'utilisation de boucles `for` classiques.

#### 1. **Structure de base de la compréhension de liste**

La structure de base d'une compréhension de liste est la suivante :

```python
[expression for element in iterable]
```
- **expression** : C'est ce que vous souhaitez ajouter dans la nouvelle liste, qui peut être une simple valeur ou un calcul appliqué à chaque élément de l'itérable.
- **for element in iterable** : Cette partie parcourt chaque élément de l'itérable (par exemple une liste, un ensemble, une plage de nombres, etc.) et applique l'expression à chaque élément.

**Exemple :**

```python
# Créer une liste des carrés des nombres de 0 à 9
squares = [x**2 for x in range(10)]
print(squares)
```

**Sortie :**

```
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

#### 2. **Ajout de conditions dans la compréhension de liste**

Vous pouvez ajouter des conditions pour filtrer les éléments de l'itérable. La syntaxe pour une condition est placée à la fin de la compréhension de liste :
```python
[expression for element in iterable if condition]
```
- **condition** : Une expression conditionnelle qui permet de filtrer les éléments qui satisfont cette condition.

**Exemple :**

```python
# Créer une liste des carrés des nombres pairs entre 0 et 9
even_squares = [x**2 for x in range(10) if x % 2 == 0]
print(even_squares)
```

**Sortie :**

```
[0, 4, 16, 36, 64]
```
Dans cet exemple, la condition `x % 2 == 0` permet de ne sélectionner que les nombres pairs avant d'appliquer l'expression `x**2`.

#### 3. **Compréhension de liste avec plusieurs conditions**

Il est possible d'ajouter plusieurs conditions dans une compréhension de liste. Chaque condition est placée après le `if` ou dans la même clause `if` avec des opérateurs logiques (comme `and`, `or`).

**Exemple :**

```python
# Créer une liste des carrés des nombres pairs supérieurs à 3
even_squares_above_3 = [x**2 for x in range(10) if x % 2 == 0 and x > 3]
print(even_squares_above_3)
```

**Sortie :**

```
[16, 36, 64]
```

#### 4. **Utilisation d'expressions complexes dans la compréhension**

La partie **expression** peut être aussi complexe que nécessaire. Cela peut inclure des appels de fonction, des opérations mathématiques, ou même des expressions conditionnelles à l'intérieur de l'expression elle-même.

**Exemple :**

```python
# Créer une liste des résultats de l'addition de 10 à chaque nombre de 0 à 4
incremented_numbers = [x + 10 for x in range(5)]
print(incremented_numbers)
```

**Sortie :**

```
[10, 11, 12, 13, 14]
```

#### 5. **Compréhension de liste imbriquée**

Il est également possible d'utiliser des compréhensions de liste imbriquées. Cela signifie que vous pouvez avoir une compréhension de liste à l'intérieur d'une autre. Cela est utile pour traiter des structures de données comme des matrices ou des tableaux à plusieurs dimensions.

**Exemple :**

```python
# Créer une matrice 3x3 avec des valeurs multiples
matrix = [[(i + j) for j in range(3)] for i in range(3)]
print(matrix)
```

**Sortie :**

```
[[0, 1, 2], [1, 2, 3], [2, 3, 4]]
```
Dans cet exemple, la compréhension de liste imbriquée crée une matrice 3x3 où chaque élément est la somme de ses indices.

#### 6. **Utilisation de la compréhension de liste avec des dictionnaires et des ensembles**

Les compréhensions de liste peuvent également être utilisées pour créer des dictionnaires ou des ensembles de manière similaire.

- **Compréhension de dictionnaire :**

```python
# Créer un dictionnaire où les clés sont les nombres et les valeurs leurs carrés
square_dict = {x: x**2 for x in range(5)}
print(square_dict)
```

**Sortie :**

```
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
```

- **Compréhension d'ensemble :**

```python
# Créer un ensemble des carrés des nombres de 0 à 9
square_set = {x**2 for x in range(10)}
print(square_set)
```

**Sortie :**

```
{0, 1, 4, 9, 16, 25, 36, 49, 64, 81}
```

#### 7. **Performance des compréhensions de liste**

Les compréhensions de liste sont non seulement plus concises, mais elles sont aussi généralement plus performantes que les boucles `for` classiques. Elles sont optimisées au niveau du compilateur Python et évitent la nécessité de créer un objet temporaire pour chaque itération.

**Exemple de comparaison de performance :**

```python
import time

# Utilisation d'une boucle for classique
start_time = time.time()
squares_loop = []
for x in range(1000000):
    squares_loop.append(x**2)
print("Temps avec boucle for : ", time.time() - start_time)

# Utilisation de la compréhension de liste
start_time = time.time()
squares_comprehension = [x**2 for x in range(1000000)]
print("Temps avec compréhension de liste : ", time.time() - start_time)
```

En règle générale, la compréhension de liste est plus rapide en raison de son optimisation.

#### Conclusion

La compréhension de liste est un outil puissant en Python pour générer des listes de manière concise et élégante. Elle permet d'écrire des expressions complexes de manière lisible tout en améliorant les performances du code. L'utilisation de conditions et de structures imbriquées rend cette technique encore plus flexible et polyvalente.

### Chap 2 **Fonctions Lambda en Python**

Les **fonctions lambda** sont des fonctions anonymes en Python, créées avec le mot-clé `lambda`. Elles permettent de définir des fonctions simples de manière concise et généralement en une seule ligne. Contrairement aux fonctions classiques définies avec `def`, les fonctions lambda ne nécessitent pas de nom et sont souvent utilisées pour des opérations simples ou comme arguments dans des fonctions de traitement.

#### 1. **Syntaxe de base des fonctions lambda**

La syntaxe d'une fonction lambda est la suivante :

```python
lambda arguments: expression
```
- **arguments** : Ce sont les paramètres d'entrée de la fonction (similaires à ceux des fonctions classiques).
- **expression** : L'expression est évaluée et renvoyée comme résultat de la fonction lambda.

**Exemple simple :**

```python
# Fonction lambda qui additionne deux nombres
add = lambda x, y: x + y
print(add(2, 3))  # Sortie : 5
```
Ici, `lambda x, y: x + y` définit une fonction qui prend deux arguments (`x` et `y`), et renvoie leur somme.

#### 2. **Utilisation des fonctions lambda avec des fonctions intégrées**

Les fonctions lambda sont souvent utilisées en combinaison avec des fonctions intégrées de Python comme `map()`, `filter()`, et `sorted()`.

- **`map()`** : Applique une fonction à tous les éléments d'un itérable et renvoie une nouvelle liste.

```python
# Appliquer une fonction lambda pour doubler chaque élément de la liste
numbers = [1, 2, 3, 4]
doubled = map(lambda x: x * 2, numbers)
print(list(doubled))  # Sortie : [2, 4, 6, 8]
```

- **`filter()`** : Filtre les éléments d'un itérable selon une condition définie dans la fonction lambda.

```python
# Filtrer les nombres pairs de la liste
numbers = [1, 2, 3, 4, 5, 6]
evens = filter(lambda x: x % 2 == 0, numbers)
print(list(evens))  # Sortie : [2, 4, 6]
```

- **`sorted()`** : Trier une liste en utilisant une fonction lambda pour définir la clé de tri.

```python
# Trier une liste de tuples par le deuxième élément
pairs = [(1, 2), (3, 1), (5, 0)]
sorted_pairs = sorted(pairs, key=lambda x: x[1])
print(sorted_pairs)  # Sortie : [(5, 0), (3, 1), (1, 2)]
```

#### 3. **Utilisation des fonctions lambda avec des arguments par défaut**

Comme pour les fonctions classiques, les fonctions lambda peuvent accepter des arguments par défaut. Cela permet de créer des fonctions lambda plus flexibles.

**Exemple :**

```python
# Fonction lambda avec un argument par défaut
multiply = lambda x, y=2: x * y
print(multiply(3))  # Sortie : 6 (car y prend la valeur par défaut 2)
print(multiply(3, 4))  # Sortie : 12 (y prend la valeur 4)
```

#### 4. **Fonctions lambda et expressions conditionnelles**

Les fonctions lambda peuvent inclure des expressions conditionnelles pour appliquer des décisions simples dans une seule ligne.

**Syntaxe d'une expression conditionnelle dans une lambda :**

```python
lambda arguments: expression1 if condition else expression2
```

- **condition** : L'expression conditionnelle qui décide quelle expression sera évaluée.
- **expression1** et **expression2** : Les deux expressions possibles selon que la condition soit vraie ou fausse.

**Exemple :**

```python
# Fonction lambda qui renvoie "pair" si le nombre est pair, sinon "impair"
check_parity = lambda x: "pair" if x % 2 == 0 else "impair"
print(check_parity(4))  # Sortie : pair
print(check_parity(5))  # Sortie : impair
```

#### 5. **Limites des fonctions lambda**

Bien que les fonctions lambda soient utiles pour des opérations simples, elles ne sont pas adaptées pour des opérations complexes. En effet, elles sont limitées à une seule expression et ne peuvent pas contenir de déclarations complexes, de boucles ou de structures de contrôle.

**Exemple d'une fonction lambda invalide :**

```python
# Ceci est incorrect car une fonction lambda ne peut pas contenir plusieurs déclarations
lambda x: if x > 0: print("Positif") else: print("Négatif")
```
Dans ce cas, on ne peut pas utiliser des structures comme `if` directement dans une lambda avec des instructions multiples.

#### 6. **Fonctions lambda dans les applications avancées**

Les fonctions lambda sont également couramment utilisées dans les applications avancées telles que les callbacks, où une fonction est transmise à une autre fonction pour être exécutée à un moment ultérieur.

**Exemple :**

```python
# Passer une fonction lambda comme argument pour exécuter un calcul personnalisé
def apply_function(f, value):
    return f(value)

result = apply_function(lambda x: x**2, 4)
print(result)  # Sortie : 16
```

#### 7. **Comparaison avec les fonctions définies avec `def`**

Les fonctions lambda sont idéales pour des opérations simples et concises. Cependant, elles ont des limitations qui rendent l’utilisation des fonctions classiques (`def`) préférable pour des opérations plus complexes.

- **Fonction lambda :**

```python
# Fonction lambda pour additionner deux nombres
add = lambda x, y: x + y
```

- **Fonction classique :**

```python
# Fonction classique pour additionner deux nombres
def add(x, y):
    return x + y
```

Les fonctions définies avec `def` sont plus lisibles, peuvent être documentées avec des docstrings, et peuvent inclure des instructions plus complexes (boucles, conditions multiples, etc.).

#### 8. **Avantages des fonctions lambda**

- **Concises et lisibles** : Elles permettent de définir des fonctions simples en une ligne, ce qui rend le code plus compact.
- **Flexibles** : Elles peuvent être utilisées pour des opérations rapides et dans des contextes où une fonction nommée classique serait trop lourde.
- **Parfaites pour les fonctions d'ordre supérieur** : Les fonctions lambda sont couramment utilisées comme arguments dans des fonctions comme `map()`, `filter()`, et `reduce()`.

#### Conclusion

Les fonctions lambda sont un outil pratique dans le langage Python pour définir rapidement des fonctions simples et concises. Elles sont particulièrement utiles dans les cas où une fonction est nécessaire pour une tâche rapide, comme dans les appels aux fonctions de traitement fonctionnel (`map()`, `filter()`, etc.). Cependant, elles sont limitées à des expressions simples et ne conviennent pas aux opérations plus complexes.

### Chap 3 **Fonctions Génératrices en Python**

Les **fonctions génératrices** sont des fonctions spéciales en Python qui permettent de produire des éléments de manière **paresseuse** (lazy evaluation), un élément à la fois, au lieu de retourner une liste entière. Elles utilisent le mot-clé `yield` pour produire des valeurs, ce qui permet de gérer efficacement la mémoire, surtout lorsqu'on travaille avec de grands ensembles de données.

#### 1. **Syntaxe de base d'une fonction génératrice**

Une fonction génératrice ressemble à une fonction classique, mais au lieu de retourner une valeur avec `return`, elle utilise `yield` pour produire des valeurs à chaque itération. Chaque appel à `yield` suspend l'exécution de la fonction et conserve son état, de sorte que l'exécution peut être reprise là où elle s'est arrêtée.

**Exemple simple :**

```python
# Fonction génératrice qui produit les carrés des nombres de 1 à n
def generate_squares(n):
    for i in range(1, n + 1):
        yield i * i

# Création d'un générateur
squares = generate_squares(5)

# Consommation des éléments du générateur
for square in squares:
    print(square)  # Sortie : 1, 4, 9, 16, 25
```

Dans cet exemple, la fonction `generate_squares` produit les carrés des nombres de 1 à `n` un à un. À chaque itération, l'appel à `yield` suspend la fonction et retourne un carré. Lorsque la fonction est reprise, elle continue à partir de l'endroit où elle s'était arrêtée.

#### 2. **Le comportement paresseux des générateurs**

Les générateurs sont souvent utilisés dans les cas où les données sont trop volumineuses pour tenir en mémoire. Au lieu de générer toute la liste d’un coup, un générateur renvoie un élément à la fois et calcule chaque élément à la demande (lorsque l'on le demande explicitement via une itération).

**Exemple de générateur pour de grandes données :**

```python
# Fonction génératrice qui génère une séquence infinie de nombres
def infinite_numbers():
    num = 0
    while True:
        yield num
        num += 1

# Consommer seulement les 5 premiers nombres
counter = infinite_numbers()
for _ in range(5):
    print(next(counter))  # Sortie : 0, 1, 2, 3, 4
```

Ici, le générateur `infinite_numbers` produit une séquence infinie de nombres, mais la fonction s'arrête d'évaluer un nombre à la fois à chaque appel de `next()`. Cela évite d’allouer de la mémoire pour des millions de nombres à la fois.

#### 3. **Avantages des générateurs**

Les générateurs présentent plusieurs avantages par rapport aux autres structures de données comme les listes ou les tuples :

- **Utilisation de la mémoire optimisée** : Contrairement aux listes qui stockent tous les éléments en mémoire, les générateurs ne stockent qu'un élément à la fois, ce qui permet de gérer efficacement de très grands ensembles de données.
- **Performance améliorée** : Comme les générateurs produisent les valeurs à la demande, ils sont souvent plus rapides que la construction d'une liste complète, surtout pour de grandes séquences ou des données infinies.
- **Réduction de la complexité** : Lorsqu'une fonction génère une séquence d'éléments, l'utilisation de générateurs permet de simplifier le code et de le rendre plus lisible.

**Exemple :**

```python
# Générateur pour extraire les premiers éléments pairs d'une grande séquence
def get_even_numbers(limit):
    for num in range(limit):
        if num % 2 == 0:
            yield num

evens = get_even_numbers(10)
for even in evens:
    print(even)  # Sortie : 0, 2, 4, 6, 8
```

#### 4. **Comparaison avec les fonctions classiques**

Les fonctions classiques retournent toutes les valeurs en une seule fois (par exemple, dans une liste ou un autre conteneur), ce qui peut être inefficace si l'ensemble des données est volumineux.

**Fonction classique qui retourne une liste complète :**

```python
# Fonction classique qui retourne une liste complète
def generate_squares_list(n):
    return [i * i for i in range(1, n + 1)]

squares_list = generate_squares_list(5)
print(squares_list)  # Sortie : [1, 4, 9, 16, 25]
```

**Fonction génératrice pour une approche paresseuse :**

```python
# Fonction génératrice qui produit les carrés un par un
def generate_squares(n):
    for i in range(1, n + 1):
        yield i * i

# Consommation des éléments du générateur
squares = generate_squares(5)
for square in squares:
    print(square)  # Sortie : 1, 4, 9, 16, 25
```

La fonction génératrice `generate_squares` produit les résultats de manière paresseuse, un élément à la fois, ce qui est plus efficace en termes de mémoire, surtout si la fonction doit gérer de grands ensembles de données.

#### 5. **Utilisation des générateurs avec `next()` et `StopIteration`**

La fonction `next()` est utilisée pour obtenir le prochain élément d'un générateur. Lorsque tous les éléments ont été produits, un générateur lève l'exception `StopIteration`.

**Exemple d'utilisation de `next()` :**

```python
# Générateur de nombres
def generate_numbers():
    yield 1
    yield 2
    yield 3

gen = generate_numbers()
print(next(gen))  # Sortie : 1
print(next(gen))  # Sortie : 2
print(next(gen))  # Sortie : 3
# Appeler next() après que le générateur a épuisé ses éléments
try:
    print(next(gen))  # Lève StopIteration
except StopIteration:
    print("Fin du générateur")
```

Le générateur lève une exception `StopIteration` lorsque tous les éléments ont été produits, indiquant qu'il n'y a plus rien à itérer.

#### 6. **Générateurs et pipeline de données**

Les générateurs sont souvent utilisés pour créer des pipelines de données. Par exemple, on peut chaîner plusieurs générateurs pour effectuer une série de transformations sur les données, chaque étape n'étant calculée que lorsque nécessaire.

**Exemple de pipeline de générateurs :**

```python
# Générateur pour filtrer les nombres pairs
def filter_even(numbers):
    for number in numbers:
        if number % 2 == 0:
            yield number

# Générateur pour doubler chaque nombre
def double(numbers):
    for number in numbers:
        yield number * 2

numbers = range(10)
filtered = filter_even(numbers)
doubled = double(filtered)

for result in doubled:
    print(result)  # Sortie : 0, 4, 8, 12, 16
```

Dans cet exemple, la séquence de nombres est d'abord filtrée pour ne garder que les nombres pairs, puis chaque nombre pair est doublé. Les étapes sont effectuées de manière paresseuse, ce qui rend l'ensemble plus efficace.

#### 7. **Expression génératrice vs compréhension de liste**

Les générateurs peuvent être créés de manière similaire aux compréhensions de liste, mais la différence réside dans le fait qu'une **compréhension de liste** crée immédiatement toute la liste en mémoire, tandis qu'un **générateur** évalue les éléments un par un et n'occupe pas de mémoire pour stocker la liste complète.

**Exemple de compréhension de liste :**

```python
# Liste complète des carrés
squares_list = [x * x for x in range(5)]
print(squares_list)  # Sortie : [0, 1, 4, 9, 16]
```

**Exemple d'expression génératrice :**

```python
# Générateur des carrés (paresseux)
squares_gen = (x * x for x in range(5))
for square in squares_gen:
    print(square)  # Sortie : 0, 1, 4, 9, 16
```

L'expression génératrice est plus économe en mémoire, car elle produit les éléments un par un.

#### 8. **Résumé des avantages des générateurs**

- **Mémoire optimisée** : Les générateurs ne chargent pas toute la séquence en mémoire, ce qui est idéal pour les ensembles de données volumineux.
- **Performances améliorées** : Étant donné qu'un générateur produit les valeurs à la demande, il peut être plus rapide que de créer des structures de données complètes.
- **Simplicité** : Les générateurs peuvent simplifier le code, notamment lorsqu'on manipule des flux de données ou des séquences infinies.
- **Flexibilité** : Ils sont souvent utilisés dans des contextes où les données doivent être traitées au fur et à mesure, comme dans des pipelines ou des flux de données continus.

#### Conclusion

Les **fonctions génératrices** offrent une approche efficace pour traiter de grandes quantités de données de manière paresseuse. Elles sont largement utilisées dans les situations où les données doivent être produites au fur et à mesure et sont particulièrement adaptées pour économiser de la mémoire et améliorer la performance des

 applications traitant de grandes séquences ou des flux de données continus.

### Chap 4 **Décorateurs en Python**

Les **décorateurs** sont un mécanisme puissant en Python permettant de modifier ou d’étendre le comportement de fonctions ou de méthodes, sans avoir besoin de modifier leur code interne. Ils permettent d'ajouter des fonctionnalités supplémentaires de manière élégante, notamment pour la gestion des comportements transversaux, comme la gestion des logs, la validation des entrées, ou encore l'optimisation des performances.

#### 1. **Définition d'un décorateur**

Un décorateur est essentiellement une fonction qui prend une autre fonction en argument et qui retourne une nouvelle fonction modifiée. Un décorateur est appliqué à une fonction en utilisant la syntaxe du symbole `@` suivi du nom du décorateur, placé juste avant la définition de la fonction cible.

La structure de base d’un décorateur ressemble à ceci :

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        # Code exécuté avant l'appel de la fonction
        result = func(*args, **kwargs)  # Appel de la fonction d'origine
        # Code exécuté après l'appel de la fonction
        return result
    return wrapper
```

Ici, `func` est la fonction cible qui sera modifiée, et `wrapper` est la nouvelle fonction qui encapsule `func`.

#### 2. **Exemple d’un décorateur simple**

Prenons un décorateur simple qui mesure le temps d’exécution d’une fonction :

```python
import time

def timing_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()  # Démarre le chronomètre
        result = func(*args, **kwargs)  # Exécute la fonction cible
        end_time = time.time()  # Arrête le chronomètre
        print(f"{func.__name__} took {end_time - start_time} seconds to execute.")
        return result
    return wrapper

@timing_decorator
def slow_function():
    time.sleep(2)  # Simule une fonction lente

slow_function()  # Sortie : slow_function took 2.0xxxxxx seconds to execute.
```

Ici, le décorateur `timing_decorator` mesure le temps d’exécution de la fonction `slow_function`. Lorsqu'on applique le décorateur avec le symbole `@`, la fonction originale est « enveloppée » dans la fonction `wrapper`, et le comportement de la fonction cible est modifié en y ajoutant un chronomètre.

#### 3. **Pourquoi utiliser des décorateurs ?**

Les décorateurs permettent d'ajouter des comportements supplémentaires aux fonctions ou méthodes sans toucher à leur code original. Cela est particulièrement utile pour :

- **La gestion des comportements transversaux** : Par exemple, la gestion des exceptions, la journalisation (logging), la validation des entrées, ou l'optimisation des performances.
- **L’optimisation du code** : Les décorateurs permettent d'éviter la duplication de code, car un même décorateur peut être appliqué à plusieurs fonctions.
- **La séparation des préoccupations** : Ils permettent de séparer la logique principale de l’application des aspects transversaux comme les logs ou la gestion des erreurs.

#### 4. **Exemple d’un décorateur pour la validation des entrées**

Un autre cas d’utilisation des décorateurs est la validation des arguments d'une fonction. Par exemple, on peut créer un décorateur qui vérifie que l'argument d'une fonction est un nombre positif avant de l'exécuter.

```python
def positive_input_decorator(func):
    def wrapper(x):
        if x < 0:
            raise ValueError("L'entrée doit être un nombre positif.")
        return func(x)
    return wrapper

@positive_input_decorator
def square_root(x):
    return x ** 0.5

print(square_root(16))  # Sortie : 4.0
print(square_root(-16))  # Lève ValueError: L'entrée doit être un nombre positif.
```

Ici, le décorateur `positive_input_decorator` vérifie si l'argument passé à la fonction `square_root` est positif avant de permettre son exécution. Si l'argument est négatif, il lève une exception `ValueError`.

#### 5. **Décorateurs avec plusieurs arguments**

Les décorateurs peuvent être plus complexes, surtout lorsqu'ils doivent prendre plusieurs arguments. Il est possible de créer des décorateurs avec des arguments supplémentaires, ce qui les rend encore plus puissants.

**Exemple de décorateur avec un argument supplémentaire :**

```python
def repeat_decorator(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(n):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat_decorator(3)
def greet(name):
    print(f"Bonjour, {name}!")

greet("Alice")  # Sortie : Bonjour, Alice! (affiché 3 fois)
```

Ici, le décorateur `repeat_decorator` prend un argument `n` qui spécifie le nombre de fois que la fonction cible doit être appelée. Le décorateur `@repeat_decorator(3)` appelle la fonction `greet` trois fois, ce qui permet de répéter une action.

#### 6. **Chainer plusieurs décorateurs**

Il est possible d’appliquer plusieurs décorateurs à une même fonction. Lorsqu'on applique plusieurs décorateurs, Python les applique dans l’ordre inverse, c’est-à-dire de bas en haut dans le code.

**Exemple de plusieurs décorateurs :**

```python
def decorator_one(func):
    def wrapper(*args, **kwargs):
        print("Décorateur 1")
        return func(*args, **kwargs)
    return wrapper

def decorator_two(func):
    def wrapper(*args, **kwargs):
        print("Décorateur 2")
        return func(*args, **kwargs)
    return wrapper

@decorator_one
@decorator_two
def hello():
    print("Bonjour")

hello()
```

**Sortie :**
```
Décorateur 1
Décorateur 2
Bonjour
```

Ici, `hello` est décorée d'abord par `decorator_two`, puis par `decorator_one`. Python applique les décorateurs dans l'ordre inverse de leur déclaration.

#### 7. **Les décorateurs de méthodes de classe**

Les décorateurs peuvent également être appliqués aux méthodes de classe ou aux méthodes statiques. Un décorateur courant dans ce cas est `@classmethod` et `@staticmethod`.

**Exemple d'un décorateur `classmethod` :**

```python
class MyClass:
    @classmethod
    def greet(cls):
        print(f"Bonjour depuis la classe {cls.__name__}!")

MyClass.greet()  # Sortie : Bonjour depuis la classe MyClass!
```

Le décorateur `@classmethod` transforme une méthode en méthode de classe, ce qui permet de l'appeler directement sur la classe et non sur une instance.

**Exemple d'un décorateur `staticmethod` :**

```python
class MyClass:
    @staticmethod
    def greet():
        print("Bonjour depuis une méthode statique!")

MyClass.greet()  # Sortie : Bonjour depuis une méthode statique!
```

Le décorateur `@staticmethod` transforme une méthode en méthode statique, ce qui permet de l'appeler directement sur la classe sans nécessiter d'instance.

#### 8. **Résumé des avantages des décorateurs**

Les décorateurs sont un moyen puissant d’étendre ou de modifier le comportement de fonctions et de méthodes sans toucher directement à leur code. Voici les principaux avantages des décorateurs :

- **Réutilisation du code** : Un décorateur peut être appliqué à plusieurs fonctions, ce qui évite la duplication de code.
- **Séparation des préoccupations** : Ils permettent de séparer la logique principale d’une fonction de comportements transversaux comme la journalisation, la gestion des erreurs, ou la validation des entrées.
- **Lisibilité** : Les décorateurs rendent le code plus lisible en regroupant des fonctionnalités supplémentaires dans des fonctions externes et réutilisables.

#### Conclusion

Les **décorateurs** en Python sont un outil puissant permettant de modifier ou d'étendre le comportement d'autres fonctions ou méthodes sans modifier leur code interne. Ils sont très utilisés pour ajouter des comportements transversaux comme la gestion des erreurs, la validation des données, ou l'optimisation des performances. Ils permettent de rendre le code plus modulaire, réutilisable et lisible.

### Chap 5 **Gestion des exceptions en Python (Try/Except/Finally)**

La **gestion des exceptions** en Python permet de capturer et de traiter les erreurs qui peuvent survenir pendant l'exécution d'un programme. Au lieu de laisser l'erreur interrompre l'exécution du programme, on peut l'intercepter, la traiter de manière appropriée, et ainsi rendre le programme plus robuste et moins susceptible de planter en cas de problème. Python fournit plusieurs mécanismes pour gérer ces erreurs, principalement à travers les blocs `try`, `except` et `finally`.

#### 1. **Le bloc `try`**

Le bloc `try` est utilisé pour encapsuler un code qui peut potentiellement générer une exception. Lorsque Python exécute un programme et rencontre une instruction dans le bloc `try` qui déclenche une exception, l'exécution du code dans ce bloc s'arrête immédiatement et l'exception est envoyée au bloc `except` associé, si présent.

#### 2. **Le bloc `except`**

Le bloc `except` est utilisé pour intercepter l'exception levée dans le bloc `try` et exécuter du code pour la gérer. Il peut capturer des exceptions spécifiques ou toutes les exceptions possibles. Si une exception correspond à un type spécifié, le code à l’intérieur du bloc `except` sera exécuté. Si aucune exception n’est levée, ce bloc est ignoré.

#### 3. **Le bloc `finally`**

Le bloc `finally` contient du code qui sera exécuté **dans tous les cas**, que l'exception ait été levée ou non. Cela permet d'assurer l'exécution de certaines actions de nettoyage, comme la fermeture de fichiers ou la libération de ressources, indépendamment du fait qu'une exception soit survenue ou non. Le bloc `finally` est optionnel.

#### 4. **Syntaxe de base :**

```python
try:
    # Code susceptible de générer une exception
except SomeException as e:
    # Code pour gérer l'exception
finally:
    # Code à exécuter dans tous les cas
```

#### 5. **Exemple avec gestion d’une exception spécifique**

Prenons un exemple où l’on tente de diviser un nombre par un autre. Si le diviseur est égal à zéro, une exception `ZeroDivisionError` sera levée. Nous allons la capturer et afficher un message d'erreur.

```python
try:
    x = 10 / 0
except ZeroDivisionError as e:
    print(f"Erreur : {e}")
finally:
    print("Bloc finally exécuté.")
```

**Sortie :**

```
Erreur : division by zero
Bloc finally exécuté.
```

Dans cet exemple, la division par zéro génère une exception `ZeroDivisionError`. Cette exception est capturée par le bloc `except`, et le message d'erreur est affiché. Le bloc `finally` est toujours exécuté, quelle que soit l'issue du bloc `try`.

#### 6. **Gestion de plusieurs exceptions**

Il est possible de gérer différentes exceptions de manière séparée en utilisant plusieurs blocs `except`. Python teste les exceptions dans l’ordre dans lequel elles sont définies. Dès qu'une exception correspond, le bloc `except` approprié est exécuté.

```python
try:
    x = int(input("Entrez un nombre : "))
    result = 10 / x
except ZeroDivisionError as e:
    print("Erreur : Division par zéro.")
except ValueError as e:
    print("Erreur : Entrée invalide. Veuillez entrer un nombre.")
finally:
    print("Bloc finally exécuté.")
```

**Exemples de sortie :**

- Si l'utilisateur entre un zéro, la sortie sera :
  ```
  Erreur : Division par zéro.
  Bloc finally exécuté.
  ```
- Si l'utilisateur entre une valeur non numérique, la sortie sera :
  ```
  Erreur : Entrée invalide. Veuillez entrer un nombre.
  Bloc finally exécuté.
  ```

#### 7. **Capturer toutes les exceptions avec `except` générique**

Il est également possible d'attraper toutes les exceptions sans spécifier un type particulier. Cela peut être utile si vous voulez capturer toutes les erreurs possibles, mais cela doit être utilisé avec prudence, car il pourrait masquer des erreurs imprévues.

```python
try:
    x = 10 / 0
except Exception as e:
    print(f"Une erreur s'est produite : {e}")
finally:
    print("Bloc finally exécuté.")
```

**Sortie :**

```
Une erreur s'est produite : division by zero
Bloc finally exécuté.
```

Dans ce cas, l'exception `ZeroDivisionError` est capturée par le bloc `except` qui utilise `Exception`, la classe de base de toutes les exceptions en Python.

#### 8. **Ressources à libérer avec `finally`**

Le bloc `finally` est particulièrement utile pour garantir que des actions de nettoyage sont effectuées, indépendamment du fait qu’une exception ait eu lieu ou non. Par exemple, on peut l'utiliser pour fermer un fichier ou une connexion à une base de données.

**Exemple avec la gestion d’un fichier :**

```python
try:
    file = open("example.txt", "r")
    data = file.read()
    # Simuler une exception
    x = 10 / 0
except ZeroDivisionError:
    print("Erreur de division.")
finally:
    file.close()  # Le fichier est toujours fermé, qu'une exception ait été levée ou non
    print("Le fichier a été fermé.")
```

**Sortie :**

```
Erreur de division.
Le fichier a été fermé.
```

Ici, même si une exception est levée pendant l'exécution du bloc `try`, le fichier est toujours fermé grâce au bloc `finally`.

#### 9. **Lever des exceptions avec `raise`**

Il est également possible de lever des exceptions de manière explicite dans le code, en utilisant l'instruction `raise`. Cela peut être utile pour forcer une erreur si une condition particulière est rencontrée dans le programme.

```python
def validate_age(age):
    if age < 18:
        raise ValueError("L'âge doit être supérieur ou égal à 18.")
    print("Âge valide.")

try:
    validate_age(16)
except ValueError as e:
    print(f"Erreur : {e}")
finally:
    print("Vérification terminée.")
```

**Sortie :**

```
Erreur : L'âge doit être supérieur ou égal à 18.
Vérification terminée.
```

Ici, une exception `ValueError` est levée explicitement dans la fonction `validate_age` lorsque l'âge est inférieur à 18, et elle est capturée et gérée par le bloc `except`.

#### 10. **Exception personnalisée**

Il est également possible de définir des exceptions personnalisées en créant une nouvelle classe d'exception. Cela permet de mieux contrôler les erreurs spécifiques à une application ou à un contexte particulier.

```python
class CustomError(Exception):
    pass

try:
    raise CustomError("C'est une erreur personnalisée.")
except CustomError as e:
    print(f"Erreur capturée : {e}")
```

**Sortie :**

```
Erreur capturée : C'est une erreur personnalisée.
```

#### 11. **Résumé des concepts clés**

- **Bloc `try`** : Contient le code qui peut générer une exception.
- **Bloc `except`** : Capture les exceptions générées dans le bloc `try` et exécute le code de gestion d’erreur.
- **Bloc `finally`** : Code qui sera exécuté dans tous les cas, qu’une exception soit levée ou non.
- **`raise`** : Permet de lever une exception explicitement dans le programme.
- **Exception personnalisée** : Création de nouvelles exceptions spécifiques à votre application.

#### Conclusion

La **gestion des exceptions** avec `try`, `except`, et `finally` est essentielle pour rendre un programme Python plus robuste et tolérant aux erreurs. En capturant et en gérant les erreurs de manière appropriée, on peut éviter que le programme ne plante brutalement et assurer un nettoyage ou une fermeture appropriée des ressources. Les décorateurs, les exceptions personnalisées, et l’utilisation des blocs `finally` permettent de rendre la gestion des erreurs encore plus flexible et puissante.

### Chap 6 **Modules et Paquets en Python**

En Python, l’organisation et la structuration du code sont facilitées par l’utilisation des **modules** et des **paquets**. Ces concepts permettent de mieux gérer les projets en séparant le code en fichiers plus petits et réutilisables, ce qui améliore la lisibilité, la maintenance et la modularité du code.

#### 1. **Module**
Un **module** en Python est un fichier contenant du code Python. Il peut contenir des fonctions, des classes et des variables, et il permet de structurer le code en petites unités logiques et réutilisables. Un fichier Python avec une extension `.py` est automatiquement considéré comme un module. Le nom du fichier devient le nom du module.

##### Utilisation d'un module :
- **Création d'un module** : On peut créer un module en enregistrant du code Python dans un fichier avec l'extension `.py`. Par exemple, un fichier nommé `calcul.py` contenant des fonctions mathématiques simples est un module.

```python
# calcul.py
def addition(a, b):
    return a + b

def multiplication(a, b):
    return a * b
```

- **Utilisation d’un module** : Un autre fichier Python peut importer et utiliser ce module pour accéder à ses fonctions.

```python
# programme.py
import calcul

resultat_addition = calcul.addition(5, 3)
resultat_multiplication = calcul.multiplication(4, 6)

print(resultat_addition)  # Affiche 8
print(resultat_multiplication)  # Affiche 24
```

- **Importation sélective** : Vous pouvez également importer des fonctions spécifiques d'un module en utilisant la syntaxe `from ... import ...`.

```python
from calcul import addition

resultat = addition(10, 5)
print(resultat)  # Affiche 15
```

- **Renommer un module ou une fonction** : Il est possible de renommer les modules ou fonctions lors de leur importation en utilisant le mot-clé `as`.

```python
import calcul as c

resultat = c.addition(1, 2)
print(resultat)  # Affiche 3
```

#### 2. **Paquet (Package)**
Un **paquet** en Python est un répertoire contenant plusieurs modules. Il permet de regrouper des modules liés entre eux sous un même répertoire afin de mieux organiser le projet. Un paquet doit contenir un fichier spécial nommé `__init__.py` pour indiquer à Python que ce répertoire doit être traité comme un paquet. Le fichier `__init__.py` peut être vide ou contenir du code d'initialisation pour le paquet.

##### Structure d’un paquet :
La structure d’un paquet peut ressembler à ceci :

```
mon_paquet/
│
├── __init__.py
├── module1.py
├── module2.py
└── sous_paquet/
    ├── __init__.py
    ├── module3.py
    └── module4.py
```

- **Accéder aux modules d’un paquet** : Vous pouvez importer des modules d’un paquet de la même manière que pour un module classique, en utilisant la syntaxe `import`. Si le paquet contient un sous-paquet, vous pouvez y accéder en spécifiant le chemin du sous-paquet.

```python
# programme.py
import mon_paquet.module1

mon_paquet.module1.fonction1()

from mon_paquet.sous_paquet import module3
module3.fonction3()
```

#### 3. **Les fonctions spéciales d’un paquet**

- **`__init__.py`** : Ce fichier est essentiel pour que Python reconnaisse un répertoire comme un paquet. Dans ce fichier, vous pouvez définir des initialisations ou des importations globales pour votre paquet.

```python
# mon_paquet/__init__.py
from .module1 import fonction1
from .module2 import fonction2
```

Cela permet de simplifier l’importation des modules de votre paquet en regroupant certains éléments sous un même nom.

```python
# programme.py
from mon_paquet import fonction1

fonction1()
```

Ici, au lieu de devoir importer directement `mon_paquet.module1.fonction1`, vous pouvez importer directement `fonction1` depuis le paquet, grâce à l'importation dans le fichier `__init__.py`.

#### 4. **Importation relative et absolue**

- **Importation absolue** : Lorsqu’un module ou un paquet est importé en spécifiant son chemin complet depuis la racine du projet, on parle d’importation absolue. C’est la méthode la plus courante.

```python
import mon_paquet.module1
```

- **Importation relative** : Python permet d’utiliser des importations relatives, c’est-à-dire d’importer des modules dans un même paquet ou sous-paquet à l’aide de chemins relatifs. Cela peut être utile pour organiser de manière plus flexible les imports à l’intérieur de grands projets.

```python
# Dans mon_paquet/sous_paquet/module4.py
from .module3 import fonction3  # Importation relative
from ..module2 import fonction2  # Importation depuis un niveau supérieur
```

#### 5. **Utilisation de `sys.path` pour ajouter des chemins personnalisés**

La liste `sys.path` contient les répertoires où Python cherche les modules à importer. Vous pouvez ajouter un répertoire à cette liste pour que Python y cherche des modules, ce qui est pratique si vous organisez vos modules en dehors du répertoire du projet.

```python
import sys
sys.path.append('/chemin/vers/mon/paquet')

import mon_paquet
```

#### 6. **Installation de paquets tiers avec `pip`**

En plus de vos propres paquets, Python permet d’installer des paquets externes via le gestionnaire de paquets `pip`. Ces paquets peuvent être installés depuis des archives locales ou des dépôts en ligne comme PyPI (Python Package Index).

- **Installation d'un paquet via `pip`** : 

```bash
pip install numpy
```

Après l'installation, vous pouvez importer et utiliser le module dans votre code Python.

```python
import numpy as np

arr = np.array([1, 2, 3])
```

#### 7. **Avantages des modules et paquets**

- **Modularité** : Les modules et paquets permettent de diviser un projet en plusieurs fichiers, rendant le code plus lisible, maintenable et réutilisable.
- **Réutilisation** : Vous pouvez réutiliser un module ou un paquet dans différents projets, réduisant ainsi la duplication du code.
- **Organisation** : Un projet bien structuré avec des modules et des paquets est plus facile à gérer, surtout lorsqu’il devient plus volumineux.

#### 8. **Résumé des concepts clés**

- **Module** : Un fichier Python `.py` contenant des fonctions, classes ou variables. On l’utilise pour organiser le code.
- **Paquet** : Un répertoire contenant plusieurs modules, et qui nécessite un fichier `__init__.py` pour être reconnu par Python.
- **Importation absolue et relative** : Permet d'importer des modules et paquets en spécifiant leur chemin complet ou relatif.
- **Gestion des dépendances** : Utilisation de `pip` pour installer des paquets externes et les importer dans vos projets.
- **Organisation du projet** : Structurer le projet en modules et paquets pour une gestion optimale.

#### Conclusion

L’utilisation des **modules et paquets** est essentielle pour organiser le code Python de manière efficace et modulaire. Cela permet de rendre les projets plus lisibles, plus maintenables, et facilite leur réutilisation dans d’autres projets. Grâce aux outils comme l’importation, les paquets, et le gestionnaire de dépendances `pip`, Python permet de créer des projets bien structurés et faciles à gérer, même à grande échelle.

### Chap 7 **Manipulation des fichiers (Lecture/Écriture) en Python**

La manipulation des fichiers en Python permet de lire, écrire et gérer les fichiers stockés sur le disque. Python offre des outils puissants et simples pour interagir avec différents types de fichiers (textes, binaires, CSV, JSON, etc.) à l’aide des modes appropriés. Cela inclut la lecture, l’écriture, l’ajout de données, ainsi que la gestion des erreurs liées aux fichiers.

#### 1. **Ouverture de fichiers**

Pour interagir avec un fichier, la première étape consiste à l'ouvrir avec la fonction `open()`. Cette fonction prend en paramètre le chemin du fichier ainsi que le mode dans lequel le fichier doit être ouvert. 

La syntaxe est la suivante :

```python
file = open("chemin/vers/fichier", mode)
```

##### Modes d’ouverture de fichiers :
- **`'r'`** : Lecture (Read). Ouvre le fichier en lecture seule. Le fichier doit exister.
- **`'w'`** : Écriture (Write). Ouvre le fichier en écriture, crée le fichier s'il n'existe pas. Si le fichier existe, son contenu est écrasé.
- **`'a'`** : Ajout (Append). Ouvre le fichier en écriture, ajoute les données à la fin du fichier existant, sans écraser son contenu.
- **`'b'`** : Mode binaire. Utilisé en combinaison avec les autres modes (`'rb'`, `'wb'`, etc.) pour ouvrir un fichier en mode binaire.
- **`'x'`** : Création exclusive (exclusive creation). Ouvre le fichier pour l’écriture, mais échoue si le fichier existe déjà.
- **`'t'`** : Mode texte (Text). C'est le mode par défaut et il peut être combiné avec d’autres modes (par exemple `'rt'` pour lire un fichier texte).
  
#### 2. **Lecture de fichiers**

Une fois un fichier ouvert en mode lecture (`'r'`), vous pouvez en extraire le contenu de plusieurs manières :

- **`read()`** : Lit tout le contenu du fichier en une seule fois.

  ```python
  with open("mon_fichier.txt", "r") as file:
      contenu = file.read()
      print(contenu)
  ```

- **`readline()`** : Lit une ligne à la fois, utile pour lire un fichier ligne par ligne.

  ```python
  with open("mon_fichier.txt", "r") as file:
      ligne = file.readline()
      while ligne:
          print(ligne.strip())  # `.strip()` pour enlever les retours à la ligne
          ligne = file.readline()
  ```

- **`readlines()`** : Lit toutes les lignes et les renvoie sous forme de liste.

  ```python
  with open("mon_fichier.txt", "r") as file:
      lignes = file.readlines()
      for ligne in lignes:
          print(ligne.strip())
  ```

#### 3. **Écriture dans un fichier**

L’écriture dans un fichier se fait en mode `'w'` (écrasement) ou `'a'` (ajout). Il est également possible d’écrire des chaînes de caractères, des nombres ou des objets sous forme de texte.

- **`write()`** : Écrit une chaîne de caractères dans un fichier. Si le fichier est ouvert en mode `'w'`, il écrasera son contenu précédent, sinon il l'ajoutera en mode `'a'`.

  ```python
  with open("mon_fichier.txt", "w") as file:
      file.write("Bonjour, ceci est un test.\n")
  ```

- **`writelines()`** : Écrit plusieurs lignes dans un fichier, attend une séquence (comme une liste) d'éléments. Les éléments de la liste ne sont pas automatiquement séparés par des retours à la ligne.

  ```python
  lignes = ["Première ligne.\n", "Deuxième ligne.\n", "Troisième ligne.\n"]
  with open("mon_fichier.txt", "w") as file:
      file.writelines(lignes)
  ```

#### 4. **Mode binaire**

Les fichiers binaires sont souvent utilisés pour les images, les vidéos, les fichiers audio et d’autres types de données non textuelles. Dans ce cas, vous devez ouvrir le fichier en mode binaire avec `'rb'` ou `'wb'`.

- **Lecture d'un fichier binaire** : Pour lire un fichier binaire, vous devez utiliser la méthode `read()` avec le mode `'rb'`.

  ```python
  with open("image.jpg", "rb") as file:
      contenu_binaire = file.read()
  ```

- **Écriture d'un fichier binaire** : De même, pour écrire des données binaires, vous utilisez le mode `'wb'`.

  ```python
  with open("image_copy.jpg", "wb") as file:
      file.write(contenu_binaire)
  ```

#### 5. **Gestion des erreurs et fermeture des fichiers**

Lorsque vous ouvrez un fichier, il est important de le fermer une fois que vous avez terminé de l'utiliser, afin de libérer les ressources et garantir que toutes les écritures sont correctement effectuées. La méthode `close()` est utilisée pour cela, mais une approche plus courante et plus sûre consiste à utiliser un **contexte de gestionnaire de fichiers**, avec l'instruction `with`. Cela garantit que le fichier est correctement fermé, même en cas d’erreur.

```python
with open("mon_fichier.txt", "r") as file:
    contenu = file.read()
# Pas besoin de file.close(), car 'with' se charge de fermer le fichier
```

#### 6. **Gestion des exceptions liées aux fichiers**

Lors de la manipulation de fichiers, des erreurs peuvent survenir, par exemple si le fichier n’existe pas ou si vous n’avez pas les autorisations nécessaires. Vous pouvez gérer ces exceptions avec un bloc `try`-`except`.

```python
try:
    with open("mon_fichier.txt", "r") as file:
        contenu = file.read()
except FileNotFoundError:
    print("Le fichier n'existe pas.")
except PermissionError:
    print("Vous n'avez pas la permission d'accéder à ce fichier.")
except Exception as e:
    print(f"Une erreur est survenue : {e}")
```

#### 7. **Travail avec des fichiers CSV**

Python offre la bibliothèque **`csv`** pour travailler avec des fichiers CSV, qui sont couramment utilisés pour stocker des données tabulaires. La lecture et l'écriture dans des fichiers CSV sont simples à effectuer avec les fonctions `csv.reader` et `csv.writer`.

- **Lire un fichier CSV** :

  ```python
  import csv
  with open('mon_fichier.csv', 'r') as file:
      lecteur = csv.reader(file)
      for ligne in lecteur:
          print(ligne)
  ```

- **Écrire dans un fichier CSV** :

  ```python
  import csv
  with open('mon_fichier.csv', 'w', newline='') as file:
      ecrivain = csv.writer(file)
      ecrivain.writerow(['Nom', 'Prénom', 'Âge'])
      ecrivain.writerow(['Dupont', 'Jean', 28])
  ```

#### 8. **Travail avec des fichiers JSON**

Le module **`json`** permet de lire et écrire des fichiers JSON, qui sont utilisés pour échanger des données dans des applications web, par exemple.

- **Lire un fichier JSON** :

  ```python
  import json
  with open('mon_fichier.json', 'r') as file:
      data = json.load(file)
      print(data)
  ```

- **Écrire dans un fichier JSON** :

  ```python
  import json
  data = {"nom": "Jean", "prénom": "Dupont", "âge": 28}
  with open('mon_fichier.json', 'w') as file:
      json.dump(data, file)
  ```

#### 9. **Résumé des concepts clés**

- **Ouverture de fichiers** : Utiliser `open()` avec différents modes (`'r'`, `'w'`, `'a'`, etc.) pour ouvrir un fichier selon l’opération souhaitée.
- **Lecture de fichiers** : Utiliser `read()`, `readline()`, ou `readlines()` pour lire le contenu du fichier.
- **Écriture dans un fichier** : Utiliser `write()` ou `writelines()` pour écrire des données dans un fichier.
- **Gestion des fichiers binaires** : Ouvrir les fichiers en mode binaire avec `'rb'` ou `'wb'` pour traiter des données non textuelles.
- **Gestion des erreurs** : Utiliser `try`-`except` pour capturer les erreurs liées aux fichiers et garantir une gestion appropriée des erreurs.
- **Gestion des ressources** : Utiliser `with` pour ouvrir et fermer automatiquement un fichier en garantissant sa fermeture correcte.
- **Fichiers CSV et JSON** : Utiliser les modules `csv` et `json` pour manipuler des fichiers dans ces formats spécifiques.

#### Conclusion

La manipulation des fichiers en Python est un aspect essentiel pour gérer des données persistantes, qu'il s'agisse de fichiers texte, binaires, CSV, ou JSON. Python offre des outils puissants et simples pour effectuer toutes les opérations nécessaires, tout en garantissant une gestion efficace des erreurs et des ressources.

### Chap 8 **Listes, tuples et dictionnaires avancés**

Les **listes**, **tuples**, et **dictionnaires** sont des structures de données de collection fondamentales en Python. Elles permettent de stocker, d'organiser et de manipuler des ensembles de données. Cette section explore des techniques avancées pour la gestion de ces structures, y compris l'itération, la modification, ainsi que l'application de fonctions spécifiques pour transformer et manipuler ces collections.

#### 1. **Listes avancées**

Les listes sont des structures de données qui peuvent contenir plusieurs éléments, modifiables et ordonnés. Python offre plusieurs méthodes et fonctionnalités pour travailler efficacement avec les listes.

##### a. **Itération avancée sur les listes**

- **Itération avec `enumerate()`** : Pour obtenir à la fois l'index et la valeur lors de l'itération.
  ```python
  ma_liste = ["a", "b", "c", "d"]
  for index, valeur in enumerate(ma_liste):
      print(f"Index {index}: {valeur}")
  ```
- **Listes imbriquées** : Utilisation de boucles imbriquées pour manipuler des listes contenant d'autres listes.
  ```python
  liste_imbricatee = [[1, 2], [3, 4], [5, 6]]
  for sous_liste in liste_imbricatee:
      for element in sous_liste:
          print(element)
  ```

##### b. **Modification et manipulation avancée des listes**

- **Ajout d'éléments avec `insert()` et `extend()`** :

  - `insert(index, valeur)` permet d'ajouter un élément à un index spécifique.
  - `extend(iterable)` permet d'ajouter tous les éléments d'un itérable (liste, ensemble, etc.) à la fin de la liste.
  ```python
  ma_liste = [1, 2, 3]
  ma_liste.insert(1, 'a')  # Insertion à l'index 1
  ma_liste.extend([4, 5])  # Ajout de plusieurs éléments
  ```

- **Suppression d'éléments avec `pop()` et `remove()`** :

  - `pop(index)` retire et renvoie l'élément à l'index spécifié.
  - `remove(valeur)` supprime la première occurrence de la valeur dans la liste.
  ```python
  ma_liste = [1, 2, 3, 4, 5]
  ma_liste.pop(2)  # Supprime l'élément à l'index 2 (3)
  ma_liste.remove(4)  # Supprime la première occurrence de 4
  ```

##### c. **Compréhension de liste avancée**

- Vous pouvez utiliser des expressions conditionnelles complexes dans une compréhension de liste.

  ```python
  # Créer une liste de carrés des nombres pairs
  chiffres = [1, 2, 3, 4, 5, 6]
  carrés_pairs = [x**2 for x in chiffres if x % 2 == 0]
  print(carrés_pairs)  # [4, 16, 36]
  ```

#### 2. **Tuples avancés**

Les tuples sont des collections ordonnées et immuables. Une fois créés, leurs éléments ne peuvent pas être modifiés. Cependant, ils sont utilisés pour des situations où l’immuabilité est importante et offrent une performance légèrement meilleure que les listes.

##### a. **Itération sur les tuples**

L'itération sur les tuples est similaire à celle des listes, mais comme les tuples sont immuables, vous devez comprendre que vous ne pouvez pas les modifier pendant l'itération.

```python
mon_tuple = (1, 2, 3, 4)
for element in mon_tuple:
    print(element)
```

##### b. **Manipulation avancée des tuples**

- **Concaténation et multiplication de tuples** : Vous pouvez concaténer plusieurs tuples ou les multiplier.

  ```python
  tuple1 = (1, 2, 3)
  tuple2 = (4, 5)
  tuple_concaténé = tuple1 + tuple2  # (1, 2, 3, 4, 5)
  tuple_multiplié = tuple1 * 2  # (1, 2, 3, 1, 2, 3)
  ```

##### c. **Accès aux éléments du tuple**

Comme pour les listes, l'accès aux éléments d'un tuple se fait par index. Vous pouvez également utiliser des tranches pour obtenir des sous-parties du tuple.

```python
mon_tuple = (10, 20, 30, 40)
print(mon_tuple[1])  # 20
print(mon_tuple[1:3])  # (20, 30)
```

#### 3. **Dictionnaires avancés**

Les dictionnaires sont des collections non ordonnées de paires clé-valeur. Les clés sont uniques, et chaque clé est associée à une valeur. Les dictionnaires permettent un accès rapide aux éléments en fonction des clés.

##### a. **Itération sur les dictionnaires**

- **Itération sur les clés, valeurs et paires clé-valeur** :

  - `dict.keys()` renvoie un itérable sur les clés.
  - `dict.values()` renvoie un itérable sur les valeurs.
  - `dict.items()` renvoie un itérable sur les paires clé-valeur.
  ```python
  mon_dict = {"a": 1, "b": 2, "c": 3}
  for clé, valeur in mon_dict.items():
      print(f"{clé}: {valeur}")
  ```

##### b. **Manipulation avancée des dictionnaires**

- **Ajout et modification des éléments d’un dictionnaire** : Vous pouvez ajouter de nouvelles paires ou modifier les valeurs existantes en utilisant les clés.

  ```python
  mon_dict = {"a": 1, "b": 2}
  mon_dict["c"] = 3  # Ajout d'une nouvelle paire
  mon_dict["a"] = 10  # Modification de la valeur associée à la clé "a"
  ```

- **Suppression d’éléments** : Vous pouvez utiliser `del` pour supprimer une paire clé-valeur ou la méthode `pop()`.

  ```python
  mon_dict = {"a": 1, "b": 2, "c": 3}
  del mon_dict["b"]  # Suppression de la paire avec la clé "b"
  valeur = mon_dict.pop("a")  # Suppression et récupération de la valeur associée à "a"
  ```

##### c. **Compréhension de dictionnaire**

Tout comme les listes, vous pouvez utiliser des expressions conditionnelles dans une compréhension de dictionnaire pour créer de nouveaux dictionnaires à partir d'itérables.

```python
# Créer un dictionnaire avec les carrés des nombres
nombres = [1, 2, 3, 4, 5]
dictionnaire_carré = {x: x**2 for x in nombres}
print(dictionnaire_carré)  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
```

##### d. **Dictionnaires imbriqués**

Les dictionnaires peuvent également contenir d’autres dictionnaires comme valeurs, permettant ainsi une structure de données plus complexe.

```python
dico_embarque = {"A": {"nom": "Alice", "âge": 30}, "B": {"nom": "Bob", "âge": 25}}
print(dico_embarque["A"]["nom"])  # "Alice"
```

#### 4. **Opérations avancées sur les collections**

##### a. **Fusionner des dictionnaires**

Depuis Python 3.5+, vous pouvez utiliser l’opérateur `**` pour fusionner plusieurs dictionnaires.
```python
d1 = {"a": 1, "b": 2}
d2 = {"c": 3, "d": 4}
fusion = {**d1, **d2}
print(fusion)  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}
```

##### b. **Tri des collections**

Les listes, tuples et dictionnaires peuvent être triés en utilisant des fonctions comme `sorted()`, mais les dictionnaires ne sont pas ordonnés jusqu’à Python 3.7+.

- Tri d’une liste :
  ```python
  ma_liste = [5, 2, 9, 1]
  sorted_liste = sorted(ma_liste)  # [1, 2, 5, 9]
  ```

- Tri des dictionnaires par clé ou valeur :

  ```python
  mon_dict = {"b": 3, "a": 2, "c": 1}
  trié_par_clé = dict(sorted(mon_dict.items()))  # Trie par clés
  trié_par_valeur = dict(sorted(mon_dict.items(), key=lambda item: item[1]))  # Trie par valeur
  ```

#### 5. **Résumé des concepts clés**

- **Listes** : Collections ordonnées et modifiables, permettant l'itération, l'ajout, la suppression, la modification, et l'application de transformations via la compréhension de liste.
- **Tuples** : Collections ordonnées et immuables, utiles pour des situations nécessitant une performance optimale et

 l'immuabilité.
- **Dictionnaires** : Collections de paires clé-valeur, efficaces pour un accès rapide aux éléments via des clés. La manipulation avancée inclut l’itération, la modification, et la fusion de dictionnaires.

### Conclusion
Ces concepts permettent une gestion avancée et performante des structures de données en Python, et peuvent être combinés pour résoudre des problèmes plus complexes de manière élégante et efficace.

### Chap 9 **Compréhension de dictionnaire**

La **compréhension de dictionnaire** est une technique puissante en Python permettant de créer des dictionnaires de manière concise et efficace. Elle repose sur une syntaxe similaire à celle des **compréhensions de liste**, mais elle inclut des paires clé-valeur. Cette méthode permet d’appliquer des transformations ou des filtres tout en créant des dictionnaires.

#### 1. **Syntaxe de la compréhension de dictionnaire**

La syntaxe de base d’une compréhension de dictionnaire est la suivante :

```python
{clé_expression: valeur_expression for élément in itérable if condition}
```

- **`clé_expression`** : Une expression qui détermine la clé du dictionnaire.
- **`valeur_expression`** : Une expression qui détermine la valeur associée à la clé.
- **`itérable`** : Une séquence ou un objet itérable à partir duquel les éléments seront extraits.
- **`condition` (facultatif)** : Un test conditionnel pour filtrer les éléments à inclure dans le dictionnaire.

#### 2. **Création de dictionnaires simples avec une compréhension**

Une compréhension de dictionnaire peut être utilisée pour créer rapidement un dictionnaire à partir d’une liste, d’un ensemble ou d’un autre dictionnaire.

Exemple 1 : Créer un dictionnaire avec des carrés des nombres dans une liste.

```python
nombres = [1, 2, 3, 4, 5]
dictionnaire_carrés = {x: x**2 for x in nombres}
print(dictionnaire_carrés)  
# Résultat : {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
```

Ici, chaque élément de la liste `nombres` est utilisé comme clé, et la valeur associée est le carré de ce nombre.

#### 3. **Ajout de conditions dans la compréhension de dictionnaire**

Vous pouvez également ajouter une **condition** pour filtrer les éléments à inclure dans le dictionnaire. Par exemple, créer un dictionnaire des carrés des nombres pairs uniquement.

```python
nombres = [1, 2, 3, 4, 5]
dictionnaire_carrés_pairs = {x: x**2 for x in nombres if x % 2 == 0}
print(dictionnaire_carrés_pairs)
# Résultat : {2: 4, 4: 16}
```

Dans cet exemple, seule la valeur `x` qui est paire est incluse dans le dictionnaire, et chaque clé correspond à un nombre pair avec sa valeur étant son carré.

#### 4. **Manipulation de dictionnaires avec une compréhension**

Une compréhension de dictionnaire peut aussi être utilisée pour transformer des dictionnaires existants en appliquant des modifications à leurs clés ou valeurs.

Exemple 2 : Modifier les valeurs d’un dictionnaire existant en les multipliant par 2.

```python
dico_original = {'a': 1, 'b': 2, 'c': 3}
dico_modifié = {k: v*2 for k, v in dico_original.items()}
print(dico_modifié)
# Résultat : {'a': 2, 'b': 4, 'c': 6}
```

Ici, le dictionnaire `dico_modifié` est créé en multipliant chaque valeur de `dico_original` par 2.

#### 5. **Utilisation de plusieurs sources dans une compréhension de dictionnaire**

Vous pouvez combiner plusieurs itérables dans une compréhension de dictionnaire pour créer un dictionnaire plus complexe. Par exemple, combiner une liste de clés et une liste de valeurs.

```python
clés = ['a', 'b', 'c']
valeurs = [1, 2, 3]
dico_combiné = {clés[i]: valeurs[i] for i in range(len(clés))}
print(dico_combiné)
# Résultat : {'a': 1, 'b': 2, 'c': 3}
```

Dans cet exemple, les éléments de la liste `clés` sont associés aux éléments correspondants dans la liste `valeurs`.

#### 6. **Création de dictionnaires imbriqués avec une compréhension**

Il est également possible de créer des dictionnaires imbriqués avec des compréhensions de dictionnaires. Par exemple, créer un dictionnaire où chaque valeur est elle-même un dictionnaire.

```python
clés = ['a', 'b', 'c']
valeurs = [1, 2, 3]
dico_imbriqué = {clé: {'valeur': valeur} for clé, valeur in zip(clés, valeurs)}
print(dico_imbriqué)
# Résultat : {'a': {'valeur': 1}, 'b': {'valeur': 2}, 'c': {'valeur': 3}}
```

Dans cet exemple, chaque clé est associée à un dictionnaire contenant une clé `valeur` avec la valeur correspondante.

#### 7. **Utilisation de fonctions dans une compréhension de dictionnaire**

Vous pouvez également appliquer des fonctions aux clés ou valeurs dans la compréhension de dictionnaire. Par exemple, en appliquant une fonction qui modifie la valeur associée à chaque clé.

```python
def majuscule(s):
    return s.upper()

clés = ['a', 'b', 'c']
valeurs = [1, 2, 3]
dico_majuscule = {majuscule(clé): valeur for clé, valeur in zip(clés, valeurs)}
print(dico_majuscule)
# Résultat : {'A': 1, 'B': 2, 'C': 3}
```

Dans cet exemple, la fonction `majuscule` est appliquée à chaque clé du dictionnaire.

#### 8. **Optimisation des performances avec des compréhensions**

Les compréhensions de dictionnaire sont non seulement plus concises que les boucles classiques, mais elles peuvent également offrir des **performances optimisées**. Par exemple, l’utilisation de `items()` pour accéder aux paires clé-valeur d’un dictionnaire dans une compréhension est plus rapide que d'utiliser une boucle classique.

#### 9. **Résumé des concepts clés**

- **Création rapide de dictionnaires** : La compréhension de dictionnaire permet de créer des dictionnaires en une ligne de code, en itérant sur des itérables et en appliquant des transformations ou des filtres.
- **Filtrage avec condition** : Il est possible d’ajouter une condition pour inclure uniquement certains éléments dans le dictionnaire.
- **Transformation des dictionnaires existants** : Les compréhensions permettent de modifier les clés ou les valeurs des dictionnaires de manière concise.
- **Complexité** : Vous pouvez imbriquer des compréhensions ou combiner plusieurs sources pour créer des structures plus complexes.

### Conclusion
La compréhension de dictionnaire est un outil puissant pour créer des dictionnaires de manière élégante et efficace, tout en optimisant la lisibilité et la performance de votre code Python.

### Chap 10 **Méthodes de classe et objets**

En Python, les **méthodes de classe** sont des fonctions qui appartiennent à une classe et qui peuvent être appelées sur des instances de cette classe. Elles sont utilisées pour définir les comportements des objets créés à partir de la classe. Le langage Python permet aussi d’utiliser des **méthodes spéciales** qui sont des fonctions intégrées permettant de personnaliser le comportement des objets, comme `__init__`, `__str__`, `__repr__`, etc. La gestion des **attributs d'instance** permet de manipuler et de gérer les données propres à chaque objet.

#### 1. **Création de classes et objets**

Avant de parler des méthodes de classe, voyons d'abord comment créer une classe en Python. Une **classe** est un modèle pour créer des objets (des instances). Elle contient des attributs et des méthodes qui définissent les comportements et les caractéristiques de ses instances.

```python
class Personne:
    def __init__(self, nom, age):
        self.nom = nom
        self.age = age

    def se_presenter(self):
        return f"Bonjour, je m'appelle {self.nom} et j'ai {self.age} ans."
```

Ici, la classe `Personne` a deux attributs d'instance (`nom` et `age`) et une méthode (`se_presenter`) qui permet à l'objet de se présenter.

#### 2. **Méthodes spéciales**

Les méthodes spéciales sont des méthodes pré-définies par Python pour modifier ou personnaliser le comportement de certains opérateurs ou fonctions intégrées.

##### **Méthode `__init__` (Constructeur)**

La méthode `__init__` est un **constructeur** spécial. Elle est appelée automatiquement lorsque vous créez une nouvelle instance de la classe. Elle sert à initialiser les attributs de l'objet.

```python
class Voiture:
    def __init__(self, marque, modèle):
        self.marque = marque
        self.modèle = modèle

    def afficher_info(self):
        return f"Voiture: {self.marque} {self.modèle}"

# Création d'une instance
voiture = Voiture('Toyota', 'Corolla')
```

Ici, la méthode `__init__` initialise les attributs `marque` et `modèle` de l'instance `voiture`.

##### **Méthode `__str__` (Représentation en chaîne de caractères)**

La méthode `__str__` est appelée lorsque l’on veut obtenir une **représentation sous forme de chaîne** de caractères de l'objet, généralement lors de l'utilisation de la fonction `print()`. Elle permet de personnaliser l'affichage d'un objet.

```python
class Personne:
    def __init__(self, nom, age):
        self.nom = nom
        self.age = age

    def __str__(self):
        return f"{self.nom} ({self.age} ans)"

# Création d'une instance
personne = Personne('Alice', 30)
print(personne)  # Affichera "Alice (30 ans)"
```

Ici, la méthode `__str__` permet de personnaliser l'affichage d'un objet `Personne` lors de l'appel à `print()`, en retournant une chaîne décrivant l'objet.

##### **Méthode `__repr__` (Représentation officielle)**

La méthode `__repr__` est utilisée pour retourner une **représentation officielle** de l'objet. Elle est appelée lorsque vous utilisez l’interpréteur interactif ou la fonction `repr()`. L'objectif est d’avoir une chaîne qui pourrait être utilisée pour recréer l’objet, ou à défaut, une représentation suffisamment détaillée.

```python
class Personne:
    def __init__(self, nom, age):
        self.nom = nom
        self.age = age

    def __repr__(self):
        return f"Personne('{self.nom}', {self.age})"

# Création d'une instance
personne = Personne('Bob', 25)
print(repr(personne))  # Affichera "Personne('Bob', 25)"
```

Ici, la méthode `__repr__` retourne une chaîne qui pourrait potentiellement être utilisée pour recréer l'objet à partir de cette chaîne.

#### 3. **Méthodes de classe et attributs d'instance**

Les **attributs d'instance** sont des variables qui appartiennent à une instance spécifique de la classe. Ils sont généralement initialisés dans la méthode `__init__` et sont accessibles via l'objet créé.

##### **Accès aux attributs d'instance**

L'accès aux attributs d'instance se fait via l'objet créé, en utilisant la syntaxe `objet.attribut`. Voici un exemple où l'attribut `nom` est modifié après la création de l'objet.

```python
class Etudiant:
    def __init__(self, nom, note):
        self.nom = nom
        self.note = note

    def modifier_note(self, nouvelle_note):
        self.note = nouvelle_note

etudiant = Etudiant('Alice', 15)
etudiant.modifier_note(18)
print(etudiant.note)  # Affichera 18
```

Ici, la méthode `modifier_note` permet de mettre à jour l'attribut `note` d'un étudiant.

##### **Méthodes de classe**

Les méthodes de classe sont des fonctions définies au sein de la classe et qui peuvent être appelées sur l’objet ou même sur la classe elle-même. Elles peuvent accéder aux **attributs de classe** (et non aux attributs d'instance). Pour définir une méthode de classe, vous utilisez le décorateur `@classmethod` et le premier argument doit être `cls`, représentant la classe elle-même.

```python
class CompteBancaire:
    taux_interet = 0.05  # Attribut de classe

    def __init__(self, titulaire, solde):
        self.titulaire = titulaire
        self.solde = solde

    @classmethod
    def modifier_taux_interet(cls, nouveau_taux):
        cls.taux_interet = nouveau_taux

    @classmethod
    def taux_actuel(cls):
        return cls.taux_interet

# Modification du taux d'intérêt via la méthode de classe
CompteBancaire.modifier_taux_interet(0.07)
print(CompteBancaire.taux_actuel())  # Affichera 0.07
```

Dans cet exemple, la méthode de classe `modifier_taux_interet` modifie l'attribut de classe `taux_interet` pour tous les objets de la classe `CompteBancaire`. La méthode `taux_actuel` permet d'obtenir la valeur actuelle de cet attribut.

#### 4. **Méthodes statiques**

Les **méthodes statiques** sont des méthodes qui n'ont pas besoin d'accéder à l'instance ou à la classe. Elles sont définies avec le décorateur `@staticmethod` et ne prennent ni `self` ni `cls` comme argument. Elles sont utilisées pour des opérations qui ne dépendent pas de l'état de l'objet ou de la classe.

```python
class Utilitaire:
    @staticmethod
    def additionner(a, b):
        return a + b

# Appel de la méthode statique sans créer d'instance
resultat = Utilitaire.additionner(3, 4)
print(resultat)  # Affichera 7
```

Dans cet exemple, la méthode statique `additionner` effectue une simple addition sans avoir besoin d'une instance de la classe.

#### 5. **Résumé des concepts clés**

- **Méthodes d'instance** : Des fonctions définies au sein de la classe qui opèrent sur les attributs spécifiques à l'instance.
- **`__init__`** : Le constructeur, utilisé pour initialiser les attributs d'une instance lors de sa création.
- **`__str__`** : Permet de définir la représentation sous forme de chaîne de caractères pour l'affichage.
- **`__repr__`** : Permet de définir la représentation plus détaillée et "officielle" de l'objet, souvent utilisée pour la reconstruction de l'objet.
- **Méthodes de classe** : Définies avec le décorateur `@classmethod`, elles agissent sur la classe elle-même et ses attributs de classe.
- **Méthodes statiques** : Des fonctions dans une classe qui ne nécessitent pas l'accès aux attributs ou méthodes de l'instance ou de la classe, définies avec le décorateur `@staticmethod`.

### Conclusion
Ces mécanismes de classes et d'objets permettent d’encapsuler le comportement et les caractéristiques des objets de manière modulaire et réutilisable. Ils facilitent la création d'applications plus structurées et compréhensibles.

### Chap 11 **Héritage et polymorphisme**

L'**héritage** et le **polymorphisme** sont des concepts fondamentaux de la **programmation orientée objet** (POO) qui permettent de créer des relations entre classes, de réutiliser du code et de modifier le comportement des objets de manière flexible. L'héritage permet à une classe dérivée (ou sous-classe) de recevoir les caractéristiques (attributs et méthodes) d'une classe de base (ou super-classe). Le polymorphisme, quant à lui, permet à différentes classes d'utiliser la même interface ou méthode, mais avec des comportements spécifiques à chaque classe.

#### 1. **Héritage**

L'héritage est un mécanisme qui permet à une classe de **hériter des propriétés et des comportements** d'une autre classe. La classe qui hérite est appelée **classe dérivée** ou **sous-classe**, et la classe dont elle hérite est appelée **classe de base** ou **super-classe**.

L'héritage permet d'éviter la duplication de code, car la classe dérivée peut utiliser les attributs et méthodes de la classe de base, tout en ayant la possibilité de les **modifier** ou **compléter**.

##### **Syntaxe de l'héritage**

En Python, une sous-classe est créée en plaçant le nom de la classe de base entre parenthèses après le nom de la sous-classe.

```python
class Animal:
    def __init__(self, nom):
        self.nom = nom

    def parler(self):
        return "L'animal fait un bruit."

class Chien(Animal):
    def __init__(self, nom, race):
        super().__init__(nom)  # Appel du constructeur de la super-classe
        self.race = race

    def parler(self):  # Redéfinition de la méthode parler
        return "Le chien aboie."

# Création d'instances
animal = Animal("Animal")
chien = Chien("Rex", "Labrador")

print(animal.parler())  # Affichera "L'animal fait un bruit."
print(chien.parler())   # Affichera "Le chien aboie."
```

Dans cet exemple, la classe `Chien` hérite de la classe `Animal` et redéfinit la méthode `parler`. La méthode `super().__init__(nom)` dans la sous-classe appelle le constructeur de la super-classe pour initialiser l'attribut `nom`.

#### 2. **Polymorphisme**

Le **polymorphisme** est un concept qui permet à des objets de types différents de répondre à une même méthode ou fonction, mais avec des comportements différents. En d'autres termes, le polymorphisme permet de définir des méthodes dans les classes dérivées qui portent le même nom que celles des classes de base, mais qui peuvent avoir des implémentations spécifiques à chaque classe dérivée.

Le polymorphisme permet d'utiliser des objets de types différents de manière uniforme.

##### **Exemple de polymorphisme**

Dans l'exemple ci-dessous, bien que la méthode `parler` existe dans toutes les classes (de base et dérivées), chaque classe définit son propre comportement pour cette méthode. Cela permet à un même appel de méthode (`parler()`) de produire des résultats différents en fonction de l'objet sur lequel il est appelé.

```python
class Chat(Animal):
    def parler(self):
        return "Le chat miaule."

# Création d'instances
chat = Chat("Minou")
chien = Chien("Rex", "Labrador")

# Polymorphisme
animaux = [chat, chien]

for animal in animaux:
    print(animal.parler())
```

Ici, le même appel `parler()` génère un comportement différent selon l'instance, qu'il s'agisse d'un `Chat` ou d'un `Chien`. Le polymorphisme permet de traiter ces objets de manière uniforme, tout en exécutant le code spécifique à chaque type d'objet.

##### **Avantages du polymorphisme**

1. **Flexibilité** : Le polymorphisme permet d'écrire des fonctions qui peuvent accepter des arguments de différents types, ce qui simplifie l'extension du programme.
2. **Extensibilité** : De nouvelles classes peuvent être ajoutées sans avoir besoin de modifier le code existant. Seules les méthodes spécifiques aux nouvelles classes doivent être définies.

#### 3. **Utilisation de `super()`**

La fonction `super()` permet d'appeler une méthode de la classe de base depuis la classe dérivée. Cela est particulièrement utile lorsque vous souhaitez appeler une méthode de la classe de base tout en ajoutant une fonctionnalité supplémentaire ou en modifiant le comportement de la méthode.

##### **Exemple d'utilisation de `super()`**

```python
class Voiture:
    def __init__(self, marque):
        self.marque = marque

    def demarrer(self):
        return f"La voiture {self.marque} démarre."

class VoitureElectrique(Voiture):
    def __init__(self, marque, batterie):
        super().__init__(marque)  # Appel du constructeur de la classe de base
        self.batterie = batterie

    def demarrer(self):
        return f"La voiture électrique {self.marque} démarre avec {self.batterie}% de batterie."

# Création d'objets
voiture = Voiture("Toyota")
voiture_electrique = VoitureElectrique("Tesla", 80)

print(voiture.demarrer())  # Affichera "La voiture Toyota démarre."
print(voiture_electrique.demarrer())  # Affichera "La voiture électrique Tesla démarre avec 80% de batterie."
```

Dans cet exemple, la classe `VoitureElectrique` hérite de la classe `Voiture` et utilise `super().__init__(marque)` pour appeler le constructeur de la classe `Voiture` et initialiser l'attribut `marque`.

#### 4. **Héritage multiple**

Python permet également l'héritage multiple, ce qui signifie qu'une classe peut hériter de plusieurs classes de base. Cela permet à une classe de combiner les comportements et attributs de plusieurs classes.

##### **Exemple d'héritage multiple**

```python
class Volant:
    def voler(self):
        return "L'objet vole."

class Nageur:
    def nager(self):
        return "L'objet nage."

class Oiseau(Volant, Nageur):
    pass

oiseau = Oiseau()
print(oiseau.voler())  # Affichera "L'objet vole."
print(oiseau.nager())  # Affichera "L'objet nage."
```

Dans cet exemple, la classe `Oiseau` hérite de deux classes de base, `Volant` et `Nageur`, ce qui lui permet d'avoir les comportements des deux classes.

#### 5. **Méthodes abstraites et héritage**

Dans les systèmes plus complexes, il peut être nécessaire de définir des **méthodes abstraites** dans des classes de base. Ces méthodes ne contiennent pas de logique, mais servent de modèle pour les sous-classes, qui doivent les implémenter. Pour cela, vous pouvez utiliser le module `abc` (Abstract Base Class).

##### **Exemple de méthodes abstraites**

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def parler(self):
        pass

class Chien(Animal):
    def parler(self):
        return "Le chien aboie."

class Chat(Animal):
    def parler(self):
        return "Le chat miaule."

# L'instanciation de Animal échouera
# animal = Animal()  # Erreur, Animal est abstraite

chien = Chien()
print(chien.parler())  # Affichera "Le chien aboie."

chat = Chat()
print(chat.parler())  # Affichera "Le chat miaule."
```

Dans cet exemple, la méthode `parler` est une méthode abstraite, ce qui signifie que toute sous-classe de `Animal` doit fournir une implémentation de cette méthode.

#### 6. **Résumé des concepts clés**

- **Héritage** : Mécanisme permettant à une classe dérivée de **hériter** des propriétés et méthodes d'une classe de base.
- **Polymorphisme** : Permet d'avoir différentes implémentations d'une même méthode dans des classes différentes, traitées de manière uniforme.
- **`super()`** : Fonction qui permet d'appeler une méthode de la classe de base dans une classe dérivée.
- **Héritage multiple** : Une classe peut hériter de plusieurs classes, ce qui permet de combiner des comportements provenant de plusieurs sources.
- **Méthodes abstraites** : Permet de définir des méthodes sans implémentation dans une classe de base, forçant les sous-classes à fournir leur propre implémentation.


### Conclusion
Ces concepts permettent de créer des systèmes complexes et modulaires en **réutilisant le code** et en favorisant la **flexibilité** du comportement des objets.

### Chap 12 **Méthodes statiques et de classe**

Les **méthodes statiques** et les **méthodes de classe** sont des concepts qui permettent de définir des méthodes liées à la classe elle-même, plutôt qu'à une instance d'objet. Ces méthodes peuvent être utilisées pour encapsuler des fonctionnalités spécifiques à la classe sans avoir besoin d'une instance de celle-ci. Les deux types de méthodes sont définis à l'aide de décorateurs spécifiques : `@staticmethod` pour les méthodes statiques et `@classmethod` pour les méthodes de classe.

#### 1. **Méthode statique (`@staticmethod`)**

Une **méthode statique** est une méthode qui est **liée à la classe** mais qui ne prend pas de référence à l'instance de la classe (pas de `self`) ni à la classe elle-même (pas de `cls`). Elle fonctionne de manière indépendante de l'état de l'objet et de la classe. Elle est utilisée principalement lorsque la méthode ne doit pas accéder aux attributs ou méthodes de la classe, mais qu’elle est néanmoins liée à cette classe par sa logique.

Les méthodes statiques sont utiles lorsque vous avez une fonction qui ne nécessite pas de connaître l'état interne de la classe, mais que vous voulez l'associer à une classe logique.

##### **Syntaxe de `@staticmethod`**

```python
class Exemple:
    @staticmethod
    def methode_statique():
        return "Méthode statique appelée."

# Appel de la méthode statique sans créer d'instance
print(Exemple.methode_statique())  # Affichera "Méthode statique appelée."
```

Dans cet exemple, la méthode `methode_statique` est appelée directement à partir de la classe, sans avoir besoin d'instancier un objet. Elle ne prend ni `self` ni `cls` comme argument.

##### **Quand utiliser une méthode statique ?**
- Lorsque la méthode ne dépend d'aucune donnée spécifique à une instance.
- Pour effectuer des calculs ou des transformations qui sont logiquement liés à la classe, mais qui ne nécessitent pas d'accès aux attributs ou méthodes de la classe ou de l'objet.

#### 2. **Méthode de classe (`@classmethod`)**

Une **méthode de classe** est une méthode qui prend comme premier argument la classe elle-même, et non l'instance. Cela lui permet d'accéder aux attributs de la classe et de les modifier. Les méthodes de classe sont utilisées pour des opérations qui concernent la classe dans son ensemble, et non un objet particulier.

Une méthode de classe est définie avec le décorateur `@classmethod`, et son premier argument est **généralement nommé `cls`** (pour "class").

##### **Syntaxe de `@classmethod`**

```python
class Exemple:
    compteur = 0  # Attribut de classe

    def __init__(self, nom):
        self.nom = nom
        Exemple.compteur += 1  # Augmente le compteur chaque fois qu'une instance est créée

    @classmethod
    def afficher_compteur(cls):
        return f"Il y a {cls.compteur} instances de la classe Exemple."

# Création d'instances
e1 = Exemple("Objet 1")
e2 = Exemple("Objet 2")

# Appel de la méthode de classe sans instancier un objet
print(Exemple.afficher_compteur())  # Affichera "Il y a 2 instances de la classe Exemple."
```

Ici, la méthode `afficher_compteur` est une méthode de classe, elle accède à l'attribut de classe `compteur` et retourne le nombre d'instances créées. Notez qu’elle est appelée sur la classe elle-même (`Exemple.afficher_compteur()`), et non sur une instance spécifique.

##### **Quand utiliser une méthode de classe ?**
- Lorsque vous avez besoin de modifier ou d'accéder aux **attributs de classe**, et non à ceux d'une instance.
- Pour créer des **méthodes d'usine** qui peuvent retourner des objets de la classe sans nécessiter un constructeur classique.
- Pour gérer des comportements ou des données qui concernent l'ensemble de la classe plutôt que des instances spécifiques.

#### 3. **Différences entre `@staticmethod` et `@classmethod`**

| Caractéristique         | `@staticmethod`                                    | `@classmethod`                                |
|-------------------------|----------------------------------------------------|-----------------------------------------------|
| **Premier argument**     | Aucun (`self` ou `cls` n'est pas utilisé)          | Reçoit un argument `cls` représentant la classe |
| **Accès aux attributs**  | Ne peut pas accéder à des attributs de classe ou d'instance | Peut accéder et modifier des attributs de classe |
| **Usage**                | Lorsque la méthode ne dépend pas de l'état de la classe ou de l'objet | Lorsque la méthode a besoin d'interagir avec la classe ou ses attributs |
| **Appel**                | Appelée sur la classe ou une instance sans modifier l'état de la classe ou de l'objet | Appelée sur la classe ou une instance et peut modifier l'état de la classe |

#### 4. **Méthodes de classe comme méthodes d'usine**

Une utilisation fréquente des méthodes de classe est de les utiliser comme **méthodes d'usine**, c'est-à-dire des méthodes qui permettent de créer des instances de la classe d'une manière différente du constructeur classique (`__init__`).

##### **Exemple d'une méthode d'usine**

```python
class Voiture:
    def __init__(self, marque, modele):
        self.marque = marque
        self.modele = modele

    @classmethod
    def from_string(cls, chaine):
        marque, modele = chaine.split('-')
        return cls(marque, modele)  # Crée une instance à partir d'une chaîne

# Utilisation de la méthode d'usine
voiture = Voiture.from_string("Toyota-Camry")
print(voiture.marque)  # Affichera "Toyota"
print(voiture.modele)  # Affichera "Camry"
```

Dans cet exemple, `from_string` est une méthode de classe utilisée pour créer une instance de `Voiture` à partir d'une chaîne de caractères. Cela permet de traiter des formats d'entrée ou des données de manière plus flexible.

#### 5. **Résumé des concepts clés**

- **Méthode statique (`@staticmethod`)** : 
  - Liée à la classe mais ne prend pas d'argument relatif à l'objet (`self`) ou à la classe (`cls`).
  - Ne peut pas accéder aux attributs ou méthodes d'instance ou de classe.
  - Utile pour des fonctions qui sont logiquement associées à une classe, mais indépendantes de l'état des objets ou de la classe elle-même.
  
- **Méthode de classe (`@classmethod`)** :
  - Liée à la classe et prend comme premier argument `cls`, représentant la classe.
  - Peut accéder et modifier les attributs de classe, et est souvent utilisée pour des méthodes d'usine ou pour manipuler des données globales à la classe.
  - Permet de créer des instances ou de gérer des comportements communs à toute la classe.

### Conclusion
Ces deux types de méthodes offrent des moyens puissants et flexibles de gérer les fonctionnalités au niveau de la classe, en fonction de l'état de l'objet ou de la classe.

### Chap 13 **Modules tiers (bibliothèques externes)**

Les **modules tiers** ou **bibliothèques externes** sont des ensembles de fonctions et d'outils créés par des développeurs extérieurs à la bibliothèque standard de Python. Ils permettent d'étendre les fonctionnalités de Python en offrant des solutions prêtes à l'emploi pour des tâches spécifiques. Ces modules peuvent être utilisés pour simplifier des processus complexes, améliorer la performance, ou intégrer des fonctionnalités avancées, telles que le calcul scientifique, la manipulation de données, ou la communication réseau.

Python bénéficie d'un écosystème riche en modules tiers, qui peuvent être installés via le gestionnaire de paquets `pip`. Certains des modules tiers les plus populaires incluent **NumPy** (pour les calculs scientifiques), **Pandas** (pour la manipulation de données), **Requests** (pour les requêtes HTTP), et **Matplotlib** (pour la visualisation de données).

#### 1. **Installation des modules tiers**

Avant d'utiliser un module tiers dans un projet Python, vous devez d'abord l'installer. Python utilise le gestionnaire de paquets `pip` pour installer ces modules. Vous pouvez installer un module via la ligne de commande comme suit :

```bash
pip install nom_du_module
```

Exemple pour installer **NumPy** :

```bash
pip install numpy
```

Une fois installé, vous pouvez l'importer dans votre code Python comme suit :

```python
import numpy as np
```

#### 2. **Exemples de bibliothèques tierces courantes**

##### **NumPy** : pour les calculs scientifiques

**NumPy** est une bibliothèque fondamentale pour les calculs scientifiques en Python. Elle fournit des structures de données puissantes comme les **tableaux multidimensionnels** et des fonctions pour effectuer des opérations mathématiques complexes sur ces tableaux.

**Fonctionnalités :**
- Création de tableaux N-dimensionnels.
- Opérations mathématiques rapides (addition, multiplication, transformations linéaires).
- Fonctionnalités pour le traitement de matrices et d'algèbre linéaire.

**Installation :**

```bash
pip install numpy
```

**Exemple d'utilisation :**

```python
import numpy as np

# Création d'un tableau NumPy
tableau = np.array([1, 2, 3, 4])

# Opération mathématique sur le tableau
tableau_au_carree = tableau ** 2
print(tableau_au_carree)  # Affiche [1 4 9 16]
```

##### **Pandas** : pour la manipulation de données

**Pandas** est une bibliothèque populaire pour la manipulation de données sous forme de tables (données structurées). Elle offre des outils pour lire, nettoyer, et analyser des données provenant de divers formats (CSV, Excel, bases de données, etc.).

**Fonctionnalités :**
- Structures de données puissantes : `DataFrame` (tableaux à 2 dimensions) et `Series` (tableaux à 1 dimension).
- Lecture et écriture de données à partir de fichiers externes (CSV, Excel, SQL, etc.).
- Manipulation de données : filtrage, agrégation, fusion.

**Installation :**

```bash
pip install pandas
```

**Exemple d'utilisation :**

```python
import pandas as pd

# Création d'un DataFrame à partir d'une liste de dictionnaires
data = {'Nom': ['Alice', 'Bob', 'Charlie'], 'Âge': [25, 30, 35]}
df = pd.DataFrame(data)

# Affichage du DataFrame
print(df)

# Accès aux données d'une colonne
print(df['Nom'])  # Affiche les noms des personnes
```

##### **Requests** : pour effectuer des requêtes HTTP

La bibliothèque **Requests** permet d'effectuer facilement des requêtes HTTP, ce qui est utile pour interagir avec des API web ou récupérer des données à partir de sites web.

**Fonctionnalités :**
- Envoi de requêtes HTTP (GET, POST, PUT, DELETE, etc.).
- Gestion des réponses HTTP (récupération du statut, des en-têtes, du contenu, etc.).
- Prise en charge de l'authentification, des sessions, des cookies.

**Installation :**

```bash
pip install requests
```

**Exemple d'utilisation :**

```python
import requests

# Envoi d'une requête GET
response = requests.get('https://api.github.com')

# Affichage du statut de la réponse
print(response.status_code)  # Affiche le code de statut HTTP

# Affichage du contenu de la réponse en JSON
data = response.json()
print(data)
```

##### **Matplotlib** : pour la visualisation de données

**Matplotlib** est une bibliothèque utilisée pour générer des graphiques 2D (comme des courbes, histogrammes, et diagrammes en secteurs), très utilisée dans l'analyse de données et les rapports visuels.

**Fonctionnalités :**
- Création de graphiques de différentes sortes : courbes, barres, diagrammes circulaires, etc.
- Personnalisation des graphiques (titres, légendes, couleurs, axes).
- Exportation des graphiques dans divers formats (PNG, PDF, SVG).

**Installation :**

```bash
pip install matplotlib
```

**Exemple d'utilisation :**

```python
import matplotlib.pyplot as plt

# Création de données
x = [1, 2, 3, 4, 5]
y = [1, 4, 9, 16, 25]

# Création d'un graphique
plt.plot(x, y)

# Ajout de titres et labels
plt.title('Graphique Exemple')
plt.xlabel('X')
plt.ylabel('Y')

# Affichage du graphique
plt.show()
```

#### 3. **Utilisation de modules tiers dans les projets**

L'utilisation de modules tiers dans vos projets peut considérablement simplifier le développement et accélérer la réalisation de vos applications. Ces bibliothèques offrent une large gamme de fonctionnalités pour des domaines aussi variés que :
- **Le traitement des données** (Pandas, NumPy).
- **La visualisation** (Matplotlib, Seaborn).
- **La communication réseau** (Requests, Socket).
- **Le machine learning et l'IA** (TensorFlow, Scikit-learn).
- **Les interfaces graphiques** (Tkinter, PyQt).

Les modules tiers sont généralement bien documentés et largement utilisés par la communauté Python, ce qui permet d'avoir un accès facile à des ressources et à du support.

#### 4. **Gestion des dépendances et des versions**

Lorsque vous travaillez avec des bibliothèques tierces dans un projet, il est important de gérer les dépendances. Cela garantit que les versions des bibliothèques sont cohérentes avec celles requises par votre code. Un fichier `requirements.txt` est souvent utilisé pour lister les bibliothèques et leurs versions spécifiques.

##### **Création d'un fichier `requirements.txt`**

```bash
pip freeze > requirements.txt
```

Ce fichier peut ensuite être utilisé pour installer toutes les dépendances d'un projet :

```bash
pip install -r requirements.txt
```

#### 5. **Résumé des concepts clés**

- Les **modules tiers** permettent d'étendre les fonctionnalités de Python en ajoutant des outils spécialisés pour des tâches spécifiques.
- Vous pouvez installer des modules tiers avec le gestionnaire de paquets `pip`.
- Les bibliothèques populaires incluent **NumPy** pour les calculs numériques, **Pandas** pour la manipulation de données, **Requests** pour les requêtes HTTP, et **Matplotlib** pour la visualisation de données.
- Pour une gestion optimale des projets, il est essentiel de gérer les dépendances à l'aide de fichiers comme `requirements.txt`.

### Conclusion
Les modules tiers sont essentiels pour travailler efficacement dans des domaines spécialisés et offrir des solutions rapides et fiables à des problèmes courants en Python.

### Chap 14 **Commutateurs (Match/Case)**

La structure **`match`** introduite dans **Python 3.10** permet de réaliser des évaluations conditionnelles de manière plus lisible et plus structurée que les classiques blocs `if/elif/else`. Elle fonctionne de manière similaire aux commutateurs (`switch/case`) dans d'autres langages de programmation, mais avec plus de flexibilité, notamment grâce à l'utilisation de **pattern matching** (correspondance de motifs).

Le **`match`** permet de comparer une valeur à plusieurs motifs possibles (`case`), et d'exécuter un bloc de code lorsque le motif correspond à la valeur. Cette structure peut être utilisée pour une évaluation plus complexe des données, notamment pour des types comme les objets, les dictionnaires, ou les tuples, avec la possibilité d'extraire des informations des valeurs correspondantes.

#### 1. **Syntaxe de base**

La syntaxe de la structure `match` est la suivante :

```python
match variable:
    case motif_1:
        # bloc de code si motif_1 correspond
    case motif_2:
        # bloc de code si motif_2 correspond
    case _:
        # bloc de code si aucun motif ne correspond (cas par défaut)
```

- **`variable`** : C'est la valeur que vous souhaitez évaluer.
- **`motif_1`, `motif_2`** : Ce sont les motifs avec lesquels vous comparez la valeur.
- **`_`** : Cela correspond à un motif générique, un "joker", qui capte tous les cas qui n'ont pas été pris en compte.

#### 2. **Fonctionnement et utilisation**

La structure `match/case` fonctionne en effectuant une comparaison entre la valeur et chaque motif, de haut en bas. Dès qu'un motif est trouvé qui correspond à la valeur, le bloc de code associé à ce motif est exécuté, et l'exécution de la structure `match` s'arrête.

##### Exemple simple :

```python
def jour_de_la_semaine(jour):
    match jour:
        case "lundi":
            print("Début de la semaine")
        case "mercredi":
            print("Milieu de la semaine")
        case "vendredi":
            print("Fin de la semaine")
        case _:
            print("Jour inconnu")

# Test
jour_de_la_semaine("mercredi")  # Affiche: Milieu de la semaine
```

Dans cet exemple, on teste la variable `jour` contre plusieurs motifs (les jours spécifiques de la semaine). Si `jour` correspond à l'un des cas définis, le code associé est exécuté. Le motif `_` est le cas par défaut et s'exécute si aucun autre cas ne correspond.

#### 3. **Pattern Matching Avancé**

Le `match` dans Python 3.10 ne se limite pas à une simple comparaison de valeurs, il peut être beaucoup plus puissant grâce à des fonctionnalités avancées comme la correspondance avec des objets, des listes, des dictionnaires ou des tuples, et même l'extraction de valeurs à partir des structures de données.

##### a. **Correspondance avec des tuples ou des séquences**

Le `match` peut être utilisé pour décomposer des tuples ou des listes en leurs éléments, permettant ainsi de comparer et d'extraire des valeurs spécifiques.

```python
def test_tuple(val):
    match val:
        case (a, b):  # Correspond à un tuple à deux éléments
            print(f"Tuile avec deux éléments: {a}, {b}")
        case (a, b, c):  # Correspond à un tuple à trois éléments
            print(f"Tuile avec trois éléments: {a}, {b}, {c}")
        case _:
            print("Autre cas")

# Test
test_tuple((1, 2))  # Affiche: Tuile avec deux éléments: 1, 2
test_tuple((1, 2, 3))  # Affiche: Tuile avec trois éléments: 1, 2, 3
```

##### b. **Correspondance avec des dictionnaires**

La correspondance avec des dictionnaires permet de vérifier si certains éléments spécifiques existent dans un dictionnaire et d'extraire leur valeur.

```python
def test_dict(val):
    match val:
        case {"nom": nom, "age": age}:  # Correspond à un dictionnaire avec les clés "nom" et "age"
            print(f"Nom: {nom}, Âge: {age}")
        case _:
            print("Autre cas")

# Test
test_dict({"nom": "Alice", "age": 30})  # Affiche: Nom: Alice, Âge: 30
```

Dans cet exemple, on utilise la structure `match` pour correspondre avec des dictionnaires et extraire les valeurs associées aux clés spécifiques (`"nom"` et `"age"`).

##### c. **Correspondance avec des objets complexes**

Vous pouvez également utiliser `match/case` pour travailler avec des objets et extraire des valeurs de leurs attributs. Cela est particulièrement utile pour les classes et les objets complexes.

```python
class Personne:
    def __init__(self, nom, age):
        self.nom = nom
        self.age = age

def test_objet(val):
    match val:
        case Personne(nom, age):  # Correspond à un objet de type Personne
            print(f"Personne: {nom}, Âge: {age}")
        case _:
            print("Autre cas")

# Test
personne = Personne("Bob", 25)
test_objet(personne)  # Affiche: Personne: Bob, Âge: 25
```

Ici, nous correspondons à un objet `Personne` et extrayons ses attributs `nom` et `age`.

#### 4. **Utilisation d'expressions régulières dans `match`**

Le `match` peut également être utilisé avec des expressions régulières, ce qui permet d'effectuer des correspondances basées sur des motifs plus complexes, comme des chaînes de caractères.

```python
import re

def test_regex(val):
    match val:
        case re.match(r"\d+", n):  # Correspond à une chaîne contenant uniquement des chiffres
            print(f"Nombre trouvé: {n}")
        case _:
            print("Non un nombre")

# Test
test_regex("12345")  # Affiche: Nombre trouvé: 12345
```

Dans cet exemple, le `match` est utilisé avec une expression régulière pour vérifier si une chaîne de caractères est composée uniquement de chiffres.

#### 5. **Résumé des concepts clés**

- **`match`** est une structure de contrôle introduite dans Python 3.10, qui permet de réaliser des évaluations conditionnelles avec une syntaxe plus claire et plus expressive que les blocs `if/elif/else`.
- Le `match` fonctionne de manière similaire à un `switch/case`, mais avec un pouvoir beaucoup plus étendu, en permettant de faire correspondre des motifs complexes (tuples, dictionnaires, objets, etc.).
- Vous pouvez extraire des valeurs à partir des motifs et travailler avec des types de données structurés comme des objets ou des listes.
- Le **`_`** est un motif générique qui capte les cas par défaut, et permet d'implémenter des logiques plus flexibles.
- Le `match` en Python permet également d'utiliser des expressions régulières et des objets complexes pour des correspondances plus détaillées.

### Conclusion
Cette fonctionnalité améliore la lisibilité du code et permet de gérer des cas complexes de manière plus élégante et concise.

### Chap 15 **Type hints et annotations**

Les **annotations de type** sont une fonctionnalité de Python introduite dans la version 3.5, qui permet aux développeurs de spécifier explicitement les types de variables, de paramètres de fonction et de valeurs de retour. Bien que Python soit un langage dynamiquement typé, les annotations de type offrent plusieurs avantages, notamment une meilleure lisibilité du code, un support accru des outils d'analyse statique (comme **mypy**) et une meilleure intégration dans les IDE pour la suggestion de types et la vérification des erreurs.

#### 1. **Syntaxe des annotations de type**

Les annotations de type sont intégrées à la syntaxe Python à travers des **syntaxes simples** ou des **types plus complexes**.

##### a. **Annotations de type pour les variables**

Les annotations de type peuvent être utilisées pour spécifier le type attendu d'une variable. Cette annotation est placée après le nom de la variable, séparée par un deux-points (`:`).

```python
x: int = 10  # x est un entier
nom: str = "Alice"  # nom est une chaîne de caractères
```

Ici, `x` est annoté comme étant un **entier** et `nom` comme étant une **chaîne de caractères**.

##### b. **Annotations de type pour les arguments de fonction**

Les annotations de type peuvent également être utilisées pour indiquer les types des paramètres d'une fonction.

```python
def addition(a: int, b: int) -> int:
    return a + b
```

Dans cet exemple :
- `a` et `b` sont des **entiers** (int).
- La fonction renvoie également un **entier** (indiqué après le `->`).

##### c. **Annotations de type pour la valeur de retour**

La syntaxe `-> type` est utilisée pour spécifier le type de la valeur de retour d'une fonction.

```python
def salutation(nom: str) -> str:
    return "Bonjour " + nom
```

Ici, la fonction `salutation` prend un argument de type `str` (chaîne de caractères) et renvoie également une valeur de type `str`.

#### 2. **Types complexes**

Les annotations de type ne se limitent pas aux types de base comme `int`, `str`, ou `float`. Il est possible de spécifier des types plus complexes, comme des collections (listes, dictionnaires), des types optionnels, ou des types personnalisés.

##### a. **Listes et dictionnaires**

Pour indiquer qu'un argument ou une variable est une liste ou un dictionnaire contenant des éléments de types spécifiques, on peut utiliser les types génériques du module `typing`.

```python
from typing import List, Dict

def somme_liste(nombres: List[int]) -> int:
    return sum(nombres)

def dico_utilisateur(utilisateurs: Dict[str, int]) -> str:
    return f"Il y a {len(utilisateurs)} utilisateurs."
```

- **`List[int]`** indique une **liste d'entiers**.
- **`Dict[str, int]`** indique un **dictionnaire** avec des **clés de type `str`** et des **valeurs de type `int`**.

##### b. **Types optionnels avec `Optional`**

Le type `Optional` est utilisé pour indiquer qu'un paramètre ou une variable peut avoir une valeur `None`, en plus de son type habituel.

```python
from typing import Optional

def trouver_element(liste: List[int], element: int) -> Optional[int]:
    try:
        return liste.index(element)
    except ValueError:
        return None
```

Ici, `Optional[int]` signifie que la fonction peut renvoyer soit un **entier**, soit `None`.

##### c. **Union de types avec `Union`**

L'annotation `Union` permet de spécifier que le type d'une variable ou d'un argument peut être l'un de plusieurs types possibles.

```python
from typing import Union

def traiter_input(val: Union[int, str]) -> str:
    if isinstance(val, int):
        return f"Entier: {val}"
    elif isinstance(val, str):
        return f"Chaîne: {val}"
    else:
        return "Type inconnu"
```

Dans cet exemple, la fonction `traiter_input` accepte soit un **entier**, soit une **chaîne de caractères**.

##### d. **Tuple avec `Tuple`**

La syntaxe `Tuple` permet de spécifier les types des éléments d'un tuple, y compris le nombre d'éléments s'il est fixe.

```python
from typing import Tuple

def coordonnees() -> Tuple[int, int]:
    return (10, 20)
```

Ici, la fonction `coordonnees` renvoie un **tuple** composé de deux **entiers**.

#### 3. **Utilisation de `Any`**

Si vous n'êtes pas sûr du type d'une variable, vous pouvez utiliser `Any`, qui indique que cette variable peut être de n'importe quel type.

```python
from typing import Any

def echo(val: Any) -> Any:
    return val
```

Le type `Any` est utile lorsque vous travaillez avec des valeurs de types indéfinis ou dynamiques, mais son utilisation réduit l'efficacité des vérifications de type statique.

#### 4. **Fonctionnalités avancées avec `TypeVar` et `Callable`**

##### a. **`TypeVar` pour les types génériques**

La classe `TypeVar` permet de créer des **types génériques**. Elle permet de spécifier que plusieurs variables ont le même type, mais ce type n'est pas défini à l'avance.

```python
from typing import TypeVar

T = TypeVar('T')

def premier_element(val: List[T]) -> T:
    return val[0]
```

Ici, `T` est un **type variable** qui permet de spécifier qu'un argument de type `List[T]` sera une liste d'éléments du même type, et que la fonction `premier_element` renverra le même type.

##### b. **`Callable` pour les fonctions comme types**

Le type `Callable` permet de spécifier des fonctions comme types. Il permet de définir les types d'arguments et de retour d'une fonction.

```python
from typing import Callable

def execute(fonction: Callable[[int, int], int]) -> int:
    return fonction(2, 3)

# Exemple d'utilisation
def addition(a: int, b: int) -> int:
    return a + b

resultat = execute(addition)  # Retourne 5
```

Ici, `Callable[[int, int], int]` indique que la fonction passée en paramètre doit accepter deux entiers en arguments et renvoyer un entier.

#### 5. **Outils de vérification des types**

Il existe des outils de vérification statique des types comme **mypy** qui permettent de s'assurer que le code respecte bien les annotations de type. Ces outils peuvent être utilisés pour vérifier que les types des variables et des paramètres de fonction sont correctement respectés, ce qui améliore la robustesse du code.

```bash
# Installer mypy
pip install mypy

# Vérification d'un fichier Python avec mypy
mypy mon_script.py
```

#### 6. **Résumé des concepts clés**

- **Les annotations de type** permettent de spécifier le type des variables, des arguments et des valeurs de retour des fonctions.
- Elles **améliorent la lisibilité** du code, permettent une **vérification statique** avec des outils comme `mypy`, et aident à éviter les erreurs de type.
- Python offre des types simples comme **`int`**, **`str`**, et **`float`**, mais aussi des types complexes comme **`List`**, **`Dict`**, **`Tuple`**, **`Optional`**, **`Union`**, et **`Any`**.
- Vous pouvez utiliser des fonctionnalités avancées comme **`Callable`** et **`TypeVar`** pour les fonctions génériques et la gestion dynamique des types.
- Bien que Python reste un langage **dynamiquement typé**, les annotations de type ajoutent un niveau de sécurité et de précision qui est particulièrement utile dans les projets complexes.

### Conclusion
Les annotations de type ne changent pas le comportement du code à l'exécution, mais offrent un meilleur outillage pour le développement, l'optimisation du code et la détection des erreurs.

### Chap 16 **Gestion de la mémoire et des ressources**

La gestion de la mémoire et des ressources est un aspect fondamental du développement en Python, bien que le langage repose principalement sur un **ramasse-miettes** (garbage collector) pour automatiser la gestion de la mémoire. Cependant, Python offre aussi des mécanismes permettant aux développeurs de mieux contrôler l'utilisation des ressources, en particulier pour les ressources limitées ou coûteuses, telles que les fichiers ou les connexions réseau.

#### 1. **Le ramasse-miettes (Garbage Collection)**

Python utilise un **ramasse-miettes (garbage collector)** pour gérer la mémoire automatiquement en supprimant les objets qui ne sont plus utilisés, ce qui permet de libérer de la mémoire sans intervention manuelle. Cependant, ce mécanisme n'est pas parfait et peut parfois entraîner des fuites de mémoire si les objets restent référencés dans des structures complexes.

##### a. **Référence comptée**

Python utilise principalement un système de **référence comptée** pour suivre les objets en mémoire. Chaque objet dans Python possède un compteur de références qui est incrémenté chaque fois qu'une nouvelle référence à cet objet est créée et décrémenté chaque fois qu'une référence est supprimée. Lorsque le compteur atteint zéro, cela signifie qu'aucune référence n'existe plus pour cet objet, et il peut être libéré.

Exemple :
```python
a = [1, 2, 3]  # Création de l'objet
b = a  # b fait référence à a
del a  # Suppression de la référence a, mais l'objet n'est pas supprimé tant que b existe
del b  # À ce moment, l'objet est supprimé
```

##### b. **Garbage Collector et cycles**

Le ramasse-miettes de Python gère également les **cycles de référence**, où deux ou plusieurs objets se réfèrent mutuellement, empêchant leur suppression automatique. Dans ce cas, Python utilise un **collecteur de cycles** pour identifier et supprimer ces cycles de référence.

```python
import gc

gc.collect()  # Force le ramasse-miettes à effectuer une collecte manuelle
```

Bien que Python gère automatiquement la mémoire, l’utilisation d'outils comme `gc` permet de contrôler ce processus.

#### 2. **Gestion des ressources avec `with` (Context Managers)**

Le mot-clé `with` est utilisé pour gérer des ressources qui nécessitent un nettoyage ou une libération explicite après usage. Il est notamment employé pour les **fichiers**, **connexions réseau**, ou **verrous** dans les environnements multi-threads.

Le mécanisme sous-jacent au `with` repose sur les **gestes contextuels** (`context managers`), qui s'assurent que les ressources sont correctement acquises et libérées, même en cas d'exception.

##### a. **Fichiers**

Lors de l'ouverture d'un fichier, vous pouvez utiliser le bloc `with` pour garantir que le fichier est bien fermé après utilisation, sans avoir besoin d'appeler explicitement `file.close()`.

```python
with open('mon_fichier.txt', 'r') as f:
    contenu = f.read()
# Le fichier est automatiquement fermé à la fin du bloc, même en cas d'exception.
```

##### b. **Verrous et Concurrence**

Lors de l'utilisation de **verrous** pour gérer des ressources partagées dans un environnement concurrent, `with` permet de garantir que le verrou est acquis et libéré correctement.

```python
import threading

verrou = threading.Lock()

with verrou:
    # Code critique où l'accès aux ressources partagées est contrôlé
    pass  # Exemple d'accès à une ressource partagée
# Le verrou est automatiquement libéré ici.
```

##### c. **Context Manager personnalisé**

Vous pouvez créer vos propres **context managers** en définissant des classes avec les méthodes spéciales `__enter__` et `__exit__`. Cela permet de gérer des ressources spécifiques de manière propre et contrôlée.

```python
class ConnexionBaseDeDonnees:
    def __enter__(self):
        # Initialisation de la connexion
        self.conn = "Connexion à la base de données"
        return self.conn

    def __exit__(self, exc_type, exc_value, traceback):
        # Libération de la connexion
        print("Fermeture de la connexion à la base de données.")
        self.conn = None

with ConnexionBaseDeDonnees() as db_conn:
    print("Utilisation de la connexion :", db_conn)
# La connexion est automatiquement fermée à la fin du bloc `with`
```

#### 3. **Références faibles (Weak References)**

Dans certaines situations, il peut être nécessaire de créer des références à des objets sans les empêcher d'être collectés par le garbage collector. Cela peut être utile pour la gestion de caches, de pools d'objets, ou d'autres structures de données où vous souhaitez éviter de créer des références fortes qui empêcheraient la collecte de l'objet.

Python fournit le module `weakref` pour créer des **références faibles**.

```python
import weakref

class MonObjet:
    def __init__(self, nom):
        self.nom = nom

obj = MonObjet("Exemple")
ref = weakref.ref(obj)  # Crée une référence faible à l'objet

# L'objet peut être collecté par le garbage collector même si ref existe
del obj
print(ref())  # Affiche None car l'objet a été collecté
```

Les références faibles permettent à l'objet de vivre sa vie normalement, mais sans empêcher sa collecte lorsque toutes les autres références sont supprimées.

#### 4. **Gestion des ressources avec `try/except/finally`**

Bien que l'utilisation de `with` soit la méthode privilégiée pour la gestion des ressources, vous pouvez aussi gérer la libération des ressources manuellement à l'aide des blocs `try/except/finally`. Le bloc `finally` est exécuté quelle que soit la survenue d'une exception et permet de s'assurer que certaines opérations de nettoyage sont réalisées.

```python
file = None
try:
    file = open("mon_fichier.txt", "r")
    # Traitement du fichier
except IOError:
    print("Erreur d'entrée/sortie.")
finally:
    if file:
        file.close()  # Fermeture du fichier, qu'une exception se produise ou non
```

#### 5. **Optimisation de la gestion de la mémoire**

Bien que Python gère automatiquement la mémoire, il existe certaines stratégies pour **optimiser l'utilisation de la mémoire** dans des programmes à grande échelle :

- **Eviter la création excessive d'objets** dans les boucles, en réutilisant des objets lorsque possible.
- Utiliser des **structures de données immutables** (comme les tuples ou les chaînes de caractères) lorsqu'elles conviennent, car elles peuvent être partagées efficacement entre différentes parties du programme.
- **Profilage de la mémoire** avec des outils comme `tracemalloc` pour identifier les fuites de mémoire ou les objets inutilisés qui sont toujours référencés.
- Utiliser des structures comme les **`deque`** ou les **`array`** du module `collections` ou `array` respectivement pour des performances mémoire optimisées sur de grandes quantités de données.

#### 6. **Résumé des concepts clés**

- Le **ramasse-miettes (garbage collector)** de Python gère la mémoire automatiquement en supprimant les objets non utilisés, mais peut parfois laisser des objets dans des cycles de référence non collectés.
- Le **mot-clé `with`** et les **context managers** permettent une gestion élégante et automatique des ressources, notamment pour les fichiers, les verrous ou toute ressource nécessitant un nettoyage explicite.
- Les **références faibles** (via le module `weakref`) permettent de créer des références qui n'empêchent pas les objets d'être collectés par le garbage collector.
- Le bloc `finally` dans les instructions `try/except/finally` peut également être utilisé pour garantir la libération des ressources, même en cas d'exception.
- Des outils comme `gc` et `tracemalloc` permettent de surveiller et de gérer l'utilisation de la mémoire dans les programmes Python.

### Chap 17 **Multithreading et Multiprocessing**

Python offre plusieurs mécanismes permettant d'exécuter des tâches en parallèle, notamment à travers le **multithreading** et le **multiprocessing**. Ces techniques permettent d'optimiser l'utilisation des ressources du système, d'améliorer la réactivité des applications et de paralléliser des tâches lourdes. Cependant, elles possèdent des caractéristiques et des usages différents, que l'on explore ci-dessous.

#### 1. **Multithreading**

Le **multithreading** permet d'exécuter plusieurs tâches en parallèle au sein d'un même processus en utilisant des **threads**. Chaque thread représente un flux d'exécution distinct. Le multithreading est particulièrement utile pour des tâches **I/O-bound** (comme les lectures et écritures de fichiers, la gestion des requêtes réseau, etc.), où l'attente des opérations d'entrée/sortie peut être masquée pendant que d'autres tâches sont effectuées.

##### a. **GIL (Global Interpreter Lock)**

Python utilise le **Global Interpreter Lock** (GIL), un mécanisme qui garantit qu'à tout moment, un seul thread exécute du bytecode Python. Cela signifie que, bien que le multithreading puisse être utilisé pour améliorer la réactivité dans le cas de tâches I/O-bound, il ne permet pas d'exécuter réellement plusieurs threads en parallèle pour les tâches **CPU-bound** (qui nécessitent un calcul intensif), car le GIL limite l'exécution à un seul thread Python à la fois.

##### b. **Création et gestion des threads**

Pour utiliser les threads en Python, le module `threading` est souvent utilisé. Il fournit une interface simple pour créer et gérer des threads.

```python
import threading

def fonction():
    print("Thread en cours d'exécution")

# Créer un thread
thread = threading.Thread(target=fonction)

# Démarrer le thread
thread.start()

# Attendre la fin de l'exécution du thread
thread.join()
```

##### c. **Limites du multithreading**

Bien que le multithreading puisse être efficace pour des tâches I/O-bound, il présente des limites pour les tâches CPU-bound, car le GIL empêche une véritable exécution parallèle sur plusieurs cœurs de processeur. Si vous devez exécuter des calculs lourds, le **multiprocessing** est souvent préféré.

#### 2. **Multiprocessing**

Le **multiprocessing** permet d'exécuter plusieurs processus distincts en parallèle. Contrairement au multithreading, chaque processus possède sa propre **mémoire et espace d'adressage**, ce qui permet de contourner les limitations imposées par le GIL. Le multiprocessing est particulièrement utile pour les tâches **CPU-bound**, où des calculs intensifs nécessitent une exécution parallèle réelle sur plusieurs cœurs du processeur.

##### a. **Création de processus avec `multiprocessing`**

Le module `multiprocessing` permet de créer et de gérer des processus en parallèle. Chaque processus fonctionne indépendamment, ce qui le rend idéal pour exploiter pleinement les capacités de traitement d'un ordinateur multicœur.

```python
import multiprocessing

def fonction():
    print("Processus en cours d'exécution")

# Créer un processus
processus = multiprocessing.Process(target=fonction)

# Démarrer le processus
processus.start()

# Attendre la fin du processus
processus.join()
```

##### b. **Partage des données entre processus**

Les processus étant indépendants, ils ne partagent pas directement de mémoire. Pour échanger des données entre processus, il est nécessaire d'utiliser des **queues**, des **pipes** ou des **mémoires partagées** fournies par le module `multiprocessing`.

Exemple avec `Queue` pour partager des données entre processus :

```python
import multiprocessing

def envoyer_donnees(queue):
    queue.put("Donnée partagée")

# Créer une queue pour partager les données
queue = multiprocessing.Queue()

# Créer un processus qui envoie des données
processus = multiprocessing.Process(target=envoyer_donnees, args=(queue,))
processus.start()
processus.join()

# Récupérer les données
data = queue.get()
print(data)
```

##### c. **Pools de processus**

Le module `multiprocessing` fournit également la classe `Pool` qui permet de gérer un ensemble de processus en parallèle, simplifiant l'exécution de tâches parallèles sur un grand nombre de données.

```python
import multiprocessing

def fonction(x):
    return x * x

# Créer un pool de 4 processus
with multiprocessing.Pool(4) as pool:
    resultats = pool.map(fonction, [1, 2, 3, 4, 5])
    print(resultats)  # Affiche [1, 4, 9, 16, 25]
```

#### 3. **Comparaison entre Multithreading et Multiprocessing**

| **Caractéristique**     | **Multithreading**                                      | **Multiprocessing**                                      |
|-------------------------|---------------------------------------------------------|---------------------------------------------------------|
| **Utilisation des cœurs**| Utilise un seul cœur en raison du GIL.                  | Utilise plusieurs cœurs en parallèle.                    |
| **Tâches adaptées**      | Idéal pour les tâches I/O-bound (ex: lecture/écriture). | Idéal pour les tâches CPU-bound (ex: calculs lourds).    |
| **Mémoire partagée**     | Partage de la même mémoire, avec des problèmes potentiels de concurrence. | Chaque processus a son propre espace mémoire.            |
| **Facilité de gestion**  | Moins de surcharge dans le démarrage des threads.      | Peut entraîner plus de surcharge en raison de la création de processus séparés. |

#### 4. **Applications pratiques du multithreading et multiprocessing**

- **Multithreading** est utile pour les tâches telles que :
  - La gestion des requêtes réseau.
  - Les interfaces utilisateur qui doivent rester réactives pendant l'exécution d'opérations longues.
  - Le téléchargement parallèle de fichiers.
  - La lecture/écriture simultanée de fichiers sans bloquer le programme principal.

- **Multiprocessing** est utile pour les tâches suivantes :
  - L'exécution de calculs intensifs sur plusieurs cœurs.
  - Le traitement parallèle de grandes quantités de données (par exemple, analyse d'images, calculs scientifiques).
  - La mise en œuvre de systèmes distribués ou d'applications nécessitant l'exécution parallèle de nombreux processus indépendants.

#### 5. **Synchronisation entre threads et processus**

En multithreading et multiprocessing, il est souvent nécessaire de synchroniser les différentes unités d'exécution pour éviter les **conditions de course** (race conditions) et garantir une exécution correcte des tâches. Python fournit plusieurs mécanismes pour cela, notamment :

- **Verrous** (Locks) pour les threads : Pour s'assurer qu'une seule unité d'exécution accède à une ressource partagée à un moment donné.
- **Sémaphores**, **événements** et **barrières** pour gérer la synchronisation dans des scénarios plus complexes.
  
Exemple de synchronisation avec un verrou (`Lock`):

```python
import threading

lock = threading.Lock()

def fonction():
    with lock:
        # Code critique où l'accès aux ressources partagées est contrôlé
        print("Accès à une ressource partagée")

thread1 = threading.Thread(target=fonction)
thread2 = threading.Thread(target=fonction)
thread1.start()
thread2.start()
thread1.join()
thread2.join()
```

#### 6. **Résumé des concepts clés**

- **Multithreading** permet d'exécuter plusieurs tâches en parallèle dans un même processus, mais il est limité par le GIL dans les tâches CPU-bound.
- **Multiprocessing** permet de créer plusieurs processus distincts et parallèles, ce qui est mieux adapté pour les tâches CPU-bound.
- Le **module `threading`** est utilisé pour le multithreading, et le **module `multiprocessing`** est utilisé pour gérer plusieurs processus parallèles.
- La synchronisation est essentielle dans les deux cas pour garantir une exécution correcte des programmes.

### Chap 18 **Tests unitaires**

Les **tests unitaires** sont un aspect fondamental du développement logiciel moderne, permettant de vérifier qu'une unité de code (souvent une fonction ou une méthode) fonctionne comme prévu. Cela garantit que le programme fonctionne correctement et facilite la détection rapide des régressions lors des modifications ou évolutions du code. Python propose plusieurs outils pour l'écriture et l'exécution de tests unitaires, parmi lesquels les plus populaires sont `unittest` et `pytest`.

#### 1. **Introduction aux tests unitaires**

Un test unitaire est conçu pour tester une **petite unité de code** de manière isolée, afin de s'assurer qu'elle se comporte comme attendu. Typiquement, cela concerne :
- La vérification des résultats des fonctions/méthodes pour différentes entrées.
- La gestion des exceptions ou erreurs attendues.
- La validation des comportements sous des conditions spécifiques (entrées valides et invalides).

Les tests unitaires aident à :
- **Valider** le comportement du code.
- **Détecter rapidement** les erreurs.
- **Faciliter la maintenance** du code en cas de changements.

#### 2. **Framework `unittest`**

`unittest` est le framework standard de Python pour les tests unitaires. Il est inspiré de JUnit (pour Java) et fournit une structure pour organiser et exécuter les tests. Il permet également de gérer des assertions, des exceptions, et de configurer un environnement de test.

##### a. **Structure d'un test unitaire avec `unittest`**

Les tests sont organisés sous forme de classes qui héritent de `unittest.TestCase`. Chaque méthode de test doit commencer par `test_` et est exécutée de manière isolée.

```python
import unittest

# Exemple d'une fonction à tester
def addition(a, b):
    return a + b

class TestAddition(unittest.TestCase):
    def test_addition_positifs(self):
        self.assertEqual(addition(2, 3), 5)

    def test_addition_negatifs(self):
        self.assertEqual(addition(-1, -1), -2)

    def test_addition_melange(self):
        self.assertEqual(addition(-1, 1), 0)

if __name__ == '__main__':
    unittest.main()
```

##### b. **Principales méthodes d'assertion**

Les tests unitaires s'appuient sur des méthodes d'assertion pour valider les résultats des fonctions. Quelques exemples :

- `assertEqual(a, b)` : Vérifie que `a == b`.
- `assertNotEqual(a, b)` : Vérifie que `a != b`.
- `assertTrue(x)` : Vérifie que `x` est vrai.
- `assertFalse(x)` : Vérifie que `x` est faux.
- `assertIsNone(x)` : Vérifie que `x` est `None`.
- `assertRaises(exc, func, *args, **kwargs)` : Vérifie qu'une exception spécifique est levée lors de l'appel d'une fonction.

##### c. **Exécution des tests**

Les tests peuvent être exécutés depuis la ligne de commande avec la commande `python -m unittest` ou directement en exécutant le fichier contenant les tests.

```bash
python -m unittest test_module.py
```

Les résultats des tests seront affichés, avec des messages d'erreur en cas de défaillance.

#### 3. **Framework `pytest`**

`pytest` est un autre framework populaire, plus flexible et facile à utiliser que `unittest`. Il supporte des assertions plus intuitives, la gestion automatique des tests, et des rapports de test détaillés.

##### a. **Structure d'un test unitaire avec `pytest`**

Contrairement à `unittest`, il n'est pas nécessaire de créer une classe pour chaque test. Les tests sont définis sous forme de fonctions simples.

```python
# Exemple d'une fonction à tester
def addition(a, b):
    return a + b

# Test avec pytest
def test_addition_positifs():
    assert addition(2, 3) == 5

def test_addition_negatifs():
    assert addition(-1, -1) == -2

def test_addition_melange():
    assert addition(-1, 1) == 0
```

##### b. **Principales fonctionnalités de `pytest`**

- **Assertions améliorées** : `pytest` permet d'utiliser directement des expressions comme `assert a == b` sans avoir besoin de méthodes d'assertion spéciales.
- **Exécution des tests** : Les tests peuvent être exécutés avec la commande `pytest` dans le terminal. Il est également possible de filtrer les tests à exécuter par nom ou par marque.
  
```bash
pytest test_module.py
```

- **Fixtures** : `pytest` permet de gérer les configurations ou les pré-conditions avant l'exécution des tests avec les **fixtures**. Les fixtures sont des fonctions qui préparent l'état avant un test.

```python
import pytest

@pytest.fixture
def setup_data():
    return [1, 2, 3]

def test_addition_positifs(setup_data):
    assert sum(setup_data) == 6
```

##### c. **Rapports et débogage**

`pytest` fournit des rapports détaillés sur l'exécution des tests, avec des informations sur les échecs et les erreurs. Il permet également de visualiser les traces d'exception et de debugger plus facilement les tests échoués.

#### 4. **Conseils pour écrire de bons tests unitaires**

- **Testez des unités isolées** : Chaque test doit se concentrer sur une seule unité de code (fonction, méthode).
- **Nommer clairement les tests** : Les noms des tests doivent refléter ce qu'ils vérifient, par exemple : `test_addition_positifs`, `test_multiplication_zero`.
- **Couvrez les cas limites** : Testez les entrées normales, mais aussi les cas limites (valeurs nulles, vides, extrêmes, etc.).
- **Évitez les tests redondants** : Un test unitaire doit vérifier un comportement spécifique et ne pas répéter les tests d'autres fonctions.
- **Utilisez des fixtures** pour configurer l'état de l'application avant les tests et nettoyer après.

#### 5. **Exemples d'utilisation de tests unitaires**

- **Vérification des résultats d'une fonction mathématique** : Tester une fonction d'addition, de multiplication, ou des calculs complexes.
- **Gestion des exceptions** : Tester que certaines erreurs ou exceptions sont correctement levées en fonction des entrées.
- **Interaction avec une base de données** : Tester les requêtes et les connexions à une base de données (en utilisant des mocks pour éviter les dépendances réelles).

#### 6. **Mocking et tests d'interaction**

Les tests unitaires peuvent aussi impliquer la simulation de comportements externes, comme des appels à des API ou des interactions avec une base de données. **`unittest.mock`** ou **`pytest-mock`** permettent de "mocker" (simuler) ces interactions pour rendre les tests plus rapides et isolés.

```python
from unittest.mock import patch

# Exemple avec mock
def get_data_from_api():
    # Simule un appel à une API externe
    return {"data": "some data"}

@patch('module.get_data_from_api')
def test_api_call(mock_get_data):
    mock_get_data.return_value = {"data": "mocked data"}
    assert get_data_from_api() == {"data": "mocked data"}
```

#### 7. **Résumé**

- **Tests unitaires** : Méthode pour tester des petites unités de code (fonction/méthode) de manière isolée.
- **`unittest` et `pytest`** : Frameworks principaux pour écrire et exécuter des tests unitaires en Python. `unittest` fait partie de la bibliothèque standard, tandis que `pytest` est un outil plus flexible et puissant, souvent préféré dans la communauté.
- **Assertions** : Les tests valident les comportements attendus du code en utilisant des assertions pour comparer les résultats obtenus et attendus.
- **Fixtures et mocks** : Utilisés pour préparer les environnements de test et simuler des comportements externes.

Les tests unitaires jouent un rôle crucial dans la qualité et la stabilité du code, en permettant de détecter des bugs tôt dans le processus de développement.

### Chap 19 **Fonctions récursives**

Les **fonctions récursives** sont des fonctions qui s’appellent elles-mêmes afin de résoudre un problème. Elles sont particulièrement efficaces pour résoudre des problèmes qui peuvent être divisés en sous-problèmes similaires ou qui présentent une structure de type « diviser pour régner ».

#### 1. **Principe de la récursion**

Une fonction est dite **récursive** lorsque, dans son corps, elle effectue un appel à elle-même. Cependant, pour éviter une récursion infinie, il est nécessaire de définir une **condition d'arrêt**. Sans cette condition, la fonction continuerait à s'appeler indéfiniment, entraînant un dépassement de la pile d'appels (stack overflow).

La **récursion** suit généralement deux étapes :
1. **Cas de base** : La condition qui permet de terminer la récursion. Cela correspond à la situation la plus simple, où la fonction peut renvoyer une valeur directement sans effectuer d'appel récursif.
2. **Appel récursif** : La fonction s'appelle elle-même sur un sous-ensemble plus petit ou plus simple du problème initial.

#### 2. **Structure d'une fonction récursive**

Une fonction récursive se compose généralement de :
- Un cas de base : le critère qui arrête l’appel récursif.
- Un appel récursif : la fonction appelle elle-même avec des arguments modifiés, généralement réduits à chaque itération.

```python
def factorielle(n):
    # Cas de base
    if n == 0:
        return 1
    # Appel récursif
    else:
        return n * factorielle(n - 1)
```

Dans cet exemple, la fonction `factorielle` calcule la factorielle de `n` en multipliant `n` par la factorielle de `n - 1`. La condition de base est `n == 0`, où la fonction retourne simplement `1`, car la factorielle de `0` est définie comme étant `1`.

#### 3. **Exemples classiques de fonctions récursives**

Voici quelques exemples classiques où la récursion est souvent utilisée :

##### a. **Calcul de la factorielle**

La **factorielle** d’un nombre `n`, notée `n!`, est le produit de tous les entiers de `1` à `n`. Elle peut être définie récursivement comme suit :
- Cas de base : `0! = 1`
- Cas général : `n! = n * (n-1)!`

```python
def factorielle(n):
    if n == 0:
        return 1
    return n * factorielle(n - 1)
```

##### b. **Calcul de la suite de Fibonacci**

La suite de **Fibonacci** est définie par la relation :
- Cas de base : `F(0) = 0`, `F(1) = 1`
- Cas général : `F(n) = F(n-1) + F(n-2)`

```python
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)
```

##### c. **Recherche dans une structure arborescente (ex. arbre binaire)**

Dans un arbre binaire, chaque nœud a deux sous-arbres. Pour effectuer une recherche ou traverser un arbre binaire, la récursion est souvent utilisée, en parcourant l'arbre depuis la racine jusqu'aux feuilles.

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def rechercher(nœud, valeur):
    if nœud is None:
        return False
    if nœud.value == valeur:
        return True
    # Recherche récursive dans les sous-arbres
    return rechercher(nœud.left, valeur) or rechercher(nœud.right, valeur)
```

#### 4. **Avantages de la récursion**

La récursion peut être un outil puissant dans plusieurs contextes :
- **Simplicité** : Certains problèmes sont naturellement récursifs, comme les calculs de factorielle, les suites de Fibonacci, ou les problèmes de recherche dans des structures arborescentes. La récursion permet de représenter ces problèmes de manière concise et élégante.
- **Diviser pour régner** : De nombreux algorithmes récursifs reposent sur le principe de diviser un problème en sous-problèmes similaires, chacun étant résolu indépendamment avant de recombiner les résultats.

#### 5. **Inconvénients et précautions**

Bien que la récursion soit élégante et parfois nécessaire, elle comporte certains inconvénients :
- **Problèmes de performance** : Dans certains cas, la récursion peut être moins performante que des boucles itératives en raison du **coût des appels de fonction**. De plus, chaque appel récursif consomme de la mémoire (empilement des appels), ce qui peut mener à une **dépassement de pile** si la profondeur de récursion est trop élevée.
- **Risque de dépassement de pile (stack overflow)** : Si la condition d'arrêt n'est pas correctement définie ou si les appels récursifs sont trop nombreux, la pile d'exécution peut se remplir et provoquer un dépassement de mémoire. C'est ce qu'on appelle un **stack overflow**.

#### 6. **Optimisation de la récursion**

Il existe des techniques permettant d’optimiser la récursion et d’éviter certains problèmes de performance :
- **Récursion terminale** : Il s'agit d'une optimisation où l'appel récursif est la dernière instruction exécutée dans la fonction. Cela permet à certains langages de programmation (comme le Python optimisé) d’éviter de conserver les appels précédents dans la pile d’exécution.
- **Mémorisation (Memoization)** : Cette technique consiste à enregistrer les résultats des appels récursifs déjà effectués pour éviter de recalculer la même chose plusieurs fois. Python offre le module `functools.lru_cache` pour la mémorisation automatique.

```python
from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)
```

#### 7. **Résumé**

- **Récursion** : Une fonction récursive s'appelle elle-même pour résoudre un problème.
- **Cas de base et appel récursif** : La récursion nécessite un cas de base pour éviter une boucle infinie et des appels récursifs qui réduisent progressivement la complexité du problème.
- **Applications** : La récursion est utilisée dans des algorithmes comme le calcul de la factorielle, la suite de Fibonacci, les recherches dans des structures arborescentes, etc.
- **Optimisation** : Des techniques comme la récursion terminale et la mémorisation peuvent être utilisées pour améliorer l’efficacité des fonctions récursives.

En résumé, les fonctions récursives sont un outil puissant pour résoudre des problèmes complexes de manière élégante, mais il est crucial de s'assurer que les conditions d'arrêt sont bien définies pour éviter les dépassements de pile et d'autres problèmes de performance.

### Chap 20 **Gestion des dépendances (pip, virtualenv)**

La gestion des dépendances est une partie essentielle du développement en Python, surtout lorsqu'on travaille avec des bibliothèques externes ou lorsque le projet a des besoins spécifiques en termes de versions de ces bibliothèques. Cela garantit que toutes les parties de votre projet fonctionnent correctement ensemble, sans conflit ni incompatibilité.

Voici les concepts clés et outils liés à la gestion des dépendances en Python :

#### 1. **`pip` (Python Package Installer)**

`pip` est l'outil de gestion de paquets par défaut en Python. Il permet d'installer, de désinstaller, de mettre à jour et de gérer les bibliothèques tierces utilisées dans un projet. `pip` se connecte au **Python Package Index (PyPI)**, qui est le dépôt principal de paquets Python.

##### a. **Installation d'un paquet**

Pour installer une bibliothèque avec `pip`, on utilise la commande suivante dans le terminal ou la ligne de commande :
```bash
pip install nom_du_paquet
```
Par exemple, pour installer **requests** (une bibliothèque pour effectuer des requêtes HTTP) :
```bash
pip install requests
```

##### b. **Installation avec une version spécifique**

Il est possible d’installer une version précise d’un paquet :
```bash
pip install requests==2.25.1
```

##### c. **Mise à jour d’un paquet**

Pour mettre à jour un paquet à sa dernière version disponible :
```bash
pip install --upgrade requests
```

##### d. **Désinstallation d’un paquet**

Pour désinstaller un paquet de votre environnement :
```bash
pip uninstall requests
```

##### e. **Lister les paquets installés**

Vous pouvez obtenir la liste de tous les paquets installés dans votre environnement avec la commande :
```bash
pip list
```

##### f. **Exporter les dépendances**

Si vous souhaitez créer un fichier de **dépendances** pour un projet, vous pouvez utiliser `pip freeze` pour générer un fichier `requirements.txt` :
```bash
pip freeze > requirements.txt
```
Ce fichier contient toutes les dépendances du projet avec leurs versions exactes.

##### g. **Installation depuis un fichier requirements.txt**

Pour installer toutes les dépendances listées dans un fichier `requirements.txt`, utilisez :
```bash
pip install -r requirements.txt
```
Cela permet de garantir que tous les membres d’un projet ou de l’équipe utilisent les mêmes versions des bibliothèques.

#### 2. **Environnements virtuels (`virtualenv`, `venv`)**

Un **environnement virtuel** est un espace isolé dans lequel vous pouvez installer des dépendances spécifiques à un projet sans interférer avec le reste de votre système. Cela permet d'éviter les conflits entre les versions de bibliothèques utilisées par différents projets.

##### a. **Création d’un environnement virtuel**

Python propose deux outils pour créer des environnements virtuels :
- `virtualenv` (ancien outil)
- `venv` (module intégré dans Python à partir de la version 3.3)

###### Avec `venv` (préféré pour les versions récentes de Python) :
```bash
python3 -m venv nom_de_l_environnement
```

Cela crée un répertoire `nom_de_l_environnement` qui contient un environnement isolé avec une copie propre de Python.

##### b. **Activation de l'environnement virtuel**

Pour activer l'environnement virtuel, suivez les instructions en fonction de votre système d’exploitation :

- **Windows** :
```bash
nom_de_l_environnement\Scripts\activate
```
- **MacOS/Linux** :
```bash
source nom_de_l_environnement/bin/activate
```

Une fois activé, votre terminal devrait afficher le nom de l'environnement, ce qui indique que vous êtes dans cet environnement virtuel.

##### c. **Installation des dépendances dans l’environnement virtuel**

Une fois l’environnement virtuel activé, toutes les bibliothèques installées avec `pip` seront installées uniquement dans cet environnement, sans affecter le reste du système. Par exemple :
```bash
pip install requests
```

##### d. **Désactivation de l’environnement virtuel**

Lorsque vous avez fini de travailler dans l'environnement virtuel, vous pouvez le désactiver en utilisant la commande :
```bash
deactivate
```

Cela vous ramène à l’environnement Python global.

#### 3. **Utilisation d’un fichier `requirements.txt` dans un environnement virtuel**

Il est courant d’utiliser un fichier `requirements.txt` pour gérer les dépendances de votre projet et garantir la cohérence des environnements entre les membres d’une équipe. Voici comment l’utiliser avec un environnement virtuel :

1. **Créer un environnement virtuel** :
```bash
python3 -m venv venv
```

2. **Activer l’environnement virtuel** :
```bash
source venv/bin/activate   # sur MacOS/Linux
venv\Scripts\activate      # sur Windows
```

3. **Installer les dépendances à partir de `requirements.txt`** :
```bash
pip install -r requirements.txt
```

Cela garantit que toutes les bibliothèques nécessaires au projet sont installées dans l’environnement virtuel.

#### 4. **Gestion des dépendances dans un environnement de développement**

L'utilisation des environnements virtuels permet de gérer plusieurs projets Python sur une même machine, sans que les bibliothèques et les versions de Python n'entrent en conflit. De plus, chaque environnement virtuel peut avoir ses propres dépendances, ce qui permet une isolation parfaite des projets.

##### a. **Exemple de fichier `requirements.txt`**
Voici un exemple de contenu d’un fichier `requirements.txt` :
```
requests==2.25.1
numpy==1.19.5
flask==2.0.1
```

##### b. **Mise à jour des dépendances**

Lorsque vous ajoutez ou mettez à jour des dépendances dans votre environnement virtuel, n’oubliez pas de mettre à jour le fichier `requirements.txt` pour refléter les nouvelles versions des paquets installés :
```bash
pip freeze > requirements.txt
```

#### 5. **Avantages de la gestion des dépendances**

- **Isolément des dépendances** : Chaque projet peut avoir ses propres bibliothèques et versions, ce qui permet d’éviter les conflits.
- **Portabilité** : Vous pouvez facilement partager votre projet avec d’autres développeurs ou déployer sur des serveurs sans craindre des problèmes de dépendances.
- **Facilité de gestion** : Vous pouvez facilement gérer les versions des paquets et installer un ensemble complet de dépendances avec une simple commande `pip install -r requirements.txt`.

#### 6. **Résumé**

- **`pip`** est l'outil principal pour installer et gérer des bibliothèques Python depuis le PyPI.
- **`virtualenv` et `venv`** sont des outils pour créer des environnements virtuels afin d’isoler les dépendances de chaque projet Python.
- Un fichier **`requirements.txt`** permet de spécifier les bibliothèques et leurs versions, et il est utilisé pour installer toutes les dépendances nécessaires avec `pip install -r requirements.txt`.
- Ces outils permettent de travailler sur plusieurs projets Python en parallèle sans conflit et assurent une gestion cohérente des dépendances à travers différentes plateformes et environnements.

Ainsi, la gestion des dépendances est essentielle pour le développement de projets Python bien structurés et faciles à maintenir.

### Chap 21 **Mécanismes de concurrence (asyncio)**

Le module `asyncio` de Python permet de créer des programmes asynchrones. Il est principalement utilisé pour gérer la concurrence sans avoir besoin de gérer directement des threads ou des processus. En utilisant des mécanismes non bloquants, `asyncio` permet d'exécuter plusieurs tâches en parallèle dans une seule boucle d'événements, rendant le programme plus efficace, surtout lorsqu'il y a des opérations d'attente longues (comme les requêtes réseau, les lectures de fichiers, etc.).

#### 1. **Introduction à `asyncio`**

`asyncio` repose sur la programmation asynchrone avec des **coroutines**, des fonctions spéciales qui peuvent être suspendues et reprises à des points spécifiques dans le temps. Cette approche permet d'exécuter d'autres tâches pendant que l'une d'elles attend une ressource (par exemple, une réponse réseau).

Les coroutines sont créées avec le mot-clé `async def` et peuvent être "attendues" avec `await`.

#### 2. **Composants principaux de `asyncio`**

1. **Coroutines**
   - Ce sont des fonctions spéciales qui utilisent les mots-clés `async` et `await`.
   - `async def` est utilisé pour définir une fonction asynchrone (coroutine).
   - `await` est utilisé pour appeler une autre coroutine et attendre qu'elle soit terminée sans bloquer l'exécution du programme.

2. **Boucle d'événements (`event loop`)**
   - La boucle d'événements est au cœur d'un programme asynchrone. Elle est responsable de la gestion et de l'exécution des tâches asynchrones.
   - La boucle d'événements s'exécute de manière continue et, chaque fois qu'une tâche asynchrone se termine, elle en démarre une autre.

3. **Tâches (`tasks`)**
   - Une tâche est une coroutine qui a été programmée pour être exécutée dans la boucle d'événements.
   - Les tâches sont créées via `asyncio.create_task()`, et une fois créées, elles sont automatiquement gérées par la boucle d'événements.

4. **Futures**
   - Les futures représentent des résultats qui ne sont pas encore disponibles. Lorsqu'une coroutine effectue une opération asynchrone, elle peut retourner un `Future`, que vous pouvez "attendre" pour obtenir le résultat final.

5. **`asyncio.run()`**
   - Utilisé pour démarrer un programme asynchrone, en exécutant la boucle d'événements principale jusqu'à ce que tout le travail soit terminé.

#### 3. **Création d'un programme asynchrone avec `asyncio`**

Voici les étapes fondamentales pour créer un programme asynchrone :

1. **Définir des coroutines avec `async def`** :
   Une coroutine est une fonction qui peut être mise en pause et reprise à des moments donnés.

2. **Utiliser `await` pour appeler d'autres coroutines** :
   Vous utilisez `await` pour attendre que d'autres coroutines ou futures terminent sans bloquer l'exécution de votre programme.

3. **Exécuter la boucle d'événements avec `asyncio.run()`** :
   Cela permet de démarrer la boucle d'événements, d'exécuter les coroutines et d'attendre que tout le travail soit terminé.

#### 4. **Exemple détaillé de programme asynchrone avec `asyncio`**

Supposons que nous avons une fonction qui simule une requête réseau (une opération asynchrone) :

```python
import asyncio

async def fetch_data():
    print("Début de la récupération des données")
    await asyncio.sleep(2)  # Simule une attente de 2 secondes (par exemple, une requête réseau)
    print("Données récupérées")

async def main():
    # Lance deux coroutines en parallèle
    task1 = asyncio.create_task(fetch_data())
    task2 = asyncio.create_task(fetch_data())

    # Attend que les deux tâches soient terminées
    await task1
    await task2

# Démarre la boucle d'événements et exécute 'main'
asyncio.run(main())
```

#### **Explication de l'exemple** :
1. **`async def fetch_data()`** : Cette fonction est une coroutine qui simule une tâche longue (attente de 2 secondes). Pendant ce temps, la boucle d'événements peut exécuter d'autres tâches.
   
2. **`await asyncio.sleep(2)`** : Cette ligne de code suspend l'exécution de la coroutine `fetch_data()` pendant 2 secondes, sans bloquer l'exécution d'autres tâches dans la boucle d'événements.

3. **`asyncio.create_task()`** : Cette fonction permet de créer une tâche à partir de la coroutine `fetch_data()`. Cela signifie que la coroutine sera exécutée en parallèle avec d'autres tâches.

4. **`await task1` et `await task2`** : Ces lignes attendent que les deux tâches soient terminées avant de continuer.

5. **`asyncio.run(main())`** : C'est le point d'entrée du programme asynchrone. Il démarre la boucle d'événements et exécute la coroutine `main()`.

#### 5. **Gérer plusieurs tâches concurrentes**

Lorsque vous avez plusieurs tâches à exécuter en parallèle, `asyncio` vous permet de gérer efficacement leur exécution. Par exemple, en utilisant `asyncio.gather()`, vous pouvez attendre l'achèvement de plusieurs coroutines en parallèle :

```python
import asyncio

async def task1():
    print("Tâche 1 en cours")
    await asyncio.sleep(1)
    print("Tâche 1 terminée")

async def task2():
    print("Tâche 2 en cours")
    await asyncio.sleep(2)
    print("Tâche 2 terminée")

async def main():
    # Exécute les deux tâches en parallèle et attend leur achèvement
    await asyncio.gather(task1(), task2())

asyncio.run(main())
```

Dans cet exemple, `task1()` et `task2()` sont exécutées en parallèle, et le programme attend leur terminaison avec `asyncio.gather()`.

#### 6. **Gestion des exceptions dans les coroutines**

Comme dans un programme synchrone, vous pouvez gérer les exceptions dans les coroutines en utilisant `try` / `except` :

```python
import asyncio

async def fetch_data():
    try:
        print("Début de la récupération des données")
        await asyncio.sleep(2)
        raise ValueError("Erreur pendant la récupération des données")  # Simuler une erreur
    except ValueError as e:
        print(f"Exception capturée : {e}")

asyncio.run(fetch_data())
```

Dans ce cas, une exception est levée et capturée dans la coroutine, et l'exécution ne bloque pas le programme.

#### 7. **Avantages de `asyncio`**

- **Efficacité en termes de ressources** : Aucun thread supplémentaire n'est nécessaire, ce qui réduit l'overhead lié à la gestion des threads.
- **Non-bloquant** : Permet de gérer plusieurs opérations I/O (comme des requêtes HTTP, des lectures de fichiers) de manière efficace sans bloquer l'exécution du programme.
- **Exécution parallèle** : `asyncio` permet d'exécuter plusieurs tâches simultanément dans une seule boucle d'événements, ce qui est particulièrement utile pour des programmes qui doivent effectuer de nombreuses opérations d'attente.

#### 8. **Limitations et considérations**

- `asyncio` est particulièrement adapté pour les applications I/O-bound (attente de données) mais moins pour les applications CPU-bound (intensives en calculs), où le multithreading ou le multiprocessing peut être plus efficace.
- Certaines bibliothèques existantes ne supportent pas encore nativement les appels asynchrones. Dans ce cas, l'utilisation de threads ou de processus parallèles pourrait être nécessaire.

### **Résumé**
- **`asyncio`** permet de créer des programmes asynchrones en Python, en exécutant plusieurs tâches simultanément sans bloquer l'exécution du programme principal.
- Il repose sur l'utilisation de **coroutines**, qui sont des fonctions spéciales pouvant être suspendues et reprises.
- Les programmes asynchrones sont gérés par une **boucle d'événements**, et les tâches sont créées avec **`asyncio.create_task()`**.
- **`asyncio.run()`** est utilisé pour démarrer et exécuter une boucle d'événements.

### Chap 22 **Gestion des versions avec Git**

Git est un système de contrôle de version décentralisé qui permet de suivre l'historique des modifications d'un projet, de gérer des branches et de collaborer avec d'autres développeurs de manière fluide. Il est utilisé pour enregistrer les changements dans les fichiers du projet, et pour permettre à plusieurs personnes de travailler sur un même code sans écraser le travail des autres.

#### 1. **Installation et configuration de Git**

Avant de commencer à utiliser Git, vous devez l'installer sur votre machine. Voici les étapes principales :

1. **Installer Git** :
   - Pour **Windows** : Téléchargez l'installateur depuis [git-scm.com](https://git-scm.com/) et suivez les instructions.
   - Pour **macOS** : Utilisez Homebrew avec la commande `brew install git`, ou téléchargez l'installateur depuis [git-scm.com](https://git-scm.com/).
   - Pour **Linux** : Utilisez le gestionnaire de paquets (par exemple `sudo apt install git` pour Ubuntu).

2. **Configurer Git** : Après l'installation, vous devez configurer Git avec votre nom et votre email pour qu'il puisse suivre les modifications effectuées par vous.
   ```bash
   git config --global user.name "Votre Nom"
   git config --global user.email "votre.email@example.com"
   ```

#### 2. **Initialisation d'un repository Git**

Un repository Git est un dossier où Git va suivre l'historique des fichiers du projet. Vous pouvez initialiser un nouveau repository dans un dossier avec la commande :

```bash
git init
```

Cela crée un dossier `.git` dans votre projet, où Git enregistre l'historique des fichiers.

#### 3. **Commandes de base de Git**

Voici les commandes Git les plus courantes et utiles :

1. **`git status`** : Affiche l'état actuel du repository, c'est-à-dire les fichiers modifiés, ajoutés ou non suivis.
   ```bash
   git status
   ```

2. **`git add`** : Ajoute des fichiers au stage (zone de préparation) avant de les valider dans l'historique.
   ```bash
   git add <fichier>  # Pour ajouter un fichier spécifique
   git add .          # Pour ajouter tous les fichiers modifiés
   ```

3. **`git commit`** : Valide les modifications ajoutées au stage, en incluant un message décrivant les changements.
   ```bash
   git commit -m "Message décrivant les modifications"
   ```

4. **`git log`** : Affiche l'historique des commits du repository.
   ```bash
   git log
   ```

5. **`git diff`** : Affiche les différences entre les fichiers modifiés et les versions précédentes.
   ```bash
   git diff
   ```

6. **`git push`** : Envoie les commits locaux vers un repository distant (par exemple, GitHub).
   ```bash
   git push origin master  # Envoie sur la branche 'master'
   ```

7. **`git pull`** : Récupère et intègre les modifications d'un repository distant dans votre repository local.
   ```bash
   git pull origin master  # Récupère les dernières modifications de la branche 'master'
   ```

#### 4. **Gestion des branches**

Les branches sont des copies indépendantes du code, qui permettent de travailler sur des fonctionnalités ou des corrections sans affecter le code principal (généralement la branche `master` ou `main`). Git facilite la gestion des branches avec les commandes suivantes :

1. **Créer une nouvelle branche** :
   ```bash
   git branch <nom_de_branche>
   ```

2. **Basculer vers une autre branche** :
   ```bash
   git checkout <nom_de_branche>
   ```

3. **Créer et basculer vers une branche en une seule commande** :
   ```bash
   git checkout -b <nom_de_branche>
   ```

4. **Fusionner une branche dans la branche actuelle** :
   Une fois que vous avez terminé les changements dans une branche et que vous souhaitez les intégrer dans la branche principale (par exemple `master`), vous utilisez `git merge`.
   ```bash
   git checkout master  # Basculez sur la branche master
   git merge <nom_de_branche>  # Fusionne la branche dans master
   ```

5. **Supprimer une branche** :
   Une fois une branche fusionnée ou inutilisée, vous pouvez la supprimer.
   ```bash
   git branch -d <nom_de_branche>
   ```

6. **Voir les branches disponibles** :
   ```bash
   git branch  # Liste les branches locales
   git branch -r  # Liste les branches distantes
   ```

#### 5. **Collaboration avec des repositories distants (GitHub, GitLab, etc.)**

Git permet de collaborer sur des projets en utilisant des repositories distants. Voici comment utiliser un repository distant avec Git :

1. **Ajouter un remote (repository distant)** :
   Vous devez d'abord lier votre repository local à un repository distant (par exemple, sur GitHub ou GitLab).
   ```bash
   git remote add origin https://github.com/votre_utilisateur/nom_du_repository.git
   ```

2. **Pousser les changements vers le repository distant** :
   Après avoir effectué un commit, vous pouvez envoyer vos modifications vers le repository distant.
   ```bash
   git push -u origin master
   ```

3. **Cloner un repository distant** :
   Pour travailler sur un projet existant, vous pouvez cloner un repository distant sur votre machine locale.
   ```bash
   git clone https://github.com/votre_utilisateur/nom_du_repository.git
   ```

#### 6. **Résolution des conflits**

Les conflits se produisent lorsqu'il y a des changements contradictoires dans deux branches différentes qui sont fusionnées. Pour résoudre un conflit :

1. **Fusionner deux branches** avec `git merge`.
2. Si un conflit survient, Git marquera les fichiers en conflit. Vous devez alors ouvrir ces fichiers et résoudre manuellement les conflits.
3. Après avoir résolu le conflit, vous devez ajouter à nouveau les fichiers et valider la fusion.
   ```bash
   git add <fichier_conflit>
   git commit
   ```

#### 7. **Tags et versions**

Les tags sont utilisés pour marquer des points spécifiques dans l'historique, souvent pour identifier des versions de code.

1. **Créer un tag** :
   ```bash
   git tag -a v1.0 -m "Version 1.0"
   ```

2. **Lister les tags** :
   ```bash
   git tag
   ```

3. **Pousser un tag vers un repository distant** :
   ```bash
   git push origin v1.0
   ```

#### 8. **Bonnes pratiques avec Git**

- **Commits fréquents et descriptifs** : Faites des commits fréquents pour que l'historique soit facile à comprendre. Chaque commit doit être accompagné d'un message clair et descriptif.
- **Travailler avec des branches** : Utilisez des branches pour travailler sur des fonctionnalités ou corrections spécifiques, puis fusionnez-les une fois qu'elles sont prêtes.
- **Collaborer efficacement** : Avant de pousser vos changements, faites un `git pull` pour vous assurer que vous avez la dernière version du projet. Résolvez les conflits avant de pousser.

### **Résumé**

- **Git** permet de suivre l’historique du code, de collaborer avec d’autres développeurs et de gérer des versions de manière décentralisée.
- Il permet de gérer des **branches**, ce qui facilite l'ajout de nouvelles fonctionnalités sans affecter la version principale du code.
- **GitHub** et d'autres services permettent de collaborer à distance en hébergeant des repositories Git et en facilitant le partage de code.
- Git gère efficacement l'historique du projet, permet de revenir en arrière en cas d'erreurs et favorise un travail collaboratif via des outils comme les **pull requests** et les **merge requests**.

En utilisant **Git** de manière optimale, vous pouvez rendre votre processus de développement plus organisé, cohérent et efficace.

### Chap 23 **Optimisation et Compilateurs JIT**

L'optimisation du code est essentielle pour améliorer ses performances, en particulier pour les applications exigeantes en calcul. Python, grâce à ses bibliothèques et outils, offre plusieurs moyens d'analyser et d'accélérer le code. Une des solutions avancées inclut les **compilateurs JIT (Just-In-Time)**, comme **Numba**.

---

#### **1. Profilage de code**

Le profilage permet d'identifier les sections du code qui consomment le plus de temps ou de mémoire. Cela permet de cibler les optimisations.

**a. Utilisation de `timeit`**  

Mesure précise du temps d'exécution d'un morceau de code.
  
```python
import timeit

# Exemple simple
code_to_test = """
result = sum([i for i in range(1000)])
"""
execution_time = timeit.timeit(code_to_test, number=1000)
print(f"Temps d'exécution : {execution_time} secondes")
```

**b. Utilisation de `cProfile`**  

Analyse des performances d'un programme en entier.  
```python
import cProfile

def test_function():
    result = sum([i for i in range(100000)])
    return result

cProfile.run('test_function()')
```

**c. Utilisation de `memory_profiler`**  

Surveillance de l'utilisation de la mémoire (nécessite une installation préalable).  

```bash
pip install memory_profiler
```
Exemple :  
```python
from memory_profiler import profile

@profile
def test_memory():
    data = [i for i in range(1000000)]
    del data

test_memory()
```

---

#### **2. Introduction au compilateur JIT : Numba**

**Numba** est une bibliothèque qui compile du code Python en code machine au moment de l'exécution (**Just-In-Time**), utilisant LLVM pour une accélération des calculs. Il est particulièrement efficace pour les boucles lourdes et les calculs mathématiques.

**Installation** :  
```bash
pip install numba
```

**a. Exemple de base avec Numba**  

Appliquez le décorateur `@jit` pour accélérer une fonction.  

```python
from numba import jit
import numpy as np

@jit
def sum_array(arr):
    result = 0
    for i in arr:
        result += i
    return result

array = np.arange(1_000_000)
print(sum_array(array))  # Exécution rapide grâce à la compilation JIT
```

**b. Mode nopython pour optimiser davantage** 
 
Le mode `nopython=True` force Numba à tout compiler en code machine, excluant l'interprétation Python.  

```python
@jit(nopython=True)
def sum_array_optimized(arr):
    result = 0
    for i in arr:
        result += i
    return result
```

**c. Accélération des boucles imbriquées**  

Les boucles complexes peuvent bénéficier d'améliorations significatives avec Numba.  

```python
@jit(nopython=True)
def matrix_multiplication(A, B):
    rows, cols = A.shape[0], B.shape[1]
    result = np.zeros((rows, cols))
    for i in range(rows):
        for j in range(cols):
            for k in range(A.shape[1]):
                result[i, j] += A[i, k] * B[k, j]
    return result

A = np.random.rand(100, 100)
B = np.random.rand(100, 100)
print(matrix_multiplication(A, B))
```

**d. Comparaison avec Python pur**  
Comparez les performances avant et après l'utilisation de Numba pour visualiser l'amélioration.

---

#### **3. Techniques supplémentaires pour l'optimisation**

- **Vectorisation avec NumPy** : Préférez les opérations vectorisées aux boucles explicites.  

  ```python
  import numpy as np

  # Calcul vectorisé
  array = np.arange(1_000_000)
  result = np.sum(array)  # Plus rapide qu'une boucle Python
  ```

- **Multithreading et multiprocessing** : Combinez Numba avec des techniques de parallélisation pour maximiser les performances.

- **Caching avec Numba** : Conservez les compilations pour éviter de les recalculer à chaque exécution.  

  ```python
  @jit(nopython=True, cache=True)
  def cached_function(arr):
      return np.sum(arr)
  ```

---

### **Résumé**

- **Profilage** : Utilisez `timeit`, `cProfile`, et `memory_profiler` pour identifier les goulots d'étranglement en termes de temps et de mémoire.
- **Numba** : Simplifiez l'accélération des calculs intensifs avec un compilateur JIT. Ses points forts sont les calculs numériques et les boucles.
- **Optimisation combinée** : Combinez Numba avec NumPy et d'autres outils pour maximiser les performances.
  
En exploitant ces techniques, vous pouvez considérablement accélérer vos programmes Python tout en gardant un code lisible et efficace.

### Chap 24 **Interopérabilité et Extensions : Connecter Python avec C/C++**

Python, bien que puissant, peut parfois manquer de performances pour des tâches nécessitant des calculs intensifs. Dans de tels cas, il est possible d'exploiter des bibliothèques écrites en C ou C++ pour améliorer les performances tout en utilisant Python comme interface. **SWIG** et **PyBind11** sont deux outils populaires pour créer cette interopérabilité.

---

### **1. SWIG : Simplified Wrapper and Interface Generator**

SWIG est un outil qui permet de générer automatiquement du code de liaison entre des bibliothèques écrites en C/C++ et des langages comme Python. Il est utilisé pour exposer des bibliothèques complexes de manière simple.

#### **a. Installation de SWIG**

Assurez-vous d'avoir SWIG installé sur votre système.

```bash
sudo apt-get install swig    # Sous Linux
brew install swig            # Sous macOS
choco install swig           # Sous Windows
```

#### **b. Structure de base d'un projet SWIG**
Un projet SWIG typique comprend :
- Un fichier C ou C++ contenant la logique principale.
- Un fichier d'interface `.i` utilisé par SWIG pour générer les liaisons.

#### **c. Exemple simple : Fonction C**

**Fichier `example.c` :**

```c
#include <math.h>

double square(double x) {
    return x * x;
}
```

**Fichier d'interface SWIG `example.i` :**

```swig
%module example

%{
#include "example.c"
%}

double square(double x);
```

**Commande pour générer les liaisons :**
```bash
swig -python -o example_wrap.c example.i
gcc -shared -o _example.so -fPIC example.c example_wrap.c -I/usr/include/python3.8
```

Le fichier `_example.so` généré peut être importé directement dans Python :

```python
import example
print(example.square(4))  # Affiche 16.0
```

#### **d. Avantages de SWIG**
- Prend en charge plusieurs langages (Python, Java, etc.).
- Facile à configurer pour des fonctions simples.

#### **e. Limites de SWIG**
- Peut devenir complexe à gérer pour des projets très grands ou avancés.
- Nécessite parfois des ajustements manuels dans le fichier d'interface.

---

### **2. PyBind11 : Interface moderne pour Python et C++**

**PyBind11** est une bibliothèque moderne pour lier C++ à Python. Elle est particulièrement utile pour exposer des classes et des fonctions C++ en Python avec un minimum de surcharge.

#### **a. Installation de PyBind11**

Installez PyBind11 avec pip ou à partir des sources :

```bash
pip install pybind11
```

#### **b. Structure d'un projet PyBind11**
Un projet PyBind11 typique inclut :
- Du code C++ avec la logique principale.
- Un fichier d'extension écrit avec PyBind11.

#### **c. Exemple simple : Fonction C++**

**Fichier `example.cpp` :**

```cpp
#include <pybind11/pybind11.h>

double square(double x) {
    return x * x;
}

PYBIND11_MODULE(example, m) {
    m.doc() = "Module PyBind11 d'exemple";
    m.def("square", &square, "Calcule le carré d'un nombre");
}
```

**Compilation avec PyBind11 :**

Utilisez la commande suivante pour compiler avec le compilateur GCC :

```bash
c++ -O3 -Wall -shared -std=c++11 -fPIC $(python3 -m pybind11 --includes) example.cpp -o example$(python3-config --extension-suffix)
```

**Utilisation en Python :**

```python
import example
print(example.square(4))  # Affiche 16.0
```

#### **d. Exposition des classes**

PyBind11 permet également de lier des classes C++ :

```cpp
#include <pybind11/pybind11.h>

class Point {
public:
    Point(double x, double y) : x(x), y(y) {}
    double distance_to_origin() const {
        return sqrt(x * x + y * y);
    }

private:
    double x, y;
};

PYBIND11_MODULE(example, m) {
    pybind11::class_<Point>(m, "Point")
        .def(pybind11::init<double, double>())
        .def("distance_to_origin", &Point::distance_to_origin);
}
```

En Python :

```python
import example
p = example.Point(3, 4)
print(p.distance_to_origin())  # Affiche 5.0
```

#### **e. Avantages de PyBind11**
- Interface moderne et intuitive pour C++11 et versions ultérieures.
- Gestion naturelle des exceptions et des types Python/C++.
- Support natif des fonctionnalités avancées comme les surcharges et les classes.

#### **f. Limites de PyBind11**
- Ne prend en charge que Python (contrairement à SWIG).
- Moins adapté pour les très grandes bibliothèques sans refactoring.

---

### **3. Comparaison SWIG vs PyBind11**

| Critère                 | SWIG                         | PyBind11                   |
|-------------------------|------------------------------|----------------------------|
| **Facilité d'utilisation** | Moyen                      | Très élevé                 |
| **Langages pris en charge** | Python, Java, Ruby, etc.   | Python uniquement          |
| **Documentation moderne**   | Moyenne                   | Excellente                 |
| **Adaptation aux grands projets** | Adapté pour de gros projets | Idéal pour des modules spécifiques |
| **Performance**         | Bonne                       | Très bonne (C++ moderne)   |

---

### **Résumé**

1. **SWIG** est un outil polyvalent pour connecter Python à C/C++ et d'autres langages. Idéal pour les projets interlangages complexes.
2. **PyBind11** offre une solution moderne et intuitive pour intégrer des bibliothèques C++ dans Python, particulièrement adaptée pour les projets C++ récents et les besoins spécifiques.  
3. Combinez ces outils avec des tests et des optimisations pour tirer le meilleur parti des performances de C/C++ tout en exploitant la simplicité de Python.

### Chap 25 **Programmation à Grande Échelle : Gestion des Workflows et Calcul Distribué**

La programmation à grande échelle se concentre sur l'optimisation des workflows complexes et sur la gestion efficace des ressources pour traiter des quantités massives de données ou exécuter des tâches asynchrones en parallèle. **Celery** et **Dask** sont deux outils puissants pour répondre à ces besoins.

---

### **1. Gestion de Workflows Asynchrones avec Celery**

Celery est une bibliothèque Python de gestion de tâches distribuées, souvent utilisée pour exécuter des tâches asynchrones dans des systèmes distribués, comme l'envoi d'e-mails, le traitement de fichiers ou les calculs de fond.

#### **a. Installation de Celery**

Installez Celery avec un backend comme Redis ou RabbitMQ pour la gestion des files d'attente :
```bash
pip install celery[redis]
```

#### **b. Exemple simple : Tâche asynchrone**

**Structure du projet :**
```
my_project/
├── tasks.py
├── celery_app.py
```

**Fichier `celery_app.py` :**

```python
from celery import Celery

# Configuration de l'application Celery avec Redis comme backend

app = Celery('my_project', broker='redis://localhost:6379/0', backend='redis://localhost:6379/0')
```

**Fichier `tasks.py` :**

```python
from celery_app import app

@app.task
def add(x, y):
    return x + y
```

**Exécution de la tâche :**

- Lancez le worker Celery :

  ```bash
  celery -A celery_app worker --loglevel=info
  ```

- Appelez la tâche dans un script Python :

  ```python
  from tasks import add
  result = add.delay(4, 6)
  print(result.get())  # Affiche 10
  ```

#### **c. Avantages de Celery**
- Conception modulaire pour la gestion de workflows complexes.
- Compatible avec plusieurs backends comme Redis, RabbitMQ, et Amazon SQS.
- Permet l'exécution planifiée des tâches avec `celery-beat`.

#### **d. Cas d'utilisation**
- Traitement en arrière-plan (e-mails, notifications).
- Analyse des données en lot.
- Orchestration des workflows en microservices.

---

### **2. Calcul Distribué avec Dask**

Dask est une bibliothèque Python conçue pour le calcul parallèle et distribué, particulièrement utile pour traiter de grandes données sur des machines locales ou dans des clusters.

#### **a. Installation de Dask**

Installez Dask avec ses modules principaux :

```bash
pip install dask[complete]
```

#### **b. Concepts de base**
Dask introduit des **graphes de tâches** pour représenter les calculs et les exécuter efficacement sur plusieurs cœurs ou machines.

**Exemple : Traitement parallèle d'une liste**

```python
import dask
from dask import delayed

@delayed
def square(x):
    return x ** 2

@delayed
def sum_squares(squares):
    return sum(squares)

data = [1, 2, 3, 4]
squares = [square(x) for x in data]
result = sum_squares(squares)

print(result.compute())  # Exécute les tâches et affiche 30
```

#### **c. Manipulation de données avec Dask DataFrame**

Dask fournit des structures similaires à pandas mais optimisées pour des jeux de données volumineux :

```python
import dask.dataframe as dd

# Chargement d'un fichier CSV volumineux
df = dd.read_csv('large_dataset.csv')

# Traitement parallèle
filtered_df = df[df['column'] > 10]
result = filtered_df.groupby('another_column').mean()

# Exécution
print(result.compute())
```

#### **d. Gestion des clusters**

Dask peut fonctionner sur un cluster distribué :

- Installez le planificateur Dask :

  ```bash
  dask-scheduler
  ```
- Connectez les travailleurs (workers) :
  ```bash
  dask-worker <adresse_du_scheduler>
  ```

#### **e. Avantages de Dask**
- Extensible : fonctionne aussi bien sur un ordinateur personnel que sur des clusters massifs.
- Compatible avec pandas, NumPy et scikit-learn.
- Aucune modification majeure du code existant pour le paralléliser.

---

### **3. Comparaison Celery vs Dask**

| **Critère**              | **Celery**                      | **Dask**                      |
|--------------------------|----------------------------------|--------------------------------|
| **Objectif principal**   | Gestion de workflows asynchrones | Calcul parallèle et distribué |
| **Backend nécessaire**   | Redis, RabbitMQ, etc.           | Facultatif (ou cluster)       |
| **Complexité des tâches**| Tâches indépendantes            | Tâches interconnectées        |
| **Domaines d'application** | Tâches d'arrière-plan          | Calcul intensif               |

---

### **Résumé**

1. **Celery** est idéal pour orchestrer des workflows asynchrones, notamment dans des applications web ou des systèmes distribués où les tâches sont relativement indépendantes.
2. **Dask** est mieux adapté pour des charges de travail nécessitant un calcul intensif ou des analyses massives de données, avec une scalabilité naturelle sur plusieurs machines.
3. Ces outils peuvent être combinés pour des pipelines complexes, par exemple, en utilisant Celery pour l'orchestration et Dask pour le traitement des données.

### Chap 26 **Gestion des Bases de Données en Python**

La gestion des bases de données est essentielle dans le développement d'applications modernes. Python offre plusieurs outils pour interagir avec des bases relationnelles (SQL) ou non relationnelles (NoSQL). Voici un aperçu des techniques courantes :

---

### **1. MongoDB avec PyMongo**

MongoDB est une base de données NoSQL orientée documents, idéale pour gérer des données semi-structurées.

#### **a. Installation**

Installez la bibliothèque `pymongo` pour interagir avec MongoDB :

```bash
pip install pymongo
```

#### **b. Exemple simple : Connexion et opérations de base**

**Connexion à une base MongoDB :**

```python
from pymongo import MongoClient

# Connexion au serveur MongoDB local
client = MongoClient('mongodb://localhost:27017/')

# Accéder à une base de données et une collection
db = client.my_database
collection = db.my_collection
```

**Insertion de documents :**

```python
document = {"name": "Alice", "age": 25, "city": "Paris"}
collection.insert_one(document)

documents = [
    {"name": "Bob", "age": 30, "city": "Lyon"},
    {"name": "Charlie", "age": 35, "city": "Marseille"}
]
collection.insert_many(documents)
```

**Requêtes simples :**

```python
# Trouver un document
result = collection.find_one({"name": "Alice"})
print(result)

# Trouver plusieurs documents
for doc in collection.find({"age": {"$gte": 30}}):
    print(doc)
```

**Mise à jour et suppression :**

```python
# Mettre à jour un document
collection.update_one({"name": "Alice"}, {"$set": {"age": 26}})

# Supprimer un document
collection.delete_one({"name": "Bob"})
```

#### **c. Avantages de MongoDB**
- Flexible pour des schémas dynamiques.
- Performant pour des applications en temps réel.

---

### **2. Redis comme Cache avec redis-py**

Redis est une base de données NoSQL en mémoire utilisée comme cache rapide ou système de message.

#### **a. Installation**

Installez le client Python pour Redis :

```bash
pip install redis
```

#### **b. Exemple simple : Connexion et stockage de données**

**Connexion à Redis :**

```python
import redis

# Connexion au serveur Redis local
r = redis.Redis(host='localhost', port=6379, db=0)
```

**Stockage et récupération :**

```python
# Ajouter une clé-valeur
r.set('key1', 'value1')

# Récupérer la valeur associée à une clé
value = r.get('key1')
print(value.decode('utf-8'))  # Affiche 'value1'
```

**Incrémentation et expiration :**

```python
# Incrémenter une clé numérique
r.set('counter', 1)
r.incr('counter')  # Résultat : 2

# Ajouter une clé avec expiration
r.setex('temp_key', 10, 'temp_value')  # Expire après 10 secondes
```

**Utilisation comme cache pour des calculs coûteux :**

```python
def cached_function(key, compute_func):
    if r.exists(key):
        return r.get(key).decode('utf-8')
    else:
        result = compute_func()
        r.set(key, result, ex=3600)  # Cache pour 1 heure
        return result
```

---

### **3. ORM de Base avec SQLAlchemy ou Peewee**

Les ORM (Object-Relational Mapping) permettent de manipuler des bases SQL via des objets Python, simplifiant l'interaction avec les bases relationnelles comme MySQL ou PostgreSQL.

#### **a. SQLAlchemy**

**Installation :**

```bash
pip install sqlalchemy
```

**Connexion et définition d'un modèle :**

```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# Connexion à SQLite
engine = create_engine('sqlite:///example.db', echo=True)
Base = declarative_base()

# Définir un modèle
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    age = Column(Integer)

# Créer les tables
Base.metadata.create_all(engine)

# Créer une session
Session = sessionmaker(bind=engine)
session = Session()
```

**Insertion et requêtes :**

```python
# Ajouter un utilisateur
new_user = User(name="Alice", age=25)
session.add(new_user)
session.commit()

# Requêter des utilisateurs
users = session.query(User).filter_by(age=25).all()
for user in users:
    print(user.name)
```

#### **b. Peewee**

**Installation :**

```bash
pip install peewee
```

**Exemple avec Peewee :**

```python
from peewee import SqliteDatabase, Model, CharField, IntegerField

# Connexion à SQLite
db = SqliteDatabase('example.db')

# Définir un modèle
class User(Model):
    name = CharField()
    age = IntegerField()

    class Meta:
        database = db

# Créer la table
db.connect()
db.create_tables([User])

# Ajouter un utilisateur
user = User.create(name="Alice", age=25)

# Requêtes
for user in User.select().where(User.age > 20):
    print(user.name)
```

---

### **Comparaison des Approches**

| **Critère**            | **MongoDB avec PyMongo**    | **Redis avec redis-py**       | **ORM (SQLAlchemy / Peewee)** |
|-------------------------|-----------------------------|--------------------------------|--------------------------------|
| **Type de base**        | NoSQL (documents)          | NoSQL (clé-valeur en mémoire) | SQL (relationnel)             |
| **Cas d'utilisation**   | Données flexibles, volumineuses | Cache rapide, sessions       | Données structurées           |
| **Langage de requête**  | Requêtes JSON              | Commandes simples             | Abstraction Pythonique        |
| **Scalabilité**         | Haute                     | Très haute (en mémoire)       | Variable (dépend du SQL)      |

---

### **Résumé**

- **MongoDB (PyMongo)** : Idéal pour des données semi-structurées et des schémas dynamiques.
- **Redis (redis-py)** : Parfait pour la mise en cache, le stockage temporaire, ou les systèmes de messagerie rapide.
- **ORM (SQLAlchemy, Peewee)** : Simplifie l'interaction avec des bases relationnelles tout en restant robuste pour les projets nécessitant des structures fixes.

Ces outils peuvent être combinés dans une application : par exemple, Redis pour le cache, MongoDB pour stocker des données non relationnelles, et SQLAlchemy pour les relations complexes.

### Chap 27 **Automatisation et DevOps avec Python**

L'automatisation et les pratiques DevOps permettent de simplifier les déploiements, de gérer les infrastructures de manière efficace, et de maintenir la cohérence des environnements. Python est un langage clé dans cet écosystème grâce à sa polyvalence et ses bibliothèques.

---

### **1. Automatisation de Déploiements avec Ansible**

Ansible est un outil open-source d'automatisation qui facilite la gestion des configurations, le déploiement des applications et l'orchestration des tâches. Python est à la base de son fonctionnement.

#### **a. Installation et configuration d'Ansible**

1. Installez Ansible :

   ```bash
   pip install ansible
   ```
2. Configurez un inventaire pour définir les serveurs cibles dans un fichier `inventory.ini` :
   ```ini
   [webservers]
   server1 ansible_host=192.168.1.10 ansible_user=ubuntu ansible_ssh_private_key_file=~/.ssh/id_rsa
   ```

#### **b. Création d'un playbook**

Un playbook Ansible est un fichier YAML décrivant les tâches à exécuter.

Exemple : Installation d'un serveur Nginx

```yaml
- name: Installer et configurer Nginx
  hosts: webservers
  become: yes
  tasks:
    - name: Mettre à jour les paquets
      apt:
        update_cache: yes

    - name: Installer Nginx
      apt:
        name: nginx
        state: present

    - name: Activer et démarrer Nginx
      service:
        name: nginx
        state: started
        enabled: yes
```

**Exécution du playbook :**

```bash
ansible-playbook -i inventory.ini playbook.yml
```

#### **c. Avantages**
- **Idempotence** : Les tâches sont répétables et ne causent pas de doublons.
- **Simplicité** : Syntaxe lisible et facile à comprendre.
- **Extensibilité** : Compatible avec des modules Python personnalisés.

---

### **2. Conteneurisation avec Docker**

Docker est un outil essentiel pour packager les applications avec toutes leurs dépendances, garantissant qu'elles s'exécutent de manière cohérente sur tous les environnements.

#### **a. Installation et configuration de Docker**
1. Installez Docker : [Documentation officielle](https://docs.docker.com/get-docker/).
2. Vérifiez l'installation :
   ```bash
   docker --version
   ```

#### **b. Création d'un Dockerfile**
Un `Dockerfile` décrit comment construire une image Docker pour votre application.

Exemple : Application Flask

```dockerfile
# Utiliser une image Python comme base
FROM python:3.10-slim

# Définir le répertoire de travail
WORKDIR /app

# Copier les fichiers nécessaires
COPY requirements.txt requirements.txt
COPY app.py app.py

# Installer les dépendances
RUN pip install --no-cache-dir -r requirements.txt

# Exposer le port 5000
EXPOSE 5000

# Commande pour lancer l'application
CMD ["python", "app.py"]
```

**Build et exécution :**
```bash
# Construire l'image Docker
docker build -t my-flask-app .

# Exécuter un conteneur
docker run -p 5000:5000 my-flask-app
```

#### **c. Gestion des conteneurs**

Quelques commandes Docker utiles :

- **Lister les conteneurs :**

  ```bash
  docker ps -a
  ```

- **Arrêter un conteneur :**

  ```bash
  docker stop <container_id>
  ```

- **Supprimer un conteneur :**

  ```bash
  docker rm <container_id>
  ```

#### **d. Utilisation avancée avec Docker Compose**
Docker Compose permet de définir et gérer plusieurs conteneurs dans un fichier `docker-compose.yml`.

Exemple : Application Flask avec une base de données PostgreSQL

```yaml
version: '3.8'
services:
  web:
    build: .
    ports:
      - "5000:5000"
    depends_on:
      - db
  db:
    image: postgres:latest
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: flaskdb
```

**Lancer l'ensemble :**

```bash
docker-compose up
```

---

### **Comparaison entre Ansible et Docker**

| **Critère**              | **Ansible**                             | **Docker**                              |
|--------------------------|------------------------------------------|-----------------------------------------|
| **Objectif principal**   | Automatisation des configurations        | Conteneurisation des applications       |
| **Étendue**              | Gère les serveurs et les applications    | Isoler les applications et leurs dépendances |
| **Persistant**           | Oui (applique des changements permanents) | Non (conteneurs éphémères par défaut)   |
| **Facilité de configuration** | Requiert un inventaire et des playbooks | Requiert un Dockerfile                  |

---

### **Applications pratiques**

- **Ansible** : Installer automatiquement des outils de monitoring (Prometheus, Grafana) sur un cluster de serveurs.
- **Docker** : Déployer une application web en environnement isolé avec ses services associés.

---

### **Résumé**

- **Ansible** est idéal pour automatiser les déploiements, gérer les configurations, et maintenir des infrastructures cohérentes.
- **Docker** simplifie la conteneurisation des applications, en garantissant leur portabilité entre différents environnements.

### Chap 28 **Introduction aux Expressions Régulières avec le Module `re`**

Les expressions régulières (regex) sont des outils puissants pour rechercher, valider ou manipuler des chaînes de caractères en Python. Le module `re` de la bibliothèque standard fournit les fonctions nécessaires pour travailler avec ces patterns.

---

### **1. Concepts de base**

- **Expression régulière** : Une séquence de caractères décrivant un modèle (pattern) de recherche.
- **Utilisation courante** : 
  - Recherche de sous-chaînes.
  - Validation de formats (e-mails, numéros de téléphone, etc.).
  - Remplacement ou modification de contenu.

---

### **2. Fonctions principales du module `re`**

#### **a. Recherche avec `re.search`**

Recherche le premier endroit où le pattern correspond dans une chaîne.

```python
import re

texte = "Mon numéro est 123-456-7890."
match = re.search(r"\d{3}-\d{3}-\d{4}", texte)
if match:
    print(f"Numéro trouvé : {match.group()}")
```

#### **b. Validation avec `re.match`**

Vérifie si une chaîne entière correspond à un pattern.

```python
pattern = r"^\d{3}-\d{3}-\d{4}$"
chaine = "123-456-7890"
if re.match(pattern, chaine):
    print("Format valide")
else:
    print("Format invalide")
```

#### **c. Recherche multiple avec `re.findall`**

Renvoie toutes les correspondances sous forme de liste.

```python
texte = "Voici deux numéros : 123-456-7890 et 987-654-3210."
matches = re.findall(r"\d{3}-\d{3}-\d{4}", texte)
print("Numéros trouvés :", matches)
```

#### **d. Substitution avec `re.sub`**

Remplace toutes les correspondances d'un pattern par une autre chaîne.

```python
texte = "Mon numéro est 123-456-7890."
texte_modifie = re.sub(r"\d{3}-\d{3}-\d{4}", "XXX-XXX-XXXX", texte)
print(texte_modifie)
```

---

### **3. Cas pratiques**

#### **a. Validation d'adresses e-mail**

```python
email = "exemple@test.com"
pattern = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"
if re.match(pattern, email):
    print("Adresse e-mail valide")
else:
    print("Adresse e-mail invalide")
```

#### **b. Extraction d'informations (dates)**

```python
texte = "Les événements ont lieu le 10/01/2025 et le 15/02/2025."
dates = re.findall(r"\d{2}/\d{2}/\d{4}", texte)
print("Dates extraites :", dates)
```

#### **c. Transformation de texte (formatage de numéros de téléphone)**

```python
texte = "1234567890 et 9876543210 sont mes numéros."
formatted = re.sub(r"(\d{3})(\d{3})(\d{4})", r"\1-\2-\3", texte)
print("Numéros formatés :", formatted)
```

---

### **4. Options et Modificateurs**

- **`re.IGNORECASE` (`re.I`)** : Ignore la casse lors de la recherche.
- **`re.MULTILINE` (`re.M`)** : Permet de rechercher sur plusieurs lignes.
- **`re.DOTALL` (`re.S`)** : Permet au point (`.`) de correspondre aux sauts de ligne.
  
Exemple :
```python
texte = "Bonjour\nMONDE"
match = re.search(r"monde", texte, re.IGNORECASE)
if match:
    print("Correspondance trouvée :", match.group())
```

---

### **5. Structure des Patterns**

| **Pattern**       | **Description**                          |
|--------------------|------------------------------------------|
| `.`               | N'importe quel caractère sauf un saut de ligne. |
| `\d`              | Un chiffre (`0-9`).                     |
| `\w`              | Un caractère alphanumérique ou `_`.      |
| `\s`              | Un espace, tabulation ou saut de ligne.  |
| `*`               | Répète 0 ou plusieurs fois.             |
| `+`               | Répète 1 ou plusieurs fois.             |
| `{n}`             | Exactement `n` occurrences.             |
| `[abc]`           | Un des caractères dans `abc`.           |
| `[^abc]`          | Aucun des caractères dans `abc`.        |

---

### **6. Optimisation et Bonnes Pratiques**

- **Compilations préalables avec `re.compile`** :
  Permet de réutiliser un pattern compilé pour optimiser les performances.
  ```python
  pattern = re.compile(r"\d{3}-\d{3}-\d{4}")
  print(pattern.search("Numéro : 123-456-7890"))
  ```

- **Tester vos regex** :
  Utilisez des outils comme [regex101](https://regex101.com) pour tester vos patterns.

- **Éviter les patterns trop complexes** :
  Décomposez les regex compliquées pour les rendre plus lisibles.

---

### **Résumé**

Les expressions régulières sont indispensables pour traiter et analyser les chaînes de caractères en Python. Grâce au module `re`, vous pouvez rechercher, valider, et transformer facilement du texte. Toutefois, leur puissance nécessite de bien comprendre les patterns et d'utiliser des pratiques optimisées.

### Chap 29 **Gestion des Fichiers Avancée avec les Modules `os` et `shutil`**

La gestion avancée des fichiers en Python repose sur les modules `os` et `shutil`, qui offrent une multitude de fonctionnalités pour manipuler, copier, déplacer, et gérer les fichiers et répertoires.

---

### **1. Module `os` : Manipulation de Chemins et Fichiers**

#### **a. Gestion des chemins**
Le module `os` fournit des fonctions pour manipuler les chemins de fichiers, détecter leur existence, ou créer des répertoires.

- **Vérification de l'existence d'un fichier ou dossier** :

  ```python
  import os

  chemin = "mon_fichier.txt"
  if os.path.exists(chemin):
      print("Le fichier existe.")
  else:
      print("Le fichier n'existe pas.")
  ```

- **Joindre des chemins de manière portable** :

  ```python
  chemin_complet = os.path.join("dossier", "sous_dossier", "fichier.txt")
  print(chemin_complet)
  ```

- **Récupérer le nom du fichier ou du répertoire parent** :

  ```python
  chemin = "/chemin/vers/fichier.txt"
  print("Nom du fichier :", os.path.basename(chemin))
  print("Répertoire parent :", os.path.dirname(chemin))
  ```

#### **b. Création et suppression**

- **Créer un répertoire** :

  ```python
  os.makedirs("nouveau_dossier/sous_dossier", exist_ok=True)
  print("Dossier créé.")
  ```

- **Supprimer un fichier ou répertoire vide** :

  ```python
  os.remove("fichier_a_supprimer.txt")  # Supprime un fichier
  os.rmdir("dossier_vide")             # Supprime un répertoire vide
  ```

---

### **2. Module `shutil` : Opérations Avancées sur les Fichiers**

Le module `shutil` est idéal pour des opérations complexes comme la copie, le déplacement ou la compression de fichiers.

#### **a. Copier des fichiers**

- **Copier un fichier** :

  ```python
  import shutil

  shutil.copy("source.txt", "destination.txt")
  print("Fichier copié.")
  ```

- **Copier un fichier avec ses métadonnées** :

  ```python
  shutil.copy2("source.txt", "destination.txt")
  ```

#### **b. Déplacement et renommage**

- **Déplacer un fichier ou un dossier** :

  ```python
  shutil.move("source.txt", "nouveau_dossier/")
  ```

#### **c. Suppression de dossiers entiers**

- **Supprimer un répertoire et tout son contenu** :

  ```python
  shutil.rmtree("dossier_a_supprimer")
  print("Dossier supprimé.")
  ```

#### **d. Création d'archives**

- **Créer une archive ZIP ou TAR** :

  ```python
  shutil.make_archive("mon_archive", "zip", "dossier_a_compresser")
  print("Archive créée.")
  ```

---

### **3. Cas Pratiques**

#### **a. Liste des fichiers dans un répertoire**

```python
chemin = "mon_dossier"
fichiers = os.listdir(chemin)
print("Fichiers et dossiers :", fichiers)
```

#### **b. Rechercher des fichiers avec une extension spécifique**

```python
chemin = "mon_dossier"
for fichier in os.listdir(chemin):
    if fichier.endswith(".txt"):
        print("Fichier texte trouvé :", fichier)
```

#### **c. Vérifier la taille d'un fichier**

```python
chemin = "mon_fichier.txt"
taille = os.path.getsize(chemin)
print(f"Taille du fichier : {taille} octets")
```

---

### **4. Bonnes Pratiques**

- **Vérification préalable** :
  Toujours vérifier l'existence d'un fichier ou répertoire avant d'y accéder ou de le supprimer.
  
- **Utilisation de chemins absolus ou relatifs portables** :
  Utilisez `os.path.join` pour garantir la compatibilité multiplateforme.

- **Gestion des exceptions** :

  Manipuler les fichiers peut entraîner des erreurs (fichiers non trouvés, permissions insuffisantes). Utilisez `try/except` pour une gestion sécurisée.

  ```python
  try:
      os.remove("fichier_inexistant.txt")
  except FileNotFoundError:
      print("Fichier introuvable.")
  ```

- **Nettoyage des ressources** :
  Pour garantir une bonne gestion des ressources, utilisez des contextes (`with`) lorsque vous ouvrez ou manipulez des fichiers.

---

### **Résumé**

- Le module `os` gère principalement les chemins, la création/suppression de fichiers et dossiers.
- Le module `shutil` offre des fonctionnalités avancées comme la copie, le déplacement, et la compression.
- Ces outils combinés permettent une gestion fine et puissante des fichiers dans des projets Python.

### Chap 30 **Concepts de Classe Avancée en Python**

La programmation orientée objet (POO) en Python permet de structurer et de gérer des programmes complexes en utilisant des classes et des objets. Les concepts avancés incluent l'utilisation de méthodes spéciales, l'héritage approfondi et d'autres mécanismes qui enrichissent les fonctionnalités des classes.

---

### **1. Méthodes Spéciales**
Les méthodes spéciales, ou "méthodes magiques", permettent de personnaliser le comportement des objets dans certains contextes spécifiques. Elles sont reconnaissables par leur double underscore (`__`).

#### **a. `__str__` et `__repr__` : Représentation des objets**
- **`__str__`** : Retourne une représentation lisible pour les utilisateurs (souvent utilisée dans `print`).
- **`__repr__`** : Retourne une représentation officielle destinée aux développeurs (idéalement exécutable).

```python
class Personne:
    def __init__(self, nom, age):
        self.nom = nom
        self.age = age

    def __str__(self):
        return f"{self.nom}, {self.age} ans"

    def __repr__(self):
        return f"Personne(nom='{self.nom}', age={self.age})"

personne = Personne("Alice", 30)
print(str(personne))   # Alice, 30 ans
print(repr(personne))  # Personne(nom='Alice', age=30)
```

---

#### **b. `__eq__` : Comparaison d'objets**
Permet de définir le comportement de l'opérateur `==`.

```python
class Personne:
    def __init__(self, nom, age):
        self.nom = nom
        self.age = age

    def __eq__(self, autre):
        return self.nom == autre.nom and self.age == autre.age

personne1 = Personne("Alice", 30)
personne2 = Personne("Alice", 30)
print(personne1 == personne2)  # True
```

---

#### **c. Autres méthodes utiles**
- **`__lt__`, `__le__`, `__gt__`, `__ge__`** : Comparaisons `<`, `<=`, `>`, `>=`.
- **`__add__`, `__sub__`, `__mul__`, etc.** : Surcharge des opérateurs arithmétiques.
- **`__len__`** : Définir le comportement de `len()` pour un objet.
- **`__call__`** : Rendre un objet "appelable" comme une fonction.

```python
class Addition:
    def __init__(self, valeur):
        self.valeur = valeur

    def __call__(self, autre):
        return self.valeur + autre

add = Addition(5)
print(add(10))  # 15
```

---

### **2. Héritage Avancé**
L'héritage permet à une classe d'hériter des attributs et des méthodes d'une autre classe.

#### **a. Héritage simple**
Une classe dérive d'une seule classe parente.

```python
class Animal:
    def parler(self):
        print("L'animal fait un bruit.")

class Chien(Animal):
    def parler(self):
        print("Le chien aboie.")

chien = Chien()
chien.parler()  # Le chien aboie.
```

---

#### **b. Héritage multiple**
Une classe peut hériter de plusieurs classes parentes. Cela nécessite de gérer les conflits éventuels via l'ordre de résolution des méthodes (MRO, Method Resolution Order).

```python
class A:
    def dire(self):
        print("Classe A")

class B:
    def dire(self):
        print("Classe B")

class C(A, B):
    pass

c = C()
c.dire()  # Classe A (ordre de MRO : C -> A -> B)
```

Pour voir l'ordre de résolution des méthodes :
```python
print(C.mro())  # [<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]
```

---

### **3. Concepts Avancés**
#### **a. Héritage avec super()**
La fonction `super()` permet d'accéder aux méthodes ou attributs des classes parentes, même dans le cas d'un héritage multiple.

```python
class Parent:
    def __init__(self, nom):
        self.nom = nom

class Enfant(Parent):
    def __init__(self, nom, age):
        super().__init__(nom)
        self.age = age

enfant = Enfant("Alice", 10)
print(enfant.nom, enfant.age)  # Alice 10
```

---

#### **b. Classes abstraites**
Les classes abstraites servent de modèles et ne peuvent pas être instanciées. Elles utilisent le module `abc`.

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def parler(self):
        pass

class Chat(Animal):
    def parler(self):
        print("Le chat miaule.")

chat = Chat()
chat.parler()  # Le chat miaule.
```

---

### **4. Cas Pratique : Polymorphisme**
Le polymorphisme permet d'utiliser un même nom de méthode pour différents comportements.

```python
class Chien:
    def parler(self):
        print("Le chien aboie.")

class Chat:
    def parler(self):
        print("Le chat miaule.")

animaux = [Chien(), Chat()]
for animal in animaux:
    animal.parler()
# Le chien aboie.
# Le chat miaule.
```

---

### **Résumé**
- Les **méthodes spéciales** enrichissent le comportement des objets.
- L'**héritage simple** est utile pour organiser le code, et l'**héritage multiple** doit être utilisé avec précaution.
- Le **polymorphisme** et les **classes abstraites** facilitent l'évolutivité et la flexibilité du code.

### Chap 31 **Threading de Base en Python**

Le **multithreading** permet d'exécuter plusieurs tâches simultanément au sein d'un programme. Il est particulièrement utile pour les tâches d'I/O (lecture/écriture de fichiers, requêtes réseau) où les threads peuvent s'exécuter en parallèle pour améliorer les performances. Python fournit le module **`threading`** pour gérer les threads.

---

### **1. Concepts de Base**
Un **thread** est une unité d'exécution indépendante qui partage les ressources (comme la mémoire) avec les autres threads du même processus.

#### **Avantages :**
- Permet des exécutions simultanées.
- Idéal pour les tâches d'I/O.

#### **Limites :**
- En Python, le **GIL (Global Interpreter Lock)** limite l'exécution simultanée de threads pour le code Python pur. Cela impacte les tâches intensives en calcul.

---

### **2. Création d'un Thread**
#### **Méthode 1 : Utilisation de `threading.Thread`**
Créer un thread en définissant une fonction à exécuter.

```python
import threading
import time

def dire_bonjour():
    for i in range(5):
        print("Bonjour!")
        time.sleep(1)

# Créer un thread
thread = threading.Thread(target=dire_bonjour)

# Démarrer le thread
thread.start()

# Continuer l'exécution principale
print("Tâche principale continue.")
```

---

#### **Méthode 2 : Hériter de `threading.Thread`**
Créer une classe personnalisée pour plus de contrôle.

```python
class MonThread(threading.Thread):
    def __init__(self, nom):
        super().__init__()
        self.nom = nom

    def run(self):
        for i in range(5):
            print(f"Thread {self.nom} en cours d'exécution.")
            time.sleep(1)

# Créer et démarrer un thread
mon_thread = MonThread("A")
mon_thread.start()
```

---

### **3. Cas d'Utilisation Pratique**
#### **Exemple : Téléchargement de fichiers en parallèle**
Imaginons une tâche où plusieurs fichiers doivent être téléchargés simultanément.

```python
import threading
import time

def telecharger_fichier(nom_fichier, duree):
    print(f"Téléchargement de {nom_fichier} commencé.")
    time.sleep(duree)
    print(f"Téléchargement de {nom_fichier} terminé.")

fichiers = [("Fichier1", 3), ("Fichier2", 5), ("Fichier3", 2)]

threads = []
for nom, duree in fichiers:
    thread = threading.Thread(target=telecharger_fichier, args=(nom, duree))
    threads.append(thread)
    thread.start()

# Attendre la fin de tous les threads
for thread in threads:
    thread.join()

print("Tous les téléchargements sont terminés.")
```

---

### **4. Synchronisation avec `Lock`**
Lorsque plusieurs threads accèdent aux mêmes ressources, des **verrous (`Lock`)** permettent d'éviter des conflits.

#### **Exemple : Incrémentation sécurisée**
Sans verrou, plusieurs threads pourraient modifier la même variable simultanément, entraînant des résultats imprévisibles.

```python
import threading

compteur = 0
lock = threading.Lock()

def incrementer():
    global compteur
    for _ in range(1000):
        with lock:  # Section critique
            compteur += 1

threads = [threading.Thread(target=incrementer) for _ in range(10)]

for thread in threads:
    thread.start()

for thread in threads:
    thread.join()

print(f"Valeur finale du compteur : {compteur}")
```

---

### **5. Limitations du GIL**
Pour des tâches intensives en calcul (comme le traitement de données), le GIL empêche l'exécution parallèle des threads Python. Dans ce cas, **`multiprocessing`** ou des bibliothèques comme **Numba** ou **Cython** sont préférables.

---

### **Résumé**
- **`threading.Thread`** permet de créer des threads pour exécuter des tâches simultanées.
- Utilisez **`Lock`** pour synchroniser les accès à des ressources partagées.
- Le threading est particulièrement utile pour les tâches I/O, mais pour les tâches intensives en calcul, privilégiez le **multiprocessing**.

### Chap 32 **Fonctions Anonymes et Programmation Fonctionnelle de Base en Python**

Python propose des outils puissants pour la **programmation fonctionnelle**, un paradigme qui se concentre sur l’utilisation de fonctions comme blocs de construction du programme. Les fonctions **anonymes (`lambda`)** et des outils comme **`map()`**, **`filter()`**, et **`reduce()`** permettent de manipuler efficacement des données sans écrire de boucles explicites.

---

### **1. Fonctions Anonymes (`lambda`)**
Une **fonction lambda** est une fonction anonyme définie en une seule ligne. Elle est souvent utilisée pour des fonctions simples ou temporaires.

#### **Syntaxe :**

```python
lambda arguments: expression
```

#### **Exemple :**

Additionner deux nombres :

```python
addition = lambda x, y: x + y
print(addition(3, 5))  # Sortie : 8
```

#### **Cas d'utilisation :**
Les fonctions lambda sont souvent utilisées avec d'autres fonctions comme `map()`, `filter()`, ou des fonctions de tri.

---

### **2. La fonction `map()`**
**`map()`** applique une fonction donnée à chaque élément d'une séquence (liste, tuple, etc.) et retourne un **itérable**.

#### **Syntaxe :**

```python
map(function, iterable)
```

#### **Exemple : Conversion de températures Celsius en Fahrenheit**

```python
celsius = [0, 20, 30, 40]
fahrenheit = list(map(lambda x: (x * 9/5) + 32, celsius))
print(fahrenheit)  # Sortie : [32.0, 68.0, 86.0, 104.0]
```

---

### **3. La fonction `filter()`**
**`filter()`** retourne les éléments d'un itérable qui satisfont une condition (fonction renvoyant `True`).

#### **Syntaxe :**

```python
filter(function, iterable)
```

#### **Exemple : Filtrer les nombres pairs**

```python
nombres = [1, 2, 3, 4, 5, 6]
pairs = list(filter(lambda x: x % 2 == 0, nombres))
print(pairs)  # Sortie : [2, 4, 6]
```

---

### **4. La fonction `reduce()`**
**`reduce()`** (dans le module `functools`) applique une fonction cumulativement à une séquence pour réduire cette dernière à une seule valeur.

#### **Syntaxe :**

```python
from functools import reduce
reduce(function, iterable)
```

#### **Exemple : Calcul du produit de tous les nombres**

```python
from functools import reduce

nombres = [1, 2, 3, 4]
produit = reduce(lambda x, y: x * y, nombres)
print(produit)  # Sortie : 24
```

---

### **5. Cas Pratiques**

#### **Exemple 1 : Trier une liste de dictionnaires par une clé**

Trier des étudiants par leurs notes :

```python
etudiants = [{'nom': 'Alice', 'note': 85}, {'nom': 'Bob', 'note': 92}, {'nom': 'Charlie', 'note': 78}]
tri = sorted(etudiants, key=lambda x: x['note'], reverse=True)
print(tri)
# Sortie : [{'nom': 'Bob', 'note': 92}, {'nom': 'Alice', 'note': 85}, {'nom': 'Charlie', 'note': 78}]
```

#### **Exemple 2 : Calculer la somme des carrés des nombres pairs**

```python
nombres = [1, 2, 3, 4, 5, 6]
somme_carre_pairs = reduce(lambda x, y: x + y, map(lambda x: x**2, filter(lambda x: x % 2 == 0, nombres)))
print(somme_carre_pairs)  # Sortie : 56 (2² + 4² + 6²)
```

#### **Exemple 3 : Trouver le mot le plus long dans une liste**

```python
mots = ["chat", "éléphant", "chien", "oiseau"]
mot_plus_long = reduce(lambda x, y: x if len(x) > len(y) else y, mots)
print(mot_plus_long)  # Sortie : "éléphant"
```

---

### **6. Comparaison avec des Boucles**

Les fonctions comme `map()` et `filter()` rendent le code plus concis et lisible, mais elles ne remplacent pas toujours les boucles, surtout pour des logiques complexes. Comparez :

#### **Avec `map()` :**

```python
nombres = [1, 2, 3, 4]
carres = list(map(lambda x: x**2, nombres))
print(carres)  # Sortie : [1, 4, 9, 16]
```

#### **Avec une boucle :**

```python
nombres = [1, 2, 3, 4]
carres = [x**2 for x in nombres]
print(carres)  # Sortie : [1, 4, 9, 16]
```

---

### **Résumé**
- Les **fonctions anonymes (`lambda`)** sont pratiques pour des opérations simples et temporaires.
- **`map()`** et **`filter()`** offrent une manière concise de transformer ou filtrer des itérables.
- **`reduce()`** est utile pour combiner tous les éléments d'une séquence en une seule valeur.
- Ces outils conviennent particulièrement aux tâches fonctionnelles et aux pipelines de traitement de données.

### Chap 33 **Itérateurs et Générateurs en Python**

Les **itérateurs** et **générateurs** permettent de manipuler des séquences de données efficacement. Ils sont particulièrement utiles pour gérer de grandes quantités de données ou pour créer des flux de données en temps réel, tout en réduisant l'utilisation de la mémoire.

---

### **1. Itérateurs**

Un **itérateur** est un objet qui implémente les méthodes spéciales **`__iter__()`** et **`__next__()`**, permettant de parcourir une séquence un élément à la fois.

#### **Création d'un itérateur personnalisé**

Voici un exemple simple pour créer un itérateur qui génère les nombres d'une séquence jusqu'à une limite donnée.

```python
class Compteur:
    def __init__(self, limite):
        self.limite = limite
        self.courant = 0

    def __iter__(self):
        return self  # Un itérateur doit retourner lui-même.

    def __next__(self):
        if self.courant < self.limite:
            valeur = self.courant
            self.courant += 1
            return valeur
        else:
            raise StopIteration  # Indique que l'itération est terminée.

# Utilisation
compteur = Compteur(5)
for nombre in compteur:
    print(nombre)  # Sortie : 0, 1, 2, 3, 4
```

---

### **2. Générateurs**

Un **générateur** est une fonction spéciale qui produit un itérateur sans avoir besoin d'implémenter manuellement les méthodes `__iter__()` et `__next__()`. Au lieu d'utiliser `return`, un générateur utilise **`yield`**, ce qui permet de suspendre et reprendre son exécution.

#### **Création d'un générateur**

Un générateur pour produire une séquence de Fibonacci :

```python
def fibonacci(limite):
    a, b = 0, 1
    while a < limite:
        yield a  # Génère la valeur actuelle et suspend l'exécution.
        a, b = b, a + b

# Utilisation
for nombre in fibonacci(10):
    print(nombre)  # Sortie : 0, 1, 1, 2, 3, 5, 8
```

---

### **3. Différences entre itérateurs et générateurs**

| **Aspect**         | **Itérateur**                                                  | **Générateur**                     |
|---------------------|---------------------------------------------------------------|-------------------------------------|
| **Création**        | Implémentation manuelle avec `__iter__()` et `__next__()`.     | Utilisation d'une fonction avec `yield`. |
| **Mémoire**         | Les données peuvent être stockées en mémoire.                 | Génère les valeurs à la demande (lazy evaluation). |
| **Complexité**      | Peut être plus complexe à implémenter.                        | Plus simple et concis.              |

---

### **4. Générateurs vs Listes**

Un générateur **ne stocke pas tous les éléments en mémoire**, contrairement à une liste. Cela permet de gérer des flux de données infinis ou de très grandes séquences.

#### **Exemple : Liste vs Générateur**

Avec une liste :

```python
nombres = [x**2 for x in range(10)]
print(nombres)  # Sortie : [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

Avec un générateur :

```python
nombres = (x**2 for x in range(10))
print(list(nombres))  # Sortie : [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

Le générateur ne calcule les valeurs qu'au moment où elles sont demandées.

---

### **5. Utilisation Avancée : Générateurs Infinis**

Un générateur infini qui génère des nombres pairs :

```python
def nombres_pairs():
    n = 0
    while True:
        yield n
        n += 2

# Utilisation
pairs = nombres_pairs()
for _ in range(5):
    print(next(pairs))  # Sortie : 0, 2, 4, 6, 8
```

---

### **6. Cas Pratiques**

#### **Exemple 1 : Lecture de fichiers ligne par ligne**

Les générateurs sont très utiles pour traiter de grands fichiers sans les charger entièrement en mémoire.

```python
def lire_fichier_en_lignes(nom_fichier):
    with open(nom_fichier, 'r') as fichier:
        for ligne in fichier:
            yield ligne.strip()

# Utilisation
for ligne in lire_fichier_en_lignes("example.txt"):
    print(ligne)
```

#### **Exemple 2 : Pipeline de traitement de données**
				
Créer des générateurs pour chaque étape d'un pipeline de traitement.

```python
def charger_donnees():
    for i in range(10):
        yield i

def transformer_donnees(donnees):
    for valeur in donnees:
        yield valeur**2

def filtrer_donnees(donnees):
    for valeur in donnees:
        if valeur % 2 == 0:
            yield valeur

# Chaînage des générateurs
pipeline = filtrer_donnees(transformer_donnees(charger_donnees()))
print(list(pipeline))  # Sortie : [0, 4, 16, 36, 64]
```

---

### **Résumé**
- Les **itérateurs** offrent un contrôle manuel sur l'itération.
- Les **générateurs**, grâce à `yield`, fournissent une alternative simple pour créer des séquences paresseuses.
- Ces outils sont essentiels pour **gérer efficacement la mémoire** et **traiter des flux de données** en temps réel.

### Chap 34 **Manipulation des fichiers avancée en Python**

La manipulation avancée des fichiers implique le travail avec différents formats de données courants (CSV, JSON, etc.) et des opérations sur le système de fichiers (par exemple, gestion des répertoires, copie de fichiers). Python offre des modules puissants comme **os**, **shutil**, **csv**, et **json** pour accomplir ces tâches.

---

### **1. Travail avec des fichiers CSV**

Le module **`csv`** facilite la lecture et l'écriture de fichiers au format CSV (Comma-Separated Values).

#### **Lecture d'un fichier CSV**

```python
import csv

# Lecture d'un fichier CSV
with open('exemple.csv', mode='r') as fichier:
    lecteur_csv = csv.reader(fichier)
    for ligne in lecteur_csv:
        print(ligne)
```

#### **Écriture dans un fichier CSV**

```python
# Écriture dans un fichier CSV
with open('sortie.csv', mode='w', newline='') as fichier:
    ecrivain_csv = csv.writer(fichier)
    ecrivain_csv.writerow(['Nom', 'Âge', 'Ville'])
    ecrivain_csv.writerow(['Alice', 30, 'Paris'])
    ecrivain_csv.writerow(['Bob', 25, 'Lyon'])
```

#### **Utilisation de `DictReader` et `DictWriter`**

```python
# Lecture avec DictReader
with open('exemple.csv', mode='r') as fichier:
    lecteur_csv = csv.DictReader(fichier)
    for ligne in lecteur_csv:
        print(ligne)

# Écriture avec DictWriter
with open('sortie.csv', mode='w', newline='') as fichier:
    colonnes = ['Nom', 'Âge', 'Ville']
    ecrivain_csv = csv.DictWriter(fichier, fieldnames=colonnes)
    ecrivain_csv.writeheader()
    ecrivain_csv.writerow({'Nom': 'Alice', 'Âge': 30, 'Ville': 'Paris'})
    ecrivain_csv.writerow({'Nom': 'Bob', 'Âge': 25, 'Ville': 'Lyon'})
```

---

### **2. Travail avec des fichiers JSON**

Le module **`json`** permet de travailler avec des données au format JSON (JavaScript Object Notation).

#### **Lecture d'un fichier JSON**

```python
import json

# Lecture d'un fichier JSON
with open('exemple.json', mode='r') as fichier:
    donnees = json.load(fichier)
    print(donnees)
```

#### **Écriture dans un fichier JSON**

```python
# Écriture dans un fichier JSON
donnees = {
    "Nom": "Alice",
    "Âge": 30,
    "Ville": "Paris"
}

with open('sortie.json', mode='w') as fichier:
    json.dump(donnees, fichier, indent=4)  # `indent=4` pour une écriture lisible
```

---

### **3. Utilisation des modules `os` et `shutil`**

Ces modules permettent de manipuler le système de fichiers : création de répertoires, copie, déplacement, suppression de fichiers, etc.

#### **Module `os`**

- **Liste des fichiers dans un répertoire**
```python
import os

# Liste des fichiers
repertoire = './'
fichiers = os.listdir(repertoire)
print(fichiers)
```

- **Création et suppression de répertoires**

```python
# Création
os.mkdir('nouveau_dossier')

# Suppression
os.rmdir('nouveau_dossier')
```

- **Manipulation des chemins**

```python
chemin = os.path.join('dossier', 'fichier.txt')
print(chemin)  # Sortie : 'dossier/fichier.txt' (ou adapté selon l'OS)

# Vérification si un fichier ou un répertoire existe
print(os.path.exists(chemin))
```

#### **Module `shutil`**

- **Copie et déplacement de fichiers**

```python
import shutil

# Copie de fichier
shutil.copy('source.txt', 'destination.txt')

# Déplacement de fichier
shutil.move('fichier.txt', 'nouveau_repertoire/')
```

- **Suppression de fichiers ou répertoires**

```python
# Suppression d'un fichier
os.remove('fichier.txt')

# Suppression d'un répertoire non vide
shutil.rmtree('dossier_non_vide')
```

---

### **4. Travail avec d'autres formats de fichiers**

#### **Manipulation de fichiers texte**

```python
# Lecture
with open('exemple.txt', mode='r') as fichier:
    contenu = fichier.read()
    print(contenu)

# Écriture
with open('exemple.txt', mode='w') as fichier:
    fichier.write('Bonjour, monde!')
```

#### **Manipulation de fichiers XML**

Pour les fichiers XML, utilisez le module **`xml.etree.ElementTree`**.

```python
import xml.etree.ElementTree as ET

# Lecture d'un fichier XML
arbre = ET.parse('exemple.xml')
racine = arbre.getroot()
print(racine.tag)

# Écriture d'un fichier XML
nouvel_element = ET.Element('note')
nouvel_element.text = 'Ceci est un test'
ET.ElementTree(nouvel_element).write('nouveau.xml')
```

---

### **5. Conseils pratiques**
1. Toujours utiliser `with` pour ouvrir des fichiers afin de s'assurer qu'ils sont correctement fermés.
2. Vérifier l'existence des fichiers avant d'y accéder pour éviter des erreurs (`os.path.exists`).
3. Utiliser des modules spécifiques comme **`pandas`** pour des manipulations complexes de données CSV ou JSON.

---

### **Résumé**
- Le module **`csv`** facilite le travail avec des fichiers tabulaires.
- Le module **`json`** permet de manipuler des structures complexes de données au format JSON.
- Les modules **`os`** et **`shutil`** permettent une gestion avancée des fichiers et répertoires.
- Python prend en charge de nombreux formats courants et offre une API intuitive pour leur manipulation.

### Chap 35 **Expressions régulières (module `re`)**

Les **expressions régulières (regex)** permettent de rechercher, valider, et manipuler des chaînes de caractères grâce à des motifs complexes. Python fournit le module **`re`** pour exploiter ces fonctionnalités.

---

### **1. Concepts de base des expressions régulières**

- **Recherche** : Identifier des motifs spécifiques dans une chaîne.
- **Substitution** : Remplacer des motifs par d'autres valeurs.
- **Validation** : Vérifier si une chaîne correspond à un motif donné.

---

### **2. Fonctions principales du module `re`**

#### **`re.search()`**

Recherche le **premier** motif correspondant dans une chaîne.

```python
import re

texte = "Bonjour, mon numéro est 123-456-7890."
resultat = re.search(r'\d{3}-\d{3}-\d{4}', texte)  # Motif : numéro de téléphone
if resultat:
    print("Numéro trouvé :", resultat.group())
```

#### **`re.findall()`**

Renvoie **toutes les occurrences** du motif sous forme de liste.

```python
texte = "Voici deux dates : 12/05/2023 et 14/06/2024."
resultats = re.findall(r'\d{2}/\d{2}/\d{4}', texte)  # Motif : dates au format DD/MM/YYYY
print("Dates trouvées :", resultats)
```

#### **`re.sub()`**

Remplace toutes les occurrences d'un motif par une autre chaîne.

```python
texte = "Prix : 10$, 20$, 30$"
nouveau_texte = re.sub(r'\$\d+', 'XX€', texte)  # Remplace les prix en dollars par "XX€"
print(nouveau_texte)
```

#### **`re.match()`**

Teste si un motif correspond au **début** d'une chaîne.

```python
texte = "abc123"
if re.match(r'abc', texte):
    print("Motif trouvé au début de la chaîne !")
```

#### **`re.split()`**

Divise une chaîne en fonction d'un motif.

```python
texte = "Nom: Alice; Âge: 30; Ville: Paris"
resultats = re.split(r';\s*', texte)  # Séparateurs : point-virgule suivi d'espaces
print(resultats)
```

---

### **3. Métacaractères courants et leurs significations**

| Métacaractère | Signification                              | Exemple                       |
|---------------|--------------------------------------------|-------------------------------|
| `.`           | N'importe quel caractère sauf une nouvelle ligne | `a.b` correspond à "acb", "a0b" |
| `^`           | Début de la chaîne                        | `^Bonjour` correspond à "Bonjour, monde" |
| `$`           | Fin de la chaîne                          | `monde$` correspond à "Bonjour, monde" |
| `*`           | 0 ou plusieurs occurrences                | `ab*` correspond à "a", "ab", "abb" |
| `+`           | 1 ou plusieurs occurrences                | `ab+` correspond à "ab", "abb" |
| `?`           | 0 ou 1 occurrence                         | `ab?` correspond à "a", "ab" |
| `{n}`         | Exactement `n` occurrences                | `a{3}` correspond à "aaa" |
| `{n,}`        | Au moins `n` occurrences                  | `a{2,}` correspond à "aa", "aaa" |
| `{n,m}`       | Entre `n` et `m` occurrences              | `a{2,4}` correspond à "aa", "aaa", "aaaa" |
| `[]`          | Classe de caractères                      | `[abc]` correspond à "a", "b", "c" |
| `|`           | OU logique                                | `a|b` correspond à "a" ou "b" |
| `\`           | Échappement des caractères spéciaux       | `\.` correspond à un point littéral |

---

### **4. Cas pratiques**

#### **Validation d'une adresse e-mail**

```python
email = "exemple@mail.com"
motif = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
if re.match(motif, email):
    print("Adresse e-mail valide !")
else:
    print("Adresse e-mail invalide.")
```

#### **Recherche de mots commençant par une lettre spécifique**

```python
texte = "Python est puissant, précis, et performant."
mots = re.findall(r'\bp\w*', texte, re.IGNORECASE)  # Mots commençant par "p" (non sensible à la casse)
print("Mots trouvés :", mots)
```

#### **Extraire les numéros de téléphone**

```python
texte = "Contacts : +33-6-12345678, +33-7-98765432."
motif = r'\+33-\d{1}-\d{8}'
numeros = re.findall(motif, texte)
print("Numéros extraits :", numeros)
```

#### **Remplacement de mots spécifiques**

```python
texte = "Le chat dort. Le chat mange. Le chat joue."
nouveau_texte = re.sub(r'\bchat\b', 'chien', texte)
print(nouveau_texte)
```

---

### **5. Flags utiles dans `re`**

- **`re.IGNORECASE` ou `re.I`** : Rend la recherche insensible à la casse.
- **`re.DOTALL` ou `re.S`** : Permet à `.` de correspondre aux nouvelles lignes.
- **`re.MULTILINE` ou `re.M`** : Permet à `^` et `$` de fonctionner sur chaque ligne.

```python
texte = """Bonjour.
Bienvenue au tutoriel regex."""
resultats = re.findall(r'^.+$', texte, re.MULTILINE)
print(resultats)  # Chaque ligne est traitée individuellement
```

---

### **6. Conseils pratiques**
1. **Tester les motifs** : Utilisez des outils en ligne comme [regex101](https://regex101.com/) pour construire et tester vos expressions régulières.
2. **Documenter vos motifs** : Les regex complexes deviennent rapidement difficiles à lire. Ajoutez des commentaires ou utilisez des motifs lisibles.
3. **Éviter les cas d'utilisation abusifs** : Les regex ne sont pas adaptées pour tout (ex. : analyse syntaxique de HTML/XML).

---

### **Résumé**
- Les expressions régulières sont puissantes pour manipuler et analyser des chaînes.
- Les fonctions principales incluent `search`, `findall`, `sub`, `match`, et `split`.
- Bien comprendre les métacaractères et utiliser les flags selon le besoin.
- Les regex bien écrites permettent d'automatiser des tâches complexes avec efficacité.

Niveau expert

### Chap 1. **Gestion de la mémoire et optimisation**

La gestion de la mémoire et l’optimisation des performances sont des aspects cruciaux pour les applications Python de grande envergure, notamment dans le contexte de traitement de données, de calculs intensifs ou de services web. Ces concepts sont abordés sous différents angles, allant de la gestion de la mémoire par le garbage collector à la mesure des performances du code.

#### **Garbage Collection (GC)**

La gestion de la mémoire en Python repose sur le **garbage collector**. Le garbage collection est un mécanisme qui permet de libérer de la mémoire en supprimant les objets qui ne sont plus utilisés.

- **Référence comptée** : Python utilise un mécanisme appelé comptage des références pour gérer la mémoire. Chaque objet en Python a un compteur de références. Lorsqu'une référence à un objet est créée ou supprimée, ce compteur est ajusté. Si ce compteur atteint zéro, cela signifie que l'objet n’est plus accessible, et donc il peut être détruit pour libérer la mémoire.

- **GC et cycles de référence** : Le comptage des références ne suffit pas pour gérer les objets référencés en boucle (par exemple, une liste contenant une référence à elle-même). Le **garbage collector** en Python est responsable de détecter et de collecter ces **cycles de références**, qui ne peuvent pas être détruits par le simple comptage des références.

#### Exemple :

```python
import gc

# Vérifie le collecteur de déchets
gc.collect()
```

Le module `gc` expose plusieurs fonctions pour interagir avec le garbage collector. `gc.collect()` force une exécution du collecteur de déchets.

- **Délai de collecte** : Python ne collecte pas immédiatement les objets inutilisés. Cela peut entraîner une accumulation temporaire de mémoire avant que le garbage collector ne se déclenche.

#### **Références faibles et fortes**

- **Référence forte** : C’est la référence classique dans Python. Lorsqu’une variable fait référence à un objet, une **référence forte** est créée. Tant qu’il existe une référence forte à un objet, il ne peut pas être détruit par le garbage collector.
  
- **Référence faible** : Une référence faible permet de référencer un objet sans empêcher son ramassage par le garbage collector. Elle est utilisée lorsque vous souhaitez suivre un objet sans le retenir en mémoire, notamment pour les caches ou les systèmes de mémoire partagée.

  Exemple de référence faible avec `weakref` :

  ```python
  import weakref

  class MyClass:
      pass

  obj = MyClass()
  weak_ref = weakref.ref(obj)

  print(weak_ref())  # Accéder à l'objet via la référence faible
  del obj  # L'objet est détruit ici, même si la référence faible existe
  print(weak_ref())  # Retourne None, car l'objet a été collecté
  ```

Les références faibles sont particulièrement utiles dans les structures de données complexes, comme les caches de mémoire, où vous ne voulez pas empêcher la collecte des objets inutilisés.

#### **Pile d’appels et gestion des ressources**

La **pile d'appels** (call stack) est une structure de données utilisée pour gérer l'exécution des fonctions dans un programme. Chaque fois qu’une fonction est appelée, un nouveau cadre d'appel est ajouté à la pile. Lorsque la fonction se termine, son cadre d'appel est retiré de la pile.

- **Profondeur de la pile** : Python a une taille limitée pour la pile d’appels, ce qui peut entraîner une **recursion infinie** si cette limite est dépassée, générant une erreur `RecursionError`. Vous pouvez ajuster la limite de profondeur via `sys.setrecursionlimit()`.

- **Gestion des ressources** : En Python, la gestion des ressources (comme les fichiers ouverts, les connexions réseau, etc.) est généralement effectuée avec des **gestionnaires de contexte** (context managers) utilisant `with`. Cela garantit que les ressources sont libérées une fois que leur utilisation est terminée, même en cas d'exception.

Exemple de gestion de ressources avec `with` :

```python
with open('file.txt', 'r') as file:
    data = file.read()
# Le fichier est automatiquement fermé ici, même en cas d'exception
```

Le gestionnaire de contexte s’assure que le fichier est fermé une fois la lecture terminée, même si une exception survient pendant le traitement du fichier.

#### **Optimisation des performances avec `timeit`, `cProfile`, etc.**

Pour mesurer et optimiser les performances du code Python, plusieurs outils peuvent être utilisés. Voici les principaux :

##### **`timeit`** : Mesurer le temps d'exécution

Le module `timeit` est utilisé pour mesurer le temps d'exécution de petits morceaux de code. Il est particulièrement utile pour comparer l'efficacité de différentes implémentations d’une même fonction.

Exemple avec `timeit` :

```python
import timeit

# Exemple de code à tester
code = """
a = [1, 2, 3, 4, 5]
b = [x*2 for x in a]
"""

# Mesurer le temps d'exécution
execution_time = timeit.timeit(stmt=code, number=10000)
print(f"Temps d'exécution : {execution_time} secondes")
```

Le paramètre `number` spécifie combien de fois le code doit être exécuté.

##### **`cProfile`** : Profilage de l'exécution

Le module `cProfile` permet d'analyser la performance d'un programme Python en termes de temps d'exécution par fonction. Cela fournit un rapport détaillé sur le temps passé dans chaque fonction.

Exemple de profilage avec `cProfile` :

```python
import cProfile

def test_function():
    sum_ = 0
    for i in range(100000):
        sum_ += i
    return sum_

# Profiling de la fonction
cProfile.run('test_function()')
```

Cela produira une sortie contenant des informations détaillées sur les appels de fonction, le nombre d'appels et le temps total passé dans chaque fonction.

##### **`memory_profiler`** : Profilage de la mémoire

`memory_profiler` est un module tiers qui permet de mesurer l’utilisation de la mémoire par un programme. Cela peut être particulièrement utile pour détecter les fuites de mémoire et optimiser l’utilisation de la mémoire.

Exemple avec `memory_profiler` :

```python
from memory_profiler import profile

@profile
def test_function():
    a = [1] * (10**6)
    b = [2] * (2 * 10**7)
    del b
    return a

test_function()
```

Cela produira des informations sur la mémoire utilisée par chaque ligne de la fonction.

##### **Optimisation par le Code**

Une fois les goulets d'étranglement identifiés à l'aide de `timeit` et `cProfile`, vous pouvez optimiser votre code de plusieurs manières :

1. **Réduire les appels de fonctions** : Les appels de fonctions ont un coût, donc minimisez leur utilisation dans les boucles serrées.
2. **Utilisation de bibliothèques optimisées** : Par exemple, préférez `NumPy` pour les calculs numériques intensifs, car elle utilise des implémentations C en arrière-plan pour des performances accrues.
3. **Structure de données appropriée** : Utilisez les structures de données les plus appropriées, comme les ensembles (`set`) pour les tests d'appartenance rapides, et les dictionnaires (`dict`) pour des recherches efficaces.
4. **Compilateur JIT (Just-in-Time)** : Utilisez `Numba` ou `Cython` pour accélérer les calculs numériques en compilant le code Python en code machine.

#### Conclusion

La gestion de la mémoire et l'optimisation des performances en Python nécessitent une compréhension approfondie des mécanismes internes du langage. En utilisant les outils comme `gc`, `timeit`, `cProfile` et `memory_profiler`, vous pouvez non seulement diagnostiquer les problèmes de performance, mais aussi implémenter des solutions efficaces pour rendre vos programmes plus rapides et plus économes en ressources.

### Chap 2. **Programmation orientée objet avancée**

La programmation orientée objet (POO) est un paradigme de programmation essentiel pour la création de systèmes modulaires et extensibles en Python. Ce chapitre aborde les concepts avancés de la POO, notamment les **métaclasses**, l'**héritage multiple**, la **résolution de méthodes (MRO)**, les **descripteurs**, et l'**abstraction et interfaces**.

#### **Métaclasses**

Les **métaclasses** sont des classes qui définissent le comportement des classes elles-mêmes. En Python, tout est un objet, y compris les classes. Une métaclasse permet de modifier ou personnaliser la création d'une classe.

Les métaclasses sont utilisées pour :
- Modifier la manière dont une classe est créée.
- Ajouter ou modifier des attributs de classe au moment de la définition de la classe.
- Intercepter des appels à la création des classes pour ajouter des comportements supplémentaires.

##### Exemple de métaclasse :

```python
# Définition d'une métaclasse
class Meta(type):
    def __new__(cls, name, bases, dct):
        # Ajoute un attribut 'meta' à toutes les classes créées avec cette métaclasse
        dct['meta'] = 'Métaclasse ajoutée'
        return super().__new__(cls, name, bases, dct)

# Définition d'une classe utilisant la métaclasse
class MyClass(metaclass=Meta):
    pass

obj = MyClass()
print(obj.meta)  # Affiche 'Métaclasse ajoutée'
```

Ici, la métaclasse `Meta` est utilisée pour ajouter un attribut `meta` à toutes les classes qui l’utilisent, comme `MyClass`.

Les métaclasses sont souvent utilisées dans des cas où vous souhaitez avoir un contrôle fin sur la définition des classes, comme pour la création automatique d’attributs, la validation de la structure des classes, ou la gestion de la persistance.

#### **Héritage multiple et résolution de méthodes (MRO)**

L'**héritage multiple** est la capacité d'une classe à hériter de plusieurs classes parente. Cela permet à une classe de combiner les comportements et attributs de plusieurs classes, mais peut également entraîner des ambiguïtés, notamment lorsqu'il existe des méthodes portant le même nom dans plusieurs classes parentes.

##### Exemple d'héritage multiple :

```python
class A:
    def method(self):
        print("Méthode de A")

class B:
    def method(self):
        print("Méthode de B")

class C(A, B):
    pass

obj = C()
obj.method()  # Affiche "Méthode de A" (résolution de méthode selon l'ordre des classes parentes)
```

La **résolution de méthode (MRO)** détermine l'ordre dans lequel les méthodes des classes parentes sont recherchées lors de l’appel d'une méthode. En Python, cela est résolu grâce à un mécanisme appelé **C3 Linearization**.

##### Comment fonctionne la MRO ?
La MRO est l’ordre dans lequel Python recherche les méthodes et attributs dans l’héritage multiple. L’ordre de résolution des méthodes dépend de l'ordre dans lequel les classes sont héritées. 

Vous pouvez consulter la MRO d’une classe en utilisant la méthode `mro()` :

```python
print(C.mro())  # Affiche l'ordre de résolution des méthodes pour la classe C
```

Cela renverra quelque chose comme :
```
[<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]
```

#### **Descripteurs**

Les **descripteurs** sont des objets qui définissent comment un attribut d'une classe doit être accédé, modifié ou supprimé. En Python, un descripteur est un objet qui implémente l’un des trois méthodes suivantes :
- `__get__(self, instance, owner)`
- `__set__(self, instance, value)`
- `__delete__(self, instance)`

Les descripteurs permettent de personnaliser la gestion des attributs d'instance de manière flexible et puissante.

##### Exemple de descripteur :

```python
class Descriptor:
    def __get__(self, instance, owner):
        print(f"Récupération de {self} de {instance}")
        return self.value

    def __set__(self, instance, value):
        print(f"Définition de {self} pour {instance} à {value}")
        self.value = value

class MyClass:
    attribute = Descriptor()

obj = MyClass()
obj.attribute = 42  # Déclenche __set__
print(obj.attribute)  # Déclenche __get__
```

Ici, chaque fois que vous définissez ou accédez à `obj.attribute`, le descripteur intercepte l'accès et le modifie.

Les descripteurs sont couramment utilisés dans les frameworks pour implémenter des comportements comme la gestion de l'accès aux attributs, la validation des valeurs ou la gestion de la persistance (ORMs).

#### **Abstraction et interfaces**

L'**abstraction** consiste à cacher la complexité du système en ne montrant que les informations essentielles. En Python, l'abstraction peut être réalisée à travers des classes abstraites.

Les **interfaces** sont des contrats que les classes doivent respecter. Bien que Python n'ait pas de type `interface` explicite comme Java ou C#, l'abstraction et les interfaces peuvent être créées à l’aide de classes abstraites via le module `abc` (Abstract Base Classes).

##### Exemple d'abstraction avec `abc` :

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14 * self.radius ** 2

# Création d'un objet
circle = Circle(5)
print(circle.area())  # Affiche l'aire du cercle
```

Ici, `Shape` est une classe abstraite avec une méthode `area()` non implémentée. La classe `Circle` est obligée de fournir une implémentation de la méthode `area()`.

##### Pourquoi utiliser l’abstraction ?
- **Modularité** : Vous pouvez créer des interfaces pour les composants de votre application sans vous soucier des détails d’implémentation.
- **Extensibilité** : Les autres classes peuvent hériter de la classe abstraite et fournir des implémentations spécifiques tout en respectant un contrat commun.

#### **Conclusion**

Ces concepts avancés en **programmation orientée objet** vous permettent de créer des applications plus flexibles, maintenables et extensibles. La compréhension et l’utilisation des **métaclasses**, de l'**héritage multiple**, de la **résolution de méthodes (MRO)**, des **descripteurs** et de l'**abstraction** avec des **interfaces** vous donnent un contrôle total sur le comportement des objets et des classes dans vos programmes Python. Ces outils sont particulièrement utiles dans des projets de grande envergure ou pour des frameworks et bibliothèques personnalisées.

### Chap 3. **Fonctionnalités avancées des fonctions**

Les fonctions en Python sont des éléments fondamentaux du langage. En plus de la définition classique de fonctions, Python offre plusieurs fonctionnalités avancées qui permettent une programmation plus flexible, fonctionnelle et concise. Ces fonctionnalités comprennent les **fermetures**, les **décorateurs**, les **fonctions anonymes**, les **arguments variadiques**, le **fonctionnement interne des générateurs** et l’utilisation de **méthodes de fonctions** comme `functools.partial`.

#### **Fermetures (closures)**

Une **fermeture** est une fonction définie à l’intérieur d’une autre fonction et qui peut accéder aux variables de la fonction extérieure même après que celle-ci ait terminé son exécution. Cela est possible parce qu’en Python, les fonctions conservent une **référence** aux variables de leur environnement lorsqu'elles sont créées.

##### Exemple de fermeture :

```python
def outer(x):
    def inner(y):
        return x + y  # La fonction 'inner' se souvient de la variable 'x' de la fonction 'outer'
    return inner

closure = outer(10)
print(closure(5))  # Affiche 15 : 'closure' est une fonction qui utilise la variable 'x' de 'outer'
```

Ici, la fonction `inner` est une fermeture car elle accède à la variable `x` de la fonction `outer`, même après l'exécution de cette dernière.

Les fermetures sont utiles lorsqu'il est nécessaire de retenir l'état (variables) entre les appels de fonction, sans utiliser des variables globales ou des objets.

#### **Décorateurs (decorators)**

Les **décorateurs** sont une manière de modifier ou d'étendre le comportement d'une fonction ou d'une méthode sans la modifier directement. Ils sont des fonctions qui prennent une autre fonction comme argument et retournent une nouvelle fonction.

##### Exemple de décorateur :

```python
def decorator(func):
    def wrapper():
        print("Avant l'appel de la fonction.")
        func()
        print("Après l'appel de la fonction.")
    return wrapper

@decorator
def say_hello():
    print("Bonjour!")

say_hello()
```

Sortie :

```
Avant l'appel de la fonction.
Bonjour!
Après l'appel de la fonction.
```

Le décorateur `decorator` modifie la fonction `say_hello` en ajoutant des messages avant et après son exécution. L'utilisation du symbole `@` permet de « décorer » la fonction de manière concise.

Les décorateurs sont largement utilisés dans les frameworks web comme Flask et Django pour ajouter des comportements comme la gestion des routes HTTP ou la gestion des accès (authentification, permissions, etc.).

#### **Fonctions anonymes (`lambda`)**

Les **fonctions anonymes**, ou **lambda**, sont des fonctions définies sans nom. Elles sont principalement utilisées pour de petites opérations ou pour être passées comme arguments à d'autres fonctions.

##### Exemple de fonction lambda :

```python
add = lambda x, y: x + y
print(add(3, 5))  # Affiche 8
```

Les fonctions `lambda` sont utiles pour écrire des fonctions simples en une ligne sans avoir à définir une fonction classique avec `def`. Elles sont souvent utilisées avec des fonctions comme `map()`, `filter()`, et `sorted()`.

##### Exemple avec `sorted()` :

```python
points = [(1, 2), (4, 3), (2, 5)]
points_sorted = sorted(points, key=lambda x: x[1])  # Trie par le second élément du tuple
print(points_sorted)  # Affiche [(1, 2), (4, 3), (2, 5)]
```

#### **Arguments variadiques (`*args`, `**kwargs`)**

Les **arguments variadiques** permettent de passer un nombre variable d'arguments à une fonction. Python supporte deux types principaux d'arguments variadiques :
- `*args` : pour accepter un nombre variable d'arguments positionnels.
- `**kwargs` : pour accepter un nombre variable d'arguments nommés (mot-clé).

##### Exemple avec `*args` :

```python
def sum_all(*args):
    return sum(args)

print(sum_all(1, 2, 3, 4, 5))  # Affiche 15
```

Ici, `*args` permet de passer n'importe quel nombre d'arguments positionnels à la fonction `sum_all`.

##### Exemple avec `**kwargs` :

```python
def greet(**kwargs):
    print(f"Bonjour {kwargs.get('name', 'inconnu')}!")

greet(name="Alice")  # Affiche "Bonjour Alice!"
greet()  # Affiche "Bonjour inconnu!"
```

Ici, `**kwargs` permet de passer des arguments nommés à la fonction `greet`. Le paramètre `name` est extrait de `kwargs` pour personnaliser le message.

#### **Fonctionnement interne des générateurs et `yield`**

Les **générateurs** sont des fonctions qui permettent de produire une séquence de valeurs au lieu de retourner une seule valeur. Un générateur utilise l'instruction `yield` pour renvoyer une valeur à chaque itération, sans avoir à créer une liste complète en mémoire.

Le fonctionnement interne d'un générateur repose sur l’utilisation de l’itérateur et de l'état conservé entre les appels successifs à `next()`.

##### Exemple de générateur :

```python
def count_up_to(n):
    count = 1
    while count <= n:
        yield count
        count += 1

gen = count_up_to(3)
print(next(gen))  # Affiche 1
print(next(gen))  # Affiche 2
print(next(gen))  # Affiche 3
```

Les générateurs sont très efficaces en termes de gestion mémoire, car ils produisent les éléments un par un, et n'ont pas besoin de tout stocker en mémoire.

##### Exemple avec une boucle `for` :

```python
for number in count_up_to(3):
    print(number)  # Affiche 1, 2, 3
```

Ici, la fonction `count_up_to()` est un générateur, et chaque appel à `next()` ou chaque itération de boucle génère une valeur sans créer de liste complète en mémoire.

#### **Méthodes de fonctions telles que `functools.partial`**

`functools.partial` est une fonction qui permet de fixer certaines parties des arguments d'une fonction, créant ainsi une nouvelle fonction avec moins d'arguments.

##### Exemple avec `functools.partial` :

```python
from functools import partial

def power(base, exp):
    return base ** exp

# Création d'une fonction qui élève un nombre au carré
square = partial(power, exp=2)
print(square(5))  # Affiche 25
```

Ici, `partial` permet de créer une nouvelle fonction `square` qui élève un nombre à la puissance 2, sans avoir à spécifier l'exposant à chaque appel.

#### **Conclusion**

Les fonctionnalités avancées des fonctions en Python, telles que les **fermetures**, les **décorateurs**, les **fonctions anonymes**, les **arguments variadiques**, les **générateurs** et l'utilisation de méthodes de fonctions comme **`functools.partial`**, permettent d'écrire un code plus flexible, concis et puissant. Ces concepts sont largement utilisés pour la programmation fonctionnelle, la gestion dynamique des fonctions, et l'optimisation des performances des applications Python.

### Chap 4. **Gestion des erreurs et des exceptions**

La gestion des erreurs et des exceptions est un aspect essentiel du développement logiciel en Python. Elle permet de gérer les situations inattendues sans interrompre brutalement le programme. Python offre une gestion des exceptions très flexible, permettant de capturer et d'intercepter des erreurs, de définir des exceptions personnalisées et d'utiliser des **gestionnaires de contexte** pour gérer des ressources de manière sécurisée. Ce chapitre couvre les **exceptions personnalisées**, les **gestionnaires de contexte**, la **propagation des exceptions**, et les **assertions avancées**.

#### **Exceptions personnalisées**

Les **exceptions personnalisées** permettent de créer des types d’erreurs spécifiques à l’application. Cela peut être utile lorsque les exceptions standard de Python ne suffisent pas pour décrire un problème particulier dans votre logique métier.

##### Exemple d'exception personnalisée :

```python
class InvalidAgeError(Exception):
    def __init__(self, age):
        super().__init__(f"L'âge {age} n'est pas valide")
        self.age = age

def register_user(age):
    if age < 18:
        raise InvalidAgeError(age)
    print("Utilisateur enregistré.")

try:
    register_user(15)
except InvalidAgeError as e:
    print(f"Erreur : {e}")
```

Sortie :

```
Erreur : L'âge 15 n'est pas valide
```

Dans cet exemple, nous avons défini une exception personnalisée `InvalidAgeError` qui est levée si l’âge d'un utilisateur est inférieur à 18 ans. Cela permet de gérer cette erreur d’une manière plus spécifique et compréhensible pour l’utilisateur.

#### **Context Managers (gestionnaires de contexte avec `with`)**

Les **gestionnaires de contexte** sont utilisés pour gérer des ressources telles que des fichiers ou des connexions réseau de manière sûre. Python utilise le mot-clé `with` pour gérer ces ressources de manière efficace, en s'assurant que les actions nécessaires (comme la fermeture d'un fichier) sont toujours effectuées, même en cas d'exception.

##### Exemple avec un gestionnaire de contexte personnalisé :

```python
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode

    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()
        if exc_type:
            print(f"Exception capturée : {exc_val}")
        return True  # Gérer l'exception (ne pas la propager)

# Utilisation du gestionnaire de contexte
with FileManager('test.txt', 'w') as f:
    f.write("Hello, world!")

# Exemple avec exception
with FileManager('test.txt', 'r') as f:
    f.write("This will raise an error")  # Exception car le fichier est en mode lecture
```

Ici, la classe `FileManager` implémente les méthodes `__enter__` et `__exit__` pour définir le comportement lors de l'entrée et de la sortie du gestionnaire de contexte. Si une exception est levée dans le bloc `with`, celle-ci est capturée, et la méthode `__exit__` est exécutée pour gérer la fermeture du fichier et le contrôle de l'exception.

#### **Propagation des exceptions et contrôle des exceptions**

La **propagation des exceptions** désigne la manière dont les erreurs sont renvoyées d'une fonction à l'autre dans une pile d'appels. Lorsqu'une exception est levée, elle est propagée vers le haut jusqu'à ce qu'elle soit capturée par un bloc `try` approprié ou qu'elle atteigne le sommet de la pile, ce qui entraîne l'arrêt du programme.

##### Exemple de propagation des exceptions :

```python
def function_a():
    raise ValueError("Erreur dans function_a")

def function_b():
    function_a()  # Propagation de l'exception

try:
    function_b()
except ValueError as e:
    print(f"Erreur capturée : {e}")
```

Sortie :

```
Erreur capturée : Erreur dans function_a
```

Ici, l'exception `ValueError` levée dans `function_a` est propagée jusqu’à `function_b` et capturée dans le bloc `try` du programme principal.

##### Exemple de contrôle des exceptions :

Il est possible de capturer des exceptions spécifiques et d'agir différemment selon le type d'exception.

```python
try:
    x = 1 / 0  # Division par zéro
except ZeroDivisionError:
    print("Erreur : division par zéro")
except Exception as e:
    print(f"Autre erreur : {e}")
```

Sortie :

```
Erreur : division par zéro
```

Dans cet exemple, une exception spécifique (`ZeroDivisionError`) est capturée, tandis que les autres erreurs sont capturées par un bloc `except` général.

#### **Assertions avancées**

Les **assertions** sont utilisées pour vérifier si une condition est vraie dans le code. Si l'assertion échoue (la condition est fausse), une exception `AssertionError` est levée. Elles sont souvent utilisées pour les tests et la validation de l'état du programme.

##### Exemple d'assertion :

```python
x = 10
assert x > 5, "x doit être supérieur à 5"

# Exemple avec assertion échouée
y = 3
assert y > 5, "y doit être supérieur à 5"  # Cela va lever une exception AssertionError
```

Sortie :

```
Traceback (most recent call last):
  File "script.py", line 4, in <module>
    assert y > 5, "y doit être supérieur à 5"
AssertionError: y doit être supérieur à 5
```

Les assertions sont désactivées en mode **optimisation** (lorsque Python est lancé avec l'option `-O`), ce qui signifie qu'elles ne doivent pas être utilisées pour la gestion des erreurs dans un environnement de production, mais plutôt pour des vérifications pendant le développement.

##### Assertions avancées avec conditions complexes :

```python
def check_positive(number):
    assert isinstance(number, (int, float)), "Le nombre doit être un entier ou un flottant"
    assert number > 0, "Le nombre doit être positif"

check_positive(10)  # Pas d'exception
check_positive(-10)  # AssertionError: Le nombre doit être positif
```

Ici, les assertions sont utilisées pour valider à la fois le type de la variable et sa valeur.

#### **Conclusion**

La gestion des erreurs et des exceptions est essentielle pour écrire un code robuste et fiable. Python permet de :
- Créer des **exceptions personnalisées** pour gérer des erreurs spécifiques.
- Utiliser des **gestionnaires de contexte** avec `with` pour gérer des ressources comme les fichiers de manière sécurisée.
- Contrôler la **propagation des exceptions** et les intercepter avec des blocs `try-except` spécifiques.
- Utiliser des **assertions** pour valider les conditions et l'intégrité des données en développement.

Maîtriser ces techniques permet de rendre votre code plus lisible, plus facile à maintenir et plus résistant aux erreurs imprévues.

### Chap 5. **Programmation concurrente et parallèle**

La programmation **concurrente** et **parallèle** permet d'exécuter plusieurs tâches de manière simultanée ou intercalée, ce qui peut améliorer les performances et la réactivité des applications. En Python, il existe plusieurs approches pour gérer la concurrence et la parallélisation, chacune ayant ses avantages et ses limites. Cette section couvre le **threading**, l'utilisation du **GIL**, la programmation **asynchrone** avec `asyncio`, le **multiprocessing**, les **futures** et **exécuteurs**, ainsi que la **communication inter-processus (IPC)**.

#### **Threading, GIL et gestion de la concurrence**

Le **threading** en Python permet d'exécuter plusieurs threads (ou fils d'exécution) simultanément, mais il existe une contrainte importante : le **Global Interpreter Lock** (GIL). Le GIL est un mécanisme de synchronisation dans l'interpréteur CPython qui empêche plusieurs threads d'exécuter du code Python en parallèle dans un même processus. Cela signifie que, bien que le threading permette la gestion de la concurrence (par exemple, pour des tâches d'entrée/sortie), il ne peut pas réellement tirer parti des processeurs multicœurs pour le calcul intensif.

##### Exemple de threading :

```python
import threading
import time

def task(id):
    print(f"Tâche {id} démarrée")
    time.sleep(2)
    print(f"Tâche {id} terminée")

threads = []
for i in range(5):
    thread = threading.Thread(target=task, args=(i,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()
```

Dans cet exemple, cinq threads sont créés pour exécuter la fonction `task`. Chaque tâche commence, attend 2 secondes, puis se termine. Grâce au threading, ces tâches sont gérées simultanément, bien que le GIL limite l'exécution parallèle réelle pour les calculs lourds.

##### GIL et calculs intensifs :
En raison du GIL, pour des tâches **calculatoires lourdes**, le **multiprocessing** (plutôt que le threading) est recommandé pour exploiter les processeurs multicœurs.

#### **`asyncio` et programmation asynchrone**

`asyncio` est une bibliothèque Python qui permet de programmer de manière asynchrone, en particulier pour les tâches d'entrée/sortie non bloquantes, comme les requêtes réseau ou les opérations sur les fichiers. L'asynchronie repose sur un modèle de **boucle d'événements**, où un **coroutine** est exécuté à la place d'un thread ou d'un processus, permettant à plusieurs tâches d'être "intercalées" sans bloquer l'exécution du programme.

##### Exemple avec `asyncio` :

```python
import asyncio

async def task(id):
    print(f"Tâche {id} démarrée")
    await asyncio.sleep(2)  # Non-bloquant
    print(f"Tâche {id} terminée")

async def main():
    tasks = [task(i) for i in range(5)]
    await asyncio.gather(*tasks)

# Exécution de la boucle d'événements
asyncio.run(main())
```

Dans cet exemple, les tâches sont exécutées de manière asynchrone, et l'utilisation de `asyncio.sleep()` simule des opérations non bloquantes. L'exécution de toutes les tâches ne nécessite que **une seule unité de travail**, car elles s'intercalent sans bloquer.

#### **Multiprocessing et gestion des processus**

Le **multiprocessing** permet d'exécuter plusieurs processus Python en parallèle, chacun ayant son propre espace mémoire et ne partageant pas le GIL. Cela permet d'exploiter les **processeurs multicœurs** pour des tâches parallèles et calculatoires lourdes, contrairement au threading.

##### Exemple de multiprocessing :

```python
import multiprocessing
import time

def task(id):
    print(f"Tâche {id} démarrée")
    time.sleep(2)
    print(f"Tâche {id} terminée")

if __name__ == '__main__':
    processes = []
    for i in range(5):
        process = multiprocessing.Process(target=task, args=(i,))
        processes.append(process)
        process.start()

    for process in processes:
        process.join()
```

Ici, cinq processus sont créés, chacun exécutant la fonction `task` de manière totalement indépendante. Cette approche utilise plusieurs cœurs du processeur pour exécuter les tâches en parallèle.

#### **Futures et exécuteurs**

Les **futures** et **exécuteurs** sont des abstractions qui permettent de gérer des tâches de manière asynchrone avec des processus ou des threads en arrière-plan. Les **exécuteurs** sont utilisés pour lancer des tâches en parallèle, tandis que les **futures** représentent les résultats à venir de ces tâches.

##### Exemple avec `ThreadPoolExecutor` :

```python
import concurrent.futures
import time

def task(id):
    print(f"Tâche {id} démarrée")
    time.sleep(2)
    return f"Tâche {id} terminée"

with concurrent.futures.ThreadPoolExecutor() as executor:
    results = executor.map(task, range(5))

for result in results:
    print(result)
```

Ici, un **ThreadPoolExecutor** est utilisé pour exécuter les tâches en parallèle, en utilisant plusieurs threads pour gérer les différentes tâches.

##### Exemple avec `ProcessPoolExecutor` :

```python
import concurrent.futures
import time

def task(id):
    print(f"Tâche {id} démarrée")
    time.sleep(2)
    return f"Tâche {id} terminée"

with concurrent.futures.ProcessPoolExecutor() as executor:
    results = executor.map(task, range(5))

for result in results:
    print(result)
```

Le **ProcessPoolExecutor** fonctionne de manière similaire à **ThreadPoolExecutor**, mais utilise des processus distincts, permettant d'exécuter des tâches en parallèle sans être limité par le GIL.

#### **Communication inter-processus (IPC)**

La **communication inter-processus (IPC)** permet aux différents processus d'échanger des informations. En Python, plusieurs mécanismes existent pour faciliter cette communication, tels que les **pipes**, les **queues** et les **partages de mémoire**.

##### Exemple avec `multiprocessing.Queue` :

```python
import multiprocessing
import time

def worker(queue):
    time.sleep(2)
    queue.put("Tâche terminée")

if __name__ == '__main__':
    queue = multiprocessing.Queue()
    process = multiprocessing.Process(target=worker, args=(queue,))
    process.start()
    result = queue.get()  # Attente du résultat
    print(result)
    process.join()
```

Ici, une **queue** est utilisée pour transmettre des données entre le processus parent et le processus enfant. Le processus enfant met un résultat dans la queue, qui est ensuite récupéré par le processus principal.

#### **Conclusion**

La **programmation concurrente** et **parallèle** en Python permet d'optimiser les performances, en particulier pour les tâches d'entrée/sortie ou les calculs lourds. Python offre différentes approches, selon les besoins du programme :
- **Threading** : Utilisé pour la gestion des tâches légères et d’entrée/sortie, mais limité par le GIL.
- **`asyncio`** : Idéal pour la programmation asynchrone et les opérations non-bloquantes.
- **Multiprocessing** : Permet l’exécution de tâches parallèles indépendantes, en tirant parti des processeurs multicœurs.
- **Futures et exécuteurs** : Facilite la gestion des tâches parallèles avec des abstractions simples.
- **IPC** : Permet l’échange de données entre processus.

Chaque technique a ses avantages et ses cas d’utilisation spécifiques, et il est crucial de comprendre quand et comment les appliquer pour obtenir des performances optimales.

### Chap 6. **Gestion des entrées-sorties et des fichiers**

La gestion des **entrées-sorties (I/O)** en Python joue un rôle fondamental pour interagir avec des fichiers, des bases de données, des périphériques, ainsi que pour la communication réseau. Elle peut être synchrone ou asynchrone, et implique diverses méthodes pour optimiser la performance et garantir une gestion correcte des ressources.

#### **Lecture et écriture non bloquantes**

La lecture et l’écriture **non bloquantes** font référence aux opérations où l'exécution du programme ne s'arrête pas en attendant que l'I/O soit terminée. En Python, ces opérations sont souvent réalisées avec l’aide de **`asyncio`** pour gérer les I/O de manière asynchrone.

- **Lecture/écriture bloquantes** : Par défaut, la lecture ou l’écriture d’un fichier ou d'une entrée-sortie réseau bloque l'exécution du programme jusqu'à ce que l'opération soit terminée.
- **Lecture/écriture non bloquantes** : En utilisant des bibliothèques comme `asyncio`, la lecture/écriture peut être effectuée sans bloquer l'exécution du programme.

##### Exemple avec `asyncio` pour la lecture/écriture non bloquantes :

```python
import asyncio

async def read_file(filename):
    with open(filename, 'r') as f:
        content = f.read()
        print(content)

async def write_file(filename, text):
    with open(filename, 'w') as f:
        f.write(text)
        print("Fichier écrit")

async def main():
    await asyncio.gather(read_file("file.txt"), write_file("file.txt", "Bonjour, monde!"))

# Exécution de la boucle d'événements asynchrone
asyncio.run(main())
```

Dans cet exemple, nous utilisons `asyncio` pour lire et écrire dans des fichiers de manière non bloquante, ce qui permet d'exécuter plusieurs opérations de manière parallèle. Cependant, notez que l'accès aux fichiers reste synchrone dans cet exemple ; des modules spécialisés (comme `aiofiles`) sont nécessaires pour l'I/O réelle non bloquante.

#### **Manipulation des fichiers binaires**

La manipulation des fichiers **binaires** permet de lire et écrire des données dans des formats non textuels, comme des images, des vidéos, ou des fichiers compressés. En Python, les fichiers binaires sont ouverts avec le mode `'rb'` pour la lecture et `'wb'` pour l'écriture.

##### Exemple de lecture/écriture de fichiers binaires :

```python
# Lecture d'un fichier binaire
with open("image.png", "rb") as file:
    data = file.read()

# Écriture dans un fichier binaire
with open("copy_image.png", "wb") as file:
    file.write(data)
```

Ici, nous ouvrons un fichier binaire en mode lecture (`rb`) et nous copions son contenu dans un autre fichier en mode écriture binaire (`wb`).

#### **Streams et buffers**

Les **streams** sont des abstractions permettant de gérer la lecture et l'écriture de données de manière continue. En Python, les streams sont associés à des **buffers**, qui sont des zones mémoire utilisées pour stocker temporairement les données avant qu'elles ne soient lues ou écrites.

- Un **buffer** est un espace mémoire où les données sont accumulées avant d'être envoyées ou lues.
- Les **streams** permettent de traiter ces données de manière séquentielle, en envoyant ou recevant des blocs de données à la fois.

##### Exemple d'utilisation d'un buffer avec `io` :

```python
import io

# Créer un buffer en mémoire
buffer = io.BytesIO()

# Écrire dans le buffer
buffer.write(b"Exemple de données binaires")

# Lire depuis le buffer
buffer.seek(0)  # Se placer au début du buffer
print(buffer.read())  # Affiche: b'Exemple de données binaires'
```

Dans cet exemple, `io.BytesIO` permet de créer un buffer en mémoire où nous écrivons et lisons des données binaires comme si c'était un fichier.

#### **Sockets et réseaux**

Les **sockets** sont utilisés pour permettre la communication entre différents processus, souvent sur des machines différentes. Les sockets peuvent être utilisés pour la communication via TCP ou UDP et sont un moyen fondamental pour établir des connexions réseau en Python.

- **Sockets TCP** : Utilisés pour les connexions fiables, garantissant que les données arrivent dans le bon ordre.
- **Sockets UDP** : Utilisés pour les connexions sans connexion et plus rapides, mais sans garantie de livraison des données.

##### Exemple de serveur TCP avec `socket` :

```python
import socket

# Créer un socket TCP
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind(("localhost", 12345))
server_socket.listen(1)

print("Serveur en attente de connexions...")
client_socket, client_address = server_socket.accept()

print(f"Connexion de {client_address}")

# Recevoir et envoyer des données
message = client_socket.recv(1024)
print(f"Message reçu: {message.decode()}")
client_socket.sendall("Réponse du serveur".encode())

client_socket.close()
server_socket.close()
```

Dans cet exemple, un serveur TCP écoute sur le port 12345 et attend des connexions de clients. Lorsqu'une connexion est établie, il reçoit un message, puis répond.

##### Exemple de client TCP avec `socket` :

```python
import socket

# Créer un socket TCP
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client_socket.connect(("localhost", 12345))

# Envoyer un message
client_socket.sendall("Hello, serveur!".encode())

# Recevoir la réponse
response = client_socket.recv(1024)
print(f"Réponse reçue: {response.decode()}")

client_socket.close()
```

Le client TCP se connecte au serveur sur `localhost` à travers le port 12345, envoie un message et attend une réponse du serveur.

#### **Conclusion**

La gestion des entrées-sorties et des fichiers est essentielle pour de nombreuses applications Python, notamment celles impliquant des fichiers, des données binaires, ou la communication réseau. Voici un résumé des concepts clés :

- **Lecture et écriture non bloquantes** : Permet d'effectuer des opérations d'I/O sans bloquer l'exécution du programme, souvent avec `asyncio` ou des bibliothèques spécialisées.
- **Fichiers binaires** : Manipulation des données non textuelles en utilisant des modes de fichiers binaires (`rb`, `wb`).
- **Streams et buffers** : Utilisation de buffers en mémoire pour manipuler des flux de données de manière efficace et continue.
- **Sockets et réseaux** : Facilite la communication réseau via TCP ou UDP, permettant l'échange de données entre différentes machines ou processus.

Ces techniques permettent de gérer efficacement les ressources d'I/O, en particulier lorsque l'on travaille avec des fichiers de grande taille ou des applications réseau.

### Chap 7. **Structures de données avancées**

Les **structures de données** avancées sont essentielles pour optimiser les performances et résoudre des problèmes complexes. Python offre plusieurs types de structures adaptées à des situations spécifiques. Ce chapitre aborde les collections spécialisées, les structures immuables et les structures d'arbres et de graphes.

#### **Collections spécialisées**

Python fournit plusieurs collections spécialisées qui sont des alternatives optimisées aux structures de données classiques comme les listes et les dictionnaires.

##### **`deque` (Double-Ended Queue)**

Le `deque` est une **queue doublement terminée**. Il permet d'ajouter et de retirer des éléments à partir de chaque extrémité (avant ou arrière), offrant des opérations de temps constant (O(1)).

- **Utilisation** : Il est particulièrement utile pour les files d'attente ou les piles où les ajouts et les suppressions doivent se produire aux deux extrémités.

###### Exemple d'utilisation de `deque` :

```python
from collections import deque

# Créer un deque
queue = deque([1, 2, 3])

# Ajouter des éléments
queue.append(4)  # Ajoute à la fin
queue.appendleft(0)  # Ajoute au début

# Retirer des éléments
queue.pop()  # Retire à la fin
queue.popleft()  # Retire au début

print(queue)  # Affiche deque([1, 2, 3])
```

##### **`Counter`**

`Counter` est une sous-classe de `dict` qui est utilisée pour compter les éléments. Il crée un dictionnaire où les clés sont les éléments de la collection et les valeurs sont leur nombre d'occurrences.

- **Utilisation** : Pratique pour compter les fréquences des éléments dans une liste ou une chaîne de caractères.

###### Exemple d'utilisation de `Counter` :

```python
from collections import Counter

# Créer un Counter
text = "hello world"
counter = Counter(text)

# Afficher les occurrences
print(counter)  # Affiche Counter({'l': 3, 'o': 2, 'h': 1, 'e': 1, ' ': 1, 'w': 1, 'r': 1, 'd': 1})
```

##### **`defaultdict`**

`defaultdict` est une sous-classe de `dict` qui fournit une valeur par défaut pour les clés inexistantes. Cela évite d'avoir à tester si une clé existe avant d'ajouter une valeur.

- **Utilisation** : Pratique pour des dictionnaires où chaque valeur nécessite une initialisation spécifique, par exemple, une liste vide ou un entier.

###### Exemple d'utilisation de `defaultdict` :

```python
from collections import defaultdict

# Créer un defaultdict avec une valeur par défaut de liste
default_dict = defaultdict(list)

# Ajouter des éléments
default_dict["a"].append(1)
default_dict["b"].append(2)

# Afficher
print(default_dict)  # Affiche defaultdict(<class 'list'>, {'a': [1], 'b': [2]})
```

##### **`namedtuple`**

`namedtuple` est une fonction qui crée des objets immutables qui sont accessibles par des attributs nommés au lieu de l'indexation. C'est une alternative plus légère à l'utilisation de classes pour de simples structures de données.

- **Utilisation** : Pratique pour les structures de données où chaque élément a un nom bien défini (comme une structure ou un enregistrement).

###### Exemple d'utilisation de `namedtuple` :

```python
from collections import namedtuple

# Définir un namedtuple
Point = namedtuple('Point', ['x', 'y'])

# Créer une instance
p = Point(3, 4)

# Accéder aux attributs
print(p.x, p.y)  # Affiche: 3 4
```

#### **Structures immuables**

Les structures de données immuables sont celles dont l'état ne peut être modifié après leur création. Elles sont utiles pour garantir que des données partagées ne peuvent pas être modifiées par accident, ce qui permet de maintenir l'intégrité des données.

##### **`frozenset`**

Un `frozenset` est une version immuable d'un `set`. Cela signifie qu'une fois que les éléments sont ajoutés à un `frozenset`, ils ne peuvent pas être modifiés (pas d'ajout, suppression, ou mise à jour).

- **Utilisation** : Pratique lorsque vous avez besoin d'un ensemble immuable et que vous souhaitez l'utiliser comme clé dans un dictionnaire (car un `set` classique n'est pas hashable).

###### Exemple d'utilisation de `frozenset` :

```python
# Créer un frozenset
frozen_set = frozenset([1, 2, 3])

# Afficher
print(frozen_set)  # Affiche frozenset({1, 2, 3})

# Tentative de modification (cela échouera)
# frozen_set.add(4)  # Lève une exception : 'frozenset' object has no attribute 'add'
```

##### **Tuples**

Un **tuple** est une structure de données immuable qui peut contenir plusieurs éléments. Contrairement aux listes, une fois un tuple créé, ses éléments ne peuvent pas être modifiés.

- **Utilisation** : Idéal pour les données qui ne doivent pas changer, comme les coordonnées géographiques, ou pour des clés de dictionnaire.

###### Exemple d'utilisation de `tuple` :

```python
# Créer un tuple
t = (1, 2, 3)

# Accéder aux éléments
print(t[0])  # Affiche 1

# Tentative de modification (cela échouera)
# t[0] = 10  # Lève une exception : 'tuple' object does not support item assignment
```

#### **Structures d'arbres, graphes et autres structures personnalisées**

Les **arbres** et les **graphes** sont des structures complexes utilisées dans des algorithmes comme les parcours de graphes, les arbres binaires de recherche, et d'autres applications complexes.

##### **Arbre binaire de recherche (Binary Search Tree, BST)**

Un **arbre binaire** est une structure dans laquelle chaque nœud a au maximum deux enfants. Dans un **arbre binaire de recherche**, les valeurs à gauche d'un nœud sont plus petites et celles à droite sont plus grandes.

###### Exemple d'implémentation d'un arbre binaire de recherche :

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    def insert(self, value):
        if self.root is None:
            self.root = Node(value)
        else:
            self._insert(self.root, value)

    def _insert(self, current, value):
        if value < current.value:
            if current.left is None:
                current.left = Node(value)
            else:
                self._insert(current.left, value)
        else:
            if current.right is None:
                current.right = Node(value)
            else:
                self._insert(current.right, value)

# Exemple d'utilisation
tree = BST()
tree.insert(10)
tree.insert(5)
tree.insert(15)
```

##### **Graphes (non orientés, orientés)**

Un **graphe** est une collection de nœuds (ou sommets) reliés par des arêtes. Un graphe peut être orienté (les arêtes ont une direction) ou non orienté. Un exemple simple peut être un graphe non orienté.

###### Exemple d'implémentation d'un graphe :

```python
class Graph:
    def __init__(self):
        self.graph = {}

    def add_edge(self, u, v):
        if u not in self.graph:
            self.graph[u] = []
        if v not in self.graph:
            self.graph[v] = []
        self.graph[u].append(v)
        self.graph[v].append(u)  # pour un graphe non orienté

# Exemple d'utilisation
g = Graph()
g.add_edge(1, 2)
g.add_edge(1, 3)
g.add_edge(2, 4)

print(g.graph)  # Affiche: {1: [2, 3], 2: [1, 4], 3: [1], 4: [2]}
```

#### **Conclusion**

Les structures de données avancées en Python sont essentielles pour résoudre des problèmes complexes de manière efficace. Elles permettent d’optimiser l'espace mémoire et les performances en fonction des besoins spécifiques de l'application. Voici un résumé des concepts abordés :

- **Collections spécialisées** (`deque`, `Counter`, `defaultdict`, `namedtuple`) pour des cas d'utilisation spécifiques, comme les files d'attente, les comptages d'occurrences, et les dictionnaires avec valeurs par défaut.
- **Structures immuables** (`frozenset`, `tuple`) pour garantir l'intégrité des données et les utiliser comme clés dans des dictionnaires.
- **Structures d'arbres et de graphes** pour la représentation et la gestion des données en hiérarchie ou en réseau.

Ces structures sont essentielles pour écrire des applications efficaces, surtout quand les données doivent être manipulées de manière complexe.

### Chap 8. **Tests et qualité du code**

Les tests et la gestion de la qualité du code sont des éléments essentiels pour garantir que le code est fiable, maintenable et performant. Dans cette section, nous aborderons différents types de tests, les outils utilisés pour les implémenter, et les pratiques courantes pour assurer une qualité de code optimale.

#### **Tests unitaires avec `unittest`, `pytest`, et `nose`**

Les tests unitaires sont des tests qui valident de manière isolée les plus petites unités de code (souvent des fonctions ou des méthodes). Ils permettent de vérifier que chaque composant de votre application fonctionne correctement indépendamment des autres.

##### **`unittest`**

`unittest` est la bibliothèque standard de Python pour effectuer des tests unitaires. Elle fournit une structure de base pour créer des tests et des assertions.

- **Fonctionnalité principale** : 
   - Permet de définir des tests dans des classes héritées de `unittest.TestCase`.
   - Fournit des méthodes d'assertion comme `assertEqual`, `assertTrue`, etc.
   - Permet d'exécuter des tests via la commande `python -m unittest`.

###### Exemple avec `unittest` :

```python
import unittest

def add(a, b):
    return a + b

class TestMathOperations(unittest.TestCase):
    def test_add(self):
        self.assertEqual(add(2, 3), 5)
        self.assertEqual(add(-1, 1), 0)

if __name__ == '__main__':
    unittest.main()
```

##### **`pytest`**

`pytest` est un framework de test très populaire en Python, connu pour sa simplicité et sa flexibilité. Il permet de structurer les tests sans avoir besoin de classes. `pytest` est également capable d'exécuter les tests définis avec `unittest` et offre une meilleure gestion des erreurs et des rapports de tests.

- **Fonctionnalité principale** :
   - Tests simples sans besoin de classes.
   - Supporte les fixtures, les assertions améliorées et les plugins pour étendre ses fonctionnalités.
   - Permet d'exécuter des tests avec `pytest`.

###### Exemple avec `pytest` :

```python
# Fonction à tester
def add(a, b):
    return a + b

# Test avec pytest
def test_add():
    assert add(2, 3) == 5
    assert add(-1, 1) == 0
```
Exécuter avec la commande : `pytest`.

##### **`nose`**

`nose` est un autre framework de test qui simplifie l'écriture des tests et l'exécution des suites de tests. Bien que moins populaire que `pytest`, il offre aussi des fonctionnalités avancées, comme la découverte automatique des tests.

- **Fonctionnalité principale** : 
   - Découverte automatique des tests dans le répertoire.
   - Extensions pour ajouter des fonctionnalités personnalisées.
   
###### Exemple avec `nose` :

```python
# Fonction à tester
def add(a, b):
    return a + b

# Test avec nose
def test_add():
    assert add(2, 3) == 5
    assert add(-1, 1) == 0
```
Exécuter avec la commande : `nosetests`.

#### **Tests de performance**

Les tests de performance permettent de mesurer l'efficacité du code, en particulier les aspects liés à la vitesse d'exécution, à l'utilisation de la mémoire et aux limites des performances dans des scénarios de charge.

##### **`timeit`**

`timeit` est un module Python qui permet de mesurer de manière précise le temps d'exécution de petits morceaux de code. Il fournit une méthode pour éviter les erreurs dues aux optimisations internes de l'interpréteur Python.

- **Fonctionnalité principale** : 
   - Permet de mesurer le temps d'exécution d'un morceau de code dans des conditions contrôlées.
   - Peut être utilisé en ligne de commande ou dans le code Python.

###### Exemple d'utilisation de `timeit` :

```python
import timeit

# Code à tester
code_to_test = """
def add(a, b):
    return a + b
add(2, 3)
"""

# Mesurer le temps d'exécution
execution_time = timeit.timeit(code_to_test, number=1000)
print(f"Temps d'exécution : {execution_time} secondes")
```

##### **`cProfile`**

`cProfile` est un module de profilage qui permet d'analyser la performance de votre code à un niveau plus détaillé, en suivant les appels de fonction et leur temps d'exécution.

- **Fonctionnalité principale** :
   - Permet de profiler le code pour identifier les fonctions lentes.
   - Fournit un rapport détaillé sur les appels de fonction et le temps passé dans chaque fonction.

###### Exemple d'utilisation de `cProfile` :

```python
import cProfile

def slow_function():
    for _ in range(100000):
        pass

cProfile.run('slow_function()')
```

#### **Tests de couverture (coverage)**

Les tests de couverture permettent de vérifier quelle proportion du code est effectivement testée par les tests unitaires. Ils sont essentiels pour s'assurer qu'un maximum de chemins du programme sont couverts par les tests.

##### **`coverage.py`**

`coverage.py` est un outil permettant de mesurer la couverture des tests, en indiquant quelles lignes de code ont été exécutées pendant les tests.

- **Fonctionnalité principale** : 
   - Fournit un rapport de couverture qui montre les lignes de code non couvertes par les tests.
   - Peut être intégré à des outils CI/CD pour évaluer la couverture pendant les processus d'intégration continue.

###### Exemple d'utilisation de `coverage.py` :

```bash
# Exécuter les tests avec coverage
coverage run -m unittest discover

# Générer un rapport de couverture
coverage report -m
```

#### **CI/CD et intégration continue**

L'intégration continue (CI) et la livraison continue (CD) sont des pratiques de développement où les modifications du code sont fréquemment intégrées et testées. Cela permet d'assurer une qualité de code élevée en automatisant les tests, la construction et la livraison.

##### **CI/CD avec GitHub Actions, Travis CI, Jenkins**

Les outils CI/CD automatisent les processus de tests, de build et de déploiement. Les tests sont lancés automatiquement à chaque modification de code (push) ou à la création de nouvelles branches.

- **Fonctionnalité principale** : 
   - Exécuter automatiquement les tests sur chaque commit ou pull request.
   - Déployer automatiquement une nouvelle version de l'application si les tests passent.

###### Exemple avec GitHub Actions (fichier `.github/workflows/test.yml`) :

```yaml
name: Python CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.8'
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    - name: Run tests
      run: |
        pytest
```

#### **Conclusion**

La qualité du code et les tests sont des aspects clés de tout projet Python bien géré. En utilisant les outils comme `unittest`, `pytest`, `nose`, `timeit`, `coverage`, et en intégrant des pratiques d'intégration continue (CI/CD), vous pouvez garantir que votre code est robuste, performant, et maintenable.

- **Tests unitaires** : Vérifient l'intégrité de chaque unité du code.
- **Tests de performance** : Mesurent l'efficacité du code.
- **Tests de couverture** : Vérifient quelles parties du code sont couvertes par les tests.
- **CI/CD** : Automatisent les tests et les déploiements pour garantir un flux de travail fluide et fiable.

### Chap 10. **Bibliothèques avancées**

Dans cette section, nous allons explorer plusieurs bibliothèques avancées en Python qui sont largement utilisées dans des domaines variés tels que le traitement de données, le développement web, le machine learning, et l'interaction avec des bases de données. Ces bibliothèques permettent d'étendre les fonctionnalités de Python, de manière performante et flexible.

#### **1. Utilisation de bibliothèques comme `NumPy`, `Pandas`, `Django`, `Flask` pour les applications de données et web**

##### **`NumPy`** (pour les calculs numériques et les matrices)
`NumPy` est une bibliothèque fondamentale pour les calculs scientifiques en Python. Elle introduit des objets de type `ndarray` (tableaux multidimensionnels) et fournit une grande variété de fonctions pour effectuer des calculs sur ces structures.

- **Fonctionnalités principales** :
   - Manipulation efficace des tableaux multidimensionnels.
   - Fonctions mathématiques (opérations sur les vecteurs et matrices, etc.).
   - Génération de nombres aléatoires.
   - Intégration avec d'autres bibliothèques comme `Pandas`, `SciPy`, et `Matplotlib`.

###### Exemple avec `NumPy` :

```python
import numpy as np

# Création d'un tableau numpy
array = np.array([1, 2, 3, 4])

# Effectuer des opérations sur le tableau
array = array * 2  # Multiplie chaque élément par 2

# Calculer la somme des éléments d'un tableau 2D
array_2d = np.array([[1, 2], [3, 4]])
print(np.sum(array_2d))  # Affiche 10
```

##### **`Pandas`** (pour la gestion des données tabulaires)
`Pandas` est une bibliothèque pour la manipulation et l'analyse des données, particulièrement adaptée aux données sous forme de tableaux (comme les fichiers CSV ou Excel). Elle introduit les structures de données `DataFrame` et `Series`.

- **Fonctionnalités principales** :
   - Manipulation efficace des données tabulaires avec `DataFrame`.
   - Chargement, nettoyage, et transformation des données.
   - Statistiques descriptives et agrégations de données.
   - Fusion et jointure de jeux de données.

###### Exemple avec `Pandas` :

```python
import pandas as pd

# Charger un fichier CSV
df = pd.read_csv('data.csv')

# Afficher les 5 premières lignes
print(df.head())

# Calculer des statistiques descriptives
print(df.describe())

# Appliquer une transformation
df['age'] = df['age'] * 2
```

##### **`Django` et `Flask`** (pour le développement web)

- **`Django`** : Un framework web de haut niveau qui permet de créer des applications web rapidement et de manière sécurisée. Il inclut des fonctionnalités telles que l'authentification, la gestion des sessions, et l'accès à la base de données via un ORM intégré.

- **Fonctionnalités principales de `Django`** :
   - Modèles de données (ORM).
   - Gestion des vues et des URL.
   - Administration automatique.
   - Système de templating.
   - Sécurisation des applications (protection contre les attaques courantes).

###### Exemple avec `Django` :

```python
# Exemple simple d'un modèle Django
from django.db import models

class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()

# Créer une vue
from django.http import HttpResponse
def home(request):
    return HttpResponse("Bienvenue sur le site")
```

- **`Flask`** : Un framework micro-web plus léger que `Django`, qui offre plus de flexibilité et qui est souvent utilisé pour des applications simples ou des API RESTful.

- **Fonctionnalités principales de `Flask`** :
   - Simplicité et flexibilité.
   - Système de routage léger.
   - Gestion des requêtes HTTP.
   - Facilité d'intégration avec des bases de données et d'autres bibliothèques.

###### Exemple avec `Flask` :

```python
from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello, World!'

if __name__ == '__main__':
    app.run()
```

#### **2. Frameworks de tests (`pytest`, `hypothesis`)**

##### **`pytest`** (pour les tests unitaires)
`pytest` est un framework de tests très populaire en Python. Il permet d'écrire des tests unitaires de manière simple, avec une syntaxe facile à comprendre, tout en fournissant une grande flexibilité pour les tests plus complexes.

- **Fonctionnalités principales** :
   - Découverte automatique des tests.
   - Prise en charge des fixtures pour préparer les tests.
   - Gestion des assertions simples et personnalisées.
   - Possibilité d'exécuter des tests parallèles avec `pytest-xdist`.

###### Exemple avec `pytest` :

```python
# Test simple avec pytest
def test_addition():
    assert 1 + 1 == 2
```

##### **`hypothesis`** (pour les tests basés sur des propriétés)
`hypothesis` est un framework pour effectuer des tests basés sur des propriétés, où l'on spécifie des propriétés à tester et où les valeurs des tests sont générées automatiquement. Cela permet de détecter des bugs qui n'auraient peut-être pas été envisagés dans les tests traditionnels.

###### Exemple avec `hypothesis` :

```python
from hypothesis import given
from hypothesis.strategies import integers

@given(integers())
def test_addition(x):
    assert x + 1 > x
```

#### **3. Gestion de bases de données (ORM, SQLAlchemy, etc.)**

##### **SQLAlchemy** (ORM pour les bases de données relationnelles)
`SQLAlchemy` est une bibliothèque puissante qui permet de gérer les bases de données relationnelles via un ORM (Object-Relational Mapping). Il permet de mapper des objets Python à des tables SQL et d'effectuer des requêtes de manière orientée objet.

- **Fonctionnalités principales** :
   - Création de tables et gestion des relations (1-N, N-N).
   - Requêtes SQL via un langage de requêtes Python.
   - Transitions entre bases de données via une interface de base de données unifiée.

###### Exemple avec `SQLAlchemy` :

```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)

# Connexion à une base de données SQLite
engine = create_engine('sqlite:///:memory:')
Base.metadata.create_all(engine)

Session = sessionmaker(bind=engine)
session = Session()

# Ajouter un utilisateur
new_user = User(name="Alice")
session.add(new_user)
session.commit()

# Requête
user = session.query(User).filter_by(name="Alice").first()
print(user.name)
```

#### **4. Traitement d'image et machine learning**

##### **`TensorFlow` et `PyTorch`** (pour le deep learning)
`TensorFlow` et `PyTorch` sont deux des bibliothèques les plus utilisées pour le machine learning et le deep learning. Elles permettent de définir, d’entraîner et de déployer des modèles de réseaux de neurones.

- **Fonctionnalités principales** :
   - Création de modèles de deep learning (réseaux de neurones convolutifs, récurrents, etc.).
   - Optimisation des modèles avec des algorithmes d'optimisation comme Adam, SGD, etc.
   - Gestion des GPU et calculs distribués.

###### Exemple avec `TensorFlow` :

```python
import tensorflow as tf

# Créer un modèle simple
model = tf.keras.Sequential([
    tf.keras.layers.Dense(32, activation='relu', input_shape=(784,)),
    tf.keras.layers.Dense(10, activation='softmax')
])

# Compiler le modèle
model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])
```

##### **`scikit-learn`** (pour le machine learning classique)
`scikit-learn` est une bibliothèque de machine learning qui permet de travailler avec des modèles statistiques et d'apprentissage supervisé/non supervisé.

- **Fonctionnalités principales** :
   - Régressions, classification, clustering, réduction de dimensions.
   - Validation croisée et évaluation des modèles.
   - Pipelines pour automatiser les transformations des données et l’entraînement des modèles.

###### Exemple avec `scikit-learn` :

```python
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier

# Charger les données
iris = load_iris()
X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=0.2)

# Entraîner un modèle
clf = RandomForestClassifier()
clf.fit(X_train, y_train)

# Prédire avec le modèle
print(clf.predict(X_test))
```

#### **Conclusion**

Les bibliothèques avancées de Python, comme `NumPy`, `Pandas`, `Django`, `Flask`, `TensorFlow`, `PyTorch`, `SQLAlchemy`, et bien d'autres, sont essentielles pour le développement d'applications complexes et performantes. Elles couvrent des domaines

 variés allant des calculs numériques, au machine learning, au développement web, jusqu'à la gestion des bases de données.

### Chap 11. **Modèles et Design Patterns**

Les **design patterns** (ou modèles de conception) sont des solutions éprouvées à des problèmes récurrents rencontrés lors de la conception de logiciels. Ces solutions peuvent être réutilisées dans différents contextes, ce qui facilite le développement, améliore la lisibilité du code et permet de résoudre des problèmes complexes de manière efficace et maintenable. 

Voici les **principaux design patterns** à connaître, avec des explications détaillées sur leur fonctionnement et des exemples d'implémentation en Python.

#### **1. Singleton Pattern**
Le **Singleton** est un pattern de création qui garantit qu'une classe n'a qu'une seule instance et fournit un point d'accès global à cette instance.

- **But** : Empêcher la création de plusieurs instances d'une même classe.
- **Utilisation typique** : Lorsque vous voulez une seule instance pour gérer des ressources globales (par exemple, une connexion à une base de données).

###### Implémentation du Singleton en Python :

```python
class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(Singleton, cls).__new__(cls)
        return cls._instance

# Utilisation
obj1 = Singleton()
obj2 = Singleton()

print(obj1 is obj2)  # Affiche True, les deux objets sont la même instance
```

#### **2. Factory Pattern**
Le **Factory Pattern** est un pattern de création qui fournit une méthode pour créer des objets sans spécifier la classe exacte de l'objet qui sera créé.

- **But** : Permet de créer des objets sans exposer la logique de création à l'utilisateur et en déléguant cette tâche à une fonction ou une méthode.
- **Utilisation typique** : Lorsque vous avez des objets similaires mais qui nécessitent des constructions spécifiques.

###### Implémentation du Factory en Python :

```python
class Car:
    def drive(self):
        return "Conduire une voiture"

class Bike:
    def drive(self):
        return "Conduire une moto"

class VehicleFactory:
    @staticmethod
    def get_vehicle(vehicle_type):
        if vehicle_type == "car":
            return Car()
        elif vehicle_type == "bike":
            return Bike()

# Utilisation
vehicle = VehicleFactory.get_vehicle("car")
print(vehicle.drive())  # Affiche "Conduire une voiture"
```

#### **3. Observer Pattern**
Le **Observer Pattern** est un pattern comportemental qui permet à un objet de notifier d'autres objets lorsque son état change, sans connaître les détails des objets qui seront notifiés.

- **But** : Permet de créer un système de notifications où un changement dans un objet peut entraîner une mise à jour automatique des objets observateurs.
- **Utilisation typique** : Idéal pour les applications où plusieurs objets doivent être informés des changements d'état d'un autre objet (exemple : interfaces utilisateur, systèmes de notification).

###### Implémentation de l'Observer en Python :

```python
class Observer:
    def update(self, message):
        pass

class ConcreteObserver(Observer):
    def __init__(self, name):
        self.name = name

    def update(self, message):
        print(f"{self.name} a reçu le message: {message}")

class Subject:
    def __init__(self):
        self._observers = []

    def add_observer(self, observer):
        self._observers.append(observer)

    def remove_observer(self, observer):
        self._observers.remove(observer)

    def notify(self, message):
        for observer in self._observers:
            observer.update(message)

# Utilisation
subject = Subject()
observer1 = ConcreteObserver("Observateur 1")
observer2 = ConcreteObserver("Observateur 2")

subject.add_observer(observer1)
subject.add_observer(observer2)

subject.notify("État changé")
# Affiche :
# Observateur 1 a reçu le message: État changé
# Observateur 2 a reçu le message: État changé
```

#### **4. Strategy Pattern**
Le **Strategy Pattern** est un pattern comportemental qui permet de définir une famille d'algorithmes, de les encapsuler et de les rendre interchangeables. Le comportement d'un objet peut ainsi être modifié au moment de l'exécution.

- **But** : Permet de varier les algorithmes d'un objet sans modifier son code.
- **Utilisation typique** : Lorsque vous avez plusieurs façons d'effectuer une même tâche, mais que vous souhaitez pouvoir alterner dynamiquement entre ces différentes méthodes.

###### Implémentation du Strategy en Python :

```python
class SortStrategy:
    def sort(self, data):
        pass

class QuickSort(SortStrategy):
    def sort(self, data):
        return sorted(data)  # Implémentation simplifiée de QuickSort

class BubbleSort(SortStrategy):
    def sort(self, data):
        # Implémentation simplifiée de BubbleSort
        for i in range(len(data)):
            for j in range(len(data)-i-1):
                if data[j] > data[j+1]:
                    data[j], data[j+1] = data[j+1], data[j]
        return data

class Context:
    def __init__(self, strategy: SortStrategy):
        self._strategy = strategy

    def execute_strategy(self, data):
        return self._strategy.sort(data)

# Utilisation
data = [5, 3, 8, 6, 7]
context = Context(QuickSort())
print(context.execute_strategy(data))  # Utilise QuickSort

context = Context(BubbleSort())
print(context.execute_strategy(data))  # Utilise BubbleSort
```

#### **5. Adapter Pattern**
Le **Adapter Pattern** est un pattern structurel qui permet d'adapter une interface existante à une interface attendue par un client. Cela permet de rendre des classes incompatibles compatibles.

- **But** : Adapter une classe existante à une nouvelle interface sans modifier la classe existante.
- **Utilisation typique** : Lorsque vous devez intégrer des bibliothèques existantes qui ont des interfaces incompatibles avec votre système.

###### Implémentation de l'Adapter en Python :

```python
class OldSystem:
    def old_method(self):
        return "Méthode du vieux système"

class NewSystem:
    def new_method(self):
        return "Méthode du nouveau système"

class Adapter:
    def __init__(self, new_system: NewSystem):
        self.new_system = new_system

    def old_method(self):
        return self.new_system.new_method()

# Utilisation
old_system = OldSystem()
print(old_system.old_method())  # Affiche "Méthode du vieux système"

new_system = NewSystem()
adapter = Adapter(new_system)
print(adapter.old_method())  # Affiche "Méthode du nouveau système"
```

#### **6. Autres Patterns Notables**
Voici quelques autres patterns de conception qui sont fréquemment utilisés dans des applications plus complexes :

- **Decorator** : Permet d'ajouter dynamiquement des fonctionnalités à un objet.
- **Command** : Encapsule une requête sous forme d'un objet, permettant ainsi de paramétrer les clients avec des requêtes différentes.
- **Facade** : Fournit une interface simplifiée à un ensemble d'interfaces dans un sous-système complexe.
- **Composite** : Permet de traiter des objets individuels et des compositions d'objets de manière uniforme.
- **Chain of Responsibility** : Permet à plusieurs objets de traiter une demande sans savoir lequel traitera finalement la requête.

### Conclusion

Les **Design Patterns** sont des outils puissants qui aident à résoudre des problèmes de conception récurrents de manière modulaire et maintenable. Une bonne compréhension de ces patterns permet non seulement de rendre le code plus flexible et réutilisable, mais aussi de faciliter la communication entre développeurs, car ces patterns fournissent un vocabulaire commun pour décrire des solutions de conception.

### Chap 12. **Interopérabilité avec d'autres langages**

L'interopérabilité permet à Python de communiquer avec d'autres langages de programmation ou de tirer parti de bibliothèques écrites dans ces langages. Cela peut être particulièrement utile lorsque certaines parties d'une application nécessitent des performances optimisées ou l'utilisation de bibliothèques spécifiques à d'autres langages. Voici un aperçu des différentes méthodes permettant à Python d'interagir avec d'autres langages.

#### **1. Extensions en C avec `Cython`**
**Cython** est un langage de programmation qui rend l'écriture de modules C extensibles dans Python beaucoup plus facile. Cython est un compilateur Python qui transforme le code Python en C, permettant ainsi d'optimiser les performances de certaines parties du code. Il est souvent utilisé pour accélérer les opérations lourdes en calcul.

- **But** : Améliorer les performances de Python en utilisant du code C.
- **Utilisation typique** : Lorsque vous avez des algorithmes très gourmands en ressources (par exemple, des calculs mathématiques ou des manipulations de données à grande échelle), Cython permet de les exécuter beaucoup plus rapidement en les compilant en code natif.

###### Exemple d'extension en C avec Cython :

1. Créez un fichier Python avec des annotations Cython.
```python
# fichier example.pyx
def add_numbers(a, b):
    return a + b
```
2. Créez un fichier `setup.py` pour compiler le code Cython.
```python
# setup.py
from setuptools import setup
from Cython.Build import cythonize

setup(
    ext_modules=cythonize("example.pyx"),
)
```

3. Compilez le code avec la commande suivante dans le terminal :

```bash
python setup.py build_ext --inplace
```
4. Ensuite, vous pouvez importer et utiliser ce module dans Python.
```python
import example
print(example.add_numbers(2, 3))  # Affiche 5
```

#### **2. Appels à des bibliothèques externes avec `ctypes` et `CFFI`**
- **`ctypes`** : `ctypes` est une bibliothèque Python qui permet d'appeler des fonctions dans des bibliothèques partagées (DLLs ou fichiers `.so`) écrites en C. Cela permet à Python d'utiliser des fonctions externes sans avoir besoin de wrappers Python complexes.
  
  **But** : Permet d'interagir directement avec des bibliothèques C.
  
  **Utilisation typique** : Pour utiliser des bibliothèques externes (par exemple, des API système, des bibliothèques de calculs mathématiques) ou des codebases écrites en C.

###### Exemple d'utilisation de `ctypes` pour appeler une fonction C :

1. Imaginons une bibliothèque C (`mathlib.c`) qui contient une fonction simple pour additionner deux entiers.

```c
// mathlib.c
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}
```
2. Compilez la bibliothèque en une DLL (ou `.so` sur Linux).
```bash
gcc -shared -o libmathlib.so -fPIC mathlib.c
```
3. Utilisez `ctypes` pour appeler cette fonction depuis Python.
```python
import ctypes

# Charger la bibliothèque partagée
lib = ctypes.CDLL('./libmathlib.so')

# Appeler la fonction add
result = lib.add(3, 5)
print(result)  # Affiche 8
```

- **`CFFI`** : Le module `CFFI` (C Foreign Function Interface) est une alternative à `ctypes` qui simplifie l'utilisation des bibliothèques C dans Python. `CFFI` permet d'utiliser des bibliothèques C externes via une interface plus simple et plus Pythonique.

###### Exemple d'utilisation de `CFFI` :

1. CFFI offre une interface pour lier et appeler des fonctions C dans des bibliothèques partagées.

```python
from cffi import FFI

ffi = FFI()

# Déclare la signature de la fonction C
ffi.cdef("int add(int, int);")

# Charger la bibliothèque C
C = ffi.dlopen("./libmathlib.so")

# Appeler la fonction C
result = C.add(10, 20)
print(result)  # Affiche 30
```

#### **3. Utilisation de Python avec Java (Jython), .NET (IronPython), etc.**
- **`Jython`** : `Jython` est une implémentation de Python qui s'exécute sur la machine virtuelle Java (JVM). Cela permet aux programmes Python d'utiliser des bibliothèques Java et d'interagir avec des applications Java existantes. Cependant, `Jython` n'est pas entièrement compatible avec toutes les fonctionnalités de CPython, notamment les extensions C.

  **But** : Permet d'utiliser des bibliothèques Java dans des applications Python et d'exécuter du code Python dans un environnement Java.

###### Exemple de Jython avec Java :

```python
# Utiliser Java depuis Python (Jython)
from java.util import ArrayList

# Créer une liste Java
java_list = ArrayList()
java_list.add("Element1")
java_list.add("Element2")

# Afficher la liste
print(java_list)
```

- **`IronPython`** : `IronPython` est une implémentation de Python qui fonctionne sur la plateforme .NET. Cela permet à Python d'interagir avec les bibliothèques .NET, d'utiliser des objets .NET et d'exécuter du code Python dans un environnement .NET.

  **But** : Permet d'utiliser des bibliothèques .NET dans des applications Python et d'exécuter du code Python dans un environnement .NET.

###### Exemple de IronPython avec .NET :

```python
import clr
clr.AddReference('System.Windows.Forms')

from System.Windows.Forms import Form, Button

# Créer une fenêtre simple avec un bouton
form = Form()
button = Button()
button.Text = "Cliquez moi"
form.Controls.Add(button)
form.ShowDialog()
```

#### **Avantages et inconvénients de l'interopérabilité entre langages** :
- **Avantages** :
  - **Performances** : Les parties critiques du code peuvent être optimisées en utilisant des langages plus rapides comme C ou C++.
  - **Réutilisation de bibliothèques** : Vous pouvez tirer parti des bibliothèques existantes dans d'autres langages, ce qui peut accélérer le développement.
  - **Accès aux fonctionnalités spécifiques** : Certaines fonctionnalités ne sont disponibles que dans des langages spécifiques, comme les API Java ou .NET.

- **Inconvénients** :
  - **Complexité accrue** : L'intégration de plusieurs langages dans un projet peut rendre le code plus complexe et plus difficile à maintenir.
  - **Problèmes de compatibilité** : Les différences entre les implémentations de Python (comme CPython, Jython, IronPython) peuvent introduire des problèmes de compatibilité.

### Conclusion
L'interopérabilité avec d'autres langages offre une flexibilité énorme dans le développement de logiciels, notamment pour les applications nécessitant des performances optimisées, l'accès à des bibliothèques spécifiques ou l'intégration dans des environnements existants. Cependant, l'utilisation de ces outils requiert une gestion soignée de la compatibilité, des performances et de la maintenabilité du code.

### Chap 13. **Sécurité et Cryptographie**

La sécurité est un domaine crucial dans le développement d'applications, notamment pour garantir la confidentialité des données, l'intégrité des communications et la prévention des attaques. Python, avec ses bibliothèques robustes, offre des outils puissants pour implémenter des solutions de sécurité et de cryptographie. Voici un aperçu des principales techniques utilisées pour la gestion des données sensibles et la sécurisation des applications.

#### **1. Chiffrement avec `cryptography`, `PyCryptodome`**

**Chiffrement** : Le chiffrement est un processus qui transforme des données lisibles (texte en clair) en une forme codée (texte chiffré) à l'aide d'un algorithme de chiffrement et d'une clé secrète. Il est utilisé pour protéger les données contre l'accès non autorisé.

##### **Cryptography** :
`cryptography` est une bibliothèque Python moderne et puissante pour la cryptographie. Elle propose des outils pour le chiffrement symétrique (où la même clé est utilisée pour chiffrer et déchiffrer les données), le chiffrement asymétrique (où des clés publiques et privées sont utilisées), et pour la gestion des certificats.

- **Chiffrement symétrique** : Utilisation d'algorithmes comme AES.
- **Chiffrement asymétrique** : Utilisation d'algorithmes comme RSA pour échanger des clés de manière sécurisée.
- **Hachage** : Utilisation de fonctions comme SHA-256 pour obtenir des empreintes uniques de données.

###### Exemple de chiffrement symétrique avec `cryptography` :

```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import os

# Générer une clé secrète de 32 octets pour AES
key = os.urandom(32)
iv = os.urandom(16)  # Vecteur d'initialisation

# Initialiser le chiffreur avec AES en mode CBC
cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
encryptor = cipher.encryptor()

# Chiffrer les données (les données doivent être multiples de 16 octets)
data = b"Message secret à chiffrer!"
ciphertext = encryptor.update(data) + encryptor.finalize()

print(f"Texte chiffré: {ciphertext.hex()}")
```

##### **PyCryptodome** :
`PyCryptodome` est une bibliothèque Python qui fournit des outils pour le chiffrement symétrique et asymétrique, ainsi que pour les fonctions de hachage et la génération de clés. Elle est souvent utilisée comme alternative à `pycrypto` et est plus facile à installer.

###### Exemple de chiffrement symétrique avec `PyCryptodome` :

```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

# Générer une clé et un IV
key = get_random_bytes(16)
cipher = AES.new(key, AES.MODE_EAX)

# Chiffrer les données
data = b"Message secret à chiffrer!"
ciphertext, tag = cipher.encrypt_and_digest(data)

print(f"Texte chiffré: {ciphertext.hex()}")
```

#### **2. Gestion des clés et des certificats**

**Gestion des clés** : Dans les systèmes de chiffrement, la gestion des clés est essentielle pour assurer la sécurité. Les clés doivent être stockées de manière sécurisée et doivent être protégées contre les accès non autorisés.

- **Clés symétriques** : Utilisées pour les algorithmes comme AES. Elles doivent être générées de manière aléatoire et stockées de manière sécurisée.
- **Clés asymétriques** : Utilisées pour le chiffrement RSA et d'autres algorithmes à clé publique/privée. La clé publique est partagée librement, tandis que la clé privée doit être protégée.

**Certificats** : Les certificats SSL/TLS, utilisés pour sécuriser les connexions réseau, sont des fichiers qui contiennent une clé publique et d'autres informations sur l'entité à laquelle elle appartient. Ces certificats sont généralement émis par une autorité de certification (CA).

##### Exemple de génération de clés avec `cryptography` :

```python
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import Encoding, PrivateFormat, PublicFormat

# Générer une clé privée RSA de 2048 bits
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
)

# Extraire la clé publique de la clé privée
public_key = private_key.public_key()

# Sérialiser la clé privée et publique en PEM
private_pem = private_key.private_bytes(
    encoding=Encoding.PEM,
    format=PrivateFormat.TraditionalOpenSSL,
    encryption_algorithm=NoEncryption(),
)

public_pem = public_key.public_bytes(
    encoding=Encoding.PEM,
    format=PublicFormat.SubjectPublicKeyInfo,
)

print(f"Clé privée : {private_pem.decode()}")
print(f"Clé publique : {public_pem.decode()}")
```

#### **3. Sécurisation des applications web (XSS, CSRF, etc.)**

**XSS (Cross-Site Scripting)** : L'attaque XSS permet à un attaquant d'injecter des scripts malveillants dans les pages web affichées aux utilisateurs. Pour prévenir les attaques XSS, il est essentiel de valider et d'assainir les données d'entrée de l'utilisateur et d'échapper correctement les caractères spéciaux dans les réponses HTML.

- Utilisation de bibliothèques comme **`Flask-WTF`** ou **`Django`** pour filtrer les entrées des utilisateurs.
- **Content Security Policy (CSP)** : Utiliser des entêtes HTTP pour restreindre les sources de contenu autorisées.

**CSRF (Cross-Site Request Forgery)** : Cette attaque consiste à tromper un utilisateur authentifié en lui faisant exécuter des actions non voulues sur un site web. La prévention du CSRF nécessite l'utilisation de tokens uniques pour chaque formulaire (par exemple, `csrf_token` dans les frameworks comme Flask et Django).

- Utiliser des bibliothèques qui gèrent automatiquement les tokens CSRF, comme **`Flask-WTF`** ou **`Django CSRF middleware`**.

###### Exemple de prévention XSS et CSRF avec `Flask` :

1. **Protection contre XSS** : Échapper les variables dans les templates.

```python
from flask import Flask, render_template_string

app = Flask(__name__)

@app.route("/")
def index():
    user_input = "<script>alert('XSS Attack')</script>"
    # Utilisation de Jinja pour échapper le contenu
    return render_template_string("<h1>{{ user_input }}</h1>", user_input=user_input)
```

2. **Protection contre CSRF** : Utiliser un token CSRF avec `Flask-WTF`.

```python
from flask import Flask, render_template_string
from flask_wtf import FlaskForm
from flask_wtf.csrf import CSRFProtect
from wtforms import SubmitField

app = Flask(__name__)
app.secret_key = 'my_secret_key'
csrf = CSRFProtect(app)

class MyForm(FlaskForm):
    submit = SubmitField('Submit')

@app.route("/form", methods=["GET", "POST"])
def form():
    form = MyForm()
    if form.validate_on_submit():
        # Traiter les données du formulaire
        return "Form submitted!"
    return render_template_string("""
        <form method="POST">
            {{ form.hidden_tag() }}
            {{ form.submit() }}
        </form>
    """, form=form)

if __name__ == "__main__":
    app.run(debug=True)
```

#### **Conclusion**

La cryptographie et la sécurité des applications web sont des aspects essentiels pour protéger les données sensibles et prévenir les attaques. Utiliser des bibliothèques comme `cryptography` et `PyCryptodome` pour le chiffrement, ainsi que suivre les bonnes pratiques pour prévenir des attaques comme XSS et CSRF, sont des étapes clés pour assurer la sécurité des applications Python.

### Chap 14. **Python pour l'analyse de données**

Python est un langage extrêmement populaire pour l'analyse de données grâce à ses bibliothèques puissantes et sa flexibilité. Les outils comme `Pandas`, `NumPy`, `matplotlib` et `seaborn` permettent de traiter, analyser, visualiser et manipuler des ensembles de données volumineux et complexes. Ce chapitre présente des concepts avancés utilisés dans l'analyse de données avec Python.

#### **1. Manipulation avancée de `Pandas` et `NumPy**

**Pandas** et **NumPy** sont les deux bibliothèques les plus utilisées pour le traitement des données en Python. `Pandas` offre des structures de données flexibles comme les `DataFrame` et `Series`, tandis que `NumPy` fournit des tableaux multidimensionnels et des fonctions mathématiques efficaces pour traiter des données numériques.

##### **Pandas Avancé** :
- **Indexation multi-niveaux (MultiIndex)** : Utiliser des indices multiples pour organiser des données hiérarchiques.
- **Opérations par groupe (GroupBy)** : Permet de regrouper des données et d'appliquer des fonctions d'agrégation comme `sum()`, `mean()`, etc.
- **Fusion et jointure (Merge & Join)** : Combinez plusieurs DataFrames selon des clés communes avec des techniques de fusion avancées.
- **Nettoyage de données (Data Cleaning)** : Techniques avancées pour traiter les valeurs manquantes, supprimer les doublons, et transformer les données.

###### Exemple de manipulation avancée avec Pandas :

```python
import pandas as pd
import numpy as np

# Créer un DataFrame avec un MultiIndex
arrays = [np.array(['A', 'A', 'B', 'B', 'C', 'C']),
          np.array(['a', 'b', 'a', 'b', 'a', 'b'])]
index = pd.MultiIndex.from_arrays(arrays, names=('Level 1', 'Level 2'))
df = pd.DataFrame(np.random.randn(6, 2), index=index, columns=['Data1', 'Data2'])

# Accéder à des données avec un MultiIndex
print(df.loc['A'])
print(df.xs('a', level='Level 2'))

# GroupBy avec agrégation
df_grouped = df.groupby('Level 1').mean()
print(df_grouped)
```

##### **NumPy Avancé** :
- **Broadcasting** : Appliquer des opérations sur des tableaux de tailles différentes, ce qui permet d'étendre automatiquement les dimensions.
- **Manipulation d'array multidimensionnels** : Créer et manipuler des matrices et des tenseurs pour les calculs numériques complexes.
- **Fonctions statistiques et algébriques** : Utiliser des fonctions pour les calculs statistiques comme la moyenne, la variance, ainsi que des fonctions linéaires et matricielles.

###### Exemple de NumPy avancé :

```python
import numpy as np

# Création de matrices
matrix = np.array([[1, 2], [3, 4]])

# Opérations de diffusion (broadcasting)
arr1 = np.array([1, 2])
arr2 = np.array([[1], [2]])
result = arr1 + arr2
print(result)

# Calcul de la moyenne, variance, etc.
mean = np.mean(matrix)
variance = np.var(matrix)
print(f"Mean: {mean}, Variance: {variance}")
```

#### **2. Data pipelines et gestion des données volumineuses**

Les **data pipelines** sont des chaînes d'opérations permettant de collecter, nettoyer, transformer, et analyser les données de manière efficace et structurée. Elles sont cruciales lorsqu'on travaille avec de grands ensembles de données ou des flux de données en temps réel.

##### **Data Pipelines avec Pandas** :
Un **data pipeline** peut impliquer des étapes comme la lecture de fichiers, la transformation des données, puis l'analyse et la sauvegarde des résultats.

- **Chargement des données** : Lire de grandes quantités de données à partir de diverses sources (CSV, Excel, bases de données SQL, etc.).
- **Transformation des données** : Appliquer des transformations complexes aux données avant de les analyser.
- **Stockage et gestion des données volumineuses** : Utiliser des structures comme `HDF5` ou `Parquet` pour stocker et manipuler des données volumineuses sans perte de performance.

###### Exemple d'un Data Pipeline simple avec Pandas :

```python
import pandas as pd

# Lecture des données à partir d'un fichier CSV
df = pd.read_csv('data.csv')

# Nettoyage et transformation des données
df_cleaned = df.dropna().reset_index(drop=True)  # Suppression des valeurs manquantes
df_transformed = df_cleaned[df_cleaned['Column'] > 10]  # Filtrage des lignes

# Sauvegarde des résultats
df_transformed.to_parquet('processed_data.parquet')

print(df_transformed.head())
```

##### **Gestion des données volumineuses** :
- Utilisation de **Dask** pour manipuler des données volumineuses de manière distribuée.
- Traitement de fichiers volumineux avec **PyArrow** et **Parquet**, qui offrent des performances plus rapides pour les lectures et écritures comparées aux fichiers CSV classiques.

###### Exemple avec Dask :

```python
import dask.dataframe as dd

# Lire un fichier CSV volumineux avec Dask
df = dd.read_csv('large_data.csv')

# Transformation des données
df_cleaned = df[df['column'] > 10]

# Exécution des calculs
df_cleaned.compute()  # Convertir en Pandas DataFrame pour obtenir le résultat
```

#### **3. Visualisation avec `matplotlib`, `seaborn`, etc.**

La visualisation des données permet de mieux comprendre les tendances, les corrélations et les anomalies au sein des données. **`matplotlib`** et **`seaborn`** sont les bibliothèques les plus populaires pour la création de graphiques en Python.

##### **`matplotlib`** :
- Utilisation pour créer des graphiques de base comme les histogrammes, les courbes, les graphiques en barres, etc.
- Personnalisation avancée des graphiques avec des couleurs, des titres, des légendes, etc.

###### Exemple de visualisation avec `matplotlib` :

```python
import matplotlib.pyplot as plt
import numpy as np

# Données à afficher
x = np.linspace(0, 10, 100)
y = np.sin(x)

# Création du graphique
plt.plot(x, y)
plt.title('Courbe Sinus')
plt.xlabel('x')
plt.ylabel('y')
plt.grid(True)
plt.show()
```

##### **`seaborn`** :
- Basé sur `matplotlib`, `seaborn` simplifie la création de graphiques complexes et améliore leur esthétique.
- Supporte des visualisations avancées telles que les cartes thermiques (heatmaps), les diagrammes en violon (violin plots), les boîtes à moustaches (box plots), etc.

###### Exemple de visualisation avec `seaborn` :

```python
import seaborn as sns
import matplotlib.pyplot as plt

# Charger un jeu de données exemple
tips = sns.load_dataset('tips')

# Créer un graphique en boîte pour visualiser les pourboires
sns.boxplot(x="day", y="total_bill", data=tips)
plt.title('Distribution des factures par jour')
plt.show()
```

#### **Conclusion**

L'analyse de données en Python repose largement sur la manipulation de données avec `Pandas` et `NumPy`, la création de **data pipelines** efficaces et la visualisation des résultats à l'aide de bibliothèques comme `matplotlib` et `seaborn`. Ces outils sont cruciaux pour gérer des données volumineuses et réaliser des analyses complexes dans un environnement Python, tout en permettant de créer des visualisations claires et informatives.

### Chap 15. **Programmation fonctionnelle avancée**

La programmation fonctionnelle est un paradigme où la computation est exprimée sous forme de fonctions qui prennent des arguments et retournent des résultats sans effets secondaires. Python, tout en étant un langage multiparadigme, supporte bien les concepts de la programmation fonctionnelle. Voici des concepts avancés qui permettent de mieux exploiter ce paradigme dans Python.

#### **1. Fonctions d'ordre supérieur**

Une fonction d'ordre supérieur est une fonction qui peut prendre une ou plusieurs fonctions en argument, ou retourner une fonction en résultat. Ce concept est fondamental en programmation fonctionnelle, car il permet de créer des abstractions puissantes et de composer des comportements.

- **Exemples de fonctions d'ordre supérieur** : `map()`, `filter()`, `reduce()` et même des fonctions comme `sorted()` qui peuvent accepter des fonctions comme clé de tri.

##### Exemple :

```python
# Fonction d'ordre supérieur qui applique une fonction à une liste
def appliquer_fonction(liste, fonction):
    return [fonction(x) for x in liste]

# Exemple d'utilisation
resultat = appliquer_fonction([1, 2, 3], lambda x: x ** 2)
print(resultat)  # [1, 4, 9]
```

Ici, la fonction `appliquer_fonction` prend une autre fonction (comme `lambda x: x ** 2`) en argument, et l'applique à chaque élément de la liste.

#### **2. Composition et currying de fonctions**

La **composition de fonctions** permet de combiner plusieurs fonctions en une seule, où la sortie d'une fonction devient l'entrée de la suivante. Le **currying** est une technique permettant de transformer une fonction qui prend plusieurs arguments en une suite de fonctions chacune prenant un seul argument.

##### **Composition de fonctions** :
La composition de fonctions peut être réalisée en utilisant des fonctions comme `compose()`. En Python, vous pouvez créer une telle fonction manuellement ou utiliser des bibliothèques comme `toolz` pour cette fonctionnalité.

##### Exemple de composition manuelle de fonctions :

```python
# Composition de deux fonctions f et g
def compose(f, g):
    return lambda x: f(g(x))

# Définition de deux fonctions
def add_3(x):
    return x + 3

def multiply_2(x):
    return x * 2

# Composition des deux fonctions
composed_function = compose(add_3, multiply_2)
result = composed_function(5)  # (5 * 2) + 3 = 13
print(result)
```

##### **Currying** :
Le currying transforme une fonction avec plusieurs arguments en une chaîne de fonctions prenant chacune un argument. 

###### Exemple de currying :

```python
def multiply(a):
    def multiply_by(b):
        return a * b
    return multiply_by

# Currying
multiply_3 = multiply(3)
result = multiply_3(5)  # 3 * 5 = 15
print(result)
```

Ici, `multiply(3)` renvoie une fonction qui multiplie son argument par 3.

#### **3. Utilisation des générateurs et itérateurs personnalisés**

Les **générateurs** et **itérateurs personnalisés** permettent de créer des séquences paresseuses, ce qui est très utile lorsqu'on travaille avec de grandes quantités de données. Un générateur est une fonction qui produit un flux d'éléments sur demande, un par un, au lieu de retourner une liste entière en mémoire.

##### **Générateurs** :
Les générateurs en Python sont créés avec l'instruction `yield`. Contrairement à une fonction traditionnelle qui retourne une valeur et termine son exécution, une fonction génératrice avec `yield` suspend son état et peut être reprise à partir de là où elle s'était arrêtée.

###### Exemple de générateur :

```python
# Générateur simple
def compteur(max):
    n = 0
    while n < max:
        yield n
        n += 1

# Utilisation du générateur
for i in compteur(5):
    print(i)
```

Ici, la fonction `compteur()` est un générateur qui retourne les valeurs de 0 à 4 sans créer une liste entière en mémoire.

##### **Itérateurs personnalisés** :
Un itérateur est un objet qui implémente les méthodes `__iter__()` et `__next__()`. Il permet de créer des objets qui peuvent être utilisés dans des boucles `for` et d'autres contextes où un objet itérable est attendu.

###### Exemple d'itérateur personnalisé :

```python
class Compteur:
    def __init__(self, max):
        self.max = max
        self.n = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.n < self.max:
            self.n += 1
            return self.n - 1
        else:
            raise StopIteration

# Utilisation de l'itérateur
compteur = Compteur(5)
for i in compteur:
    print(i)
```

Ici, `Compteur` est une classe qui implémente un itérateur. La méthode `__next__()` renvoie les valeurs successives jusqu'à atteindre la limite, après quoi elle lève une exception `StopIteration` pour signaler la fin de l'itération.

#### **Conclusion**

La programmation fonctionnelle avancée permet de manipuler des fonctions comme des objets de première classe, offrant ainsi une flexibilité considérable dans la création d'applications Python modulaires, composables et réutilisables. La composition et le currying de fonctions, ainsi que l'utilisation de générateurs et d'itérateurs personnalisés, sont des outils puissants qui, lorsqu'ils sont maîtrisés, permettent de développer des applications Python plus efficaces, plus expressives et plus performantes.

### Chap 16. **Python et la performance**

La gestion de la performance dans Python est un aspect crucial pour optimiser les applications et rendre les algorithmes plus efficaces. Bien que Python soit un langage interprété et donc plus lent que des langages compilés comme C ou C++, il existe de nombreuses techniques et outils qui permettent d'améliorer les performances des applications Python.

#### **1. Profiling et optimisation du code**

Le **profiling** consiste à mesurer la performance du code afin de comprendre quelles parties sont lentes et nécessitent une optimisation. Python offre plusieurs outils pour effectuer des analyses de performance, comme `cProfile`, `timeit`, et des modules de visualisation comme `snakeviz`.

- **`cProfile`** : C'est un profiler intégré qui permet d'analyser la performance des fonctions d'un programme. Il offre un rapport détaillé de l'exécution, indiquant le temps passé dans chaque fonction, le nombre d'appels, etc.
  
  ##### Exemple d'utilisation de `cProfile` :

  ```python
  import cProfile

  def ma_fonction():
      total = 0
      for i in range(1000000):
          total += i
      return total

  cProfile.run('ma_fonction()')
  ```

  Cela produira une sortie détaillant le nombre de fois où chaque fonction a été appelée et le temps qu'elle a mis à s'exécuter.

- **`timeit`** : Ce module est utilisé pour mesurer le temps d'exécution de petites portions de code. Il est pratique pour tester des alternatives et choisir la plus rapide.

  ##### Exemple d'utilisation de `timeit` :

  ```python
  import timeit
  print(timeit.timeit('x = sum(range(100))', number=100000))
  ```

  Cela mesurera le temps d'exécution de l'instruction `sum(range(100))` sur 100 000 exécutions.

##### **Optimisation après profiling**
Une fois que vous avez identifié les parties lentes de votre code, vous pouvez les optimiser de différentes manières :

- Réduire la complexité algorithmique : Passer de `O(n^2)` à `O(n log n)` ou `O(n)` est souvent une optimisation majeure.
- Utiliser des structures de données plus efficaces : Utiliser des dictionnaires au lieu de listes pour des recherches rapides.
- Limiter les opérations coûteuses, comme les accès disque ou les appels réseau, en optimisant les algorithmes ou en utilisant des caches.

#### **2. Cython pour l'optimisation des performances**

**Cython** est un superset de Python qui permet d'écrire des extensions C dans du code Python. Cela permet de compiler une partie du code en C pour obtenir des gains de performance significatifs, tout en restant dans l'écosystème Python.

- **Avantages de Cython** :
  - Accélération du code en permettant des optimisations bas niveau.
  - Intégration facile avec Python et possibilité de compiler des bibliothèques C.
  - Utilisation des types statiques pour maximiser la performance.

##### Exemple simple d'utilisation de Cython :

1. **Installer Cython** :
   ```bash
   pip install cython
   ```

2. **Écrire un fichier Cython** (par exemple, `exemple.pyx`) :

   ```cython
   def somme(int n):
       cdef int i, total = 0
       for i in range(n):
           total += i
       return total
   ```

3. **Compiler avec Cython** :

   Créez un fichier de configuration `setup.py` pour compiler le fichier `.pyx` :

   ```python
   from distutils.core import setup
   from Cython.Build import cythonize

   setup(
       ext_modules = cythonize("exemple.pyx")
   )
   ```

4. **Compiler le fichier** :

   ```bash
   python setup.py build_ext --inplace
   ```

5. **Utiliser le fichier compilé** :

   ```python
   import exemple
   print(exemple.somme(1000000))
   ```

Grâce à l'utilisation de `cdef` pour déclarer les types de variables, Cython permet une optimisation de la performance en tirant parti des capacités de compilation du C.

#### **3. Utilisation des structures de données efficaces pour les algorithmes**

L'un des aspects clés pour améliorer la performance d'un algorithme Python est de choisir les bonnes structures de données. Python propose plusieurs structures de données optimisées pour des cas d'utilisation spécifiques. Voici quelques conseils pour utiliser efficacement ces structures :

- **Dictionnaires (`dict`)** : Les dictionnaires sont implémentés sous forme de tables de hachage, ce qui permet des recherches, insertions et suppressions rapides en moyenne en `O(1)`. Utilisez-les pour des recherches rapides et pour maintenir des relations clé-valeur.

  ##### Exemple :

  ```python
  d = {}
  for i in range(1000):
      d[i] = i * 2
  ```

- **Listes (`list`)** : Les listes en Python sont dynamiques, mais elles ne sont pas les plus efficaces pour certaines opérations (par exemple, suppression et insertion au début de la liste, qui est `O(n)`), donc pour ces cas, utilisez des `deque` (double-ended queue) qui permettent des opérations en temps constant `O(1)` aux deux extrémités.

  ##### Exemple avec `deque` :

  ```python
  from collections import deque
  d = deque([1, 2, 3])
  d.appendleft(0)  # Ajoute 0 au début en O(1)
  d.append(4)      # Ajoute 4 à la fin en O(1)
  print(d)  # deque([0, 1, 2, 3, 4])
  ```

- **Ensembles (`set`)** : Utilisez des `set` pour les tests d'appartenance rapides (vérifier si un élément existe dans une collection). Les ensembles sont basés sur des tables de hachage et offrent des performances en `O(1)` pour les recherches.

  ##### Exemple :

  ```python
  s = set([1, 2, 3, 4, 5])
  print(3 in s)  # True en O(1)
  ```

- **Structures personnalisées** : Lorsque les structures de données standards ne sont pas suffisantes, vous pouvez utiliser des bibliothèques comme `numpy` pour des matrices et des calculs mathématiques rapides, ou encore `heapq` pour des tas (heaps) efficaces.

#### **Conclusion**

L'optimisation des performances en Python passe par un bon profilage du code, l'utilisation de techniques comme Cython pour accélérer le code critique, et la sélection des structures de données adaptées aux besoins spécifiques des algorithmes. Utiliser des outils comme `cProfile` et `timeit` permet de repérer les goulets d'étranglement, tandis que l'intégration de Cython et le choix judicieux des structures de données permettent de maximiser l'efficacité des programmes Python dans des contextes de calcul intensif.

### Chap 17. **Sécurité et Cryptographie Avancée**

La sécurité est une composante essentielle dans le développement d’applications modernes, surtout lorsque des données sensibles ou des transactions critiques sont en jeu. Voici une exploration détaillée des concepts avancés de sécurité et de cryptographie dans Python.

---

#### **1. Mise en œuvre de l'authentification avancée avec OAuth2 et JWT**

**OAuth2** et **JWT** (JSON Web Tokens) sont deux piliers de l'authentification moderne pour sécuriser les API et applications.

---

##### **OAuth2** (Open Authorization Protocol v2)

**OAuth2** est un protocole permettant d'accorder un accès limité à des ressources sans partager les identifiants de l'utilisateur. Python propose des bibliothèques comme **`authlib`**, **`flask-oauthlib`** ou **`fastapi`** pour gérer OAuth2.

- **Flux d’authentification courants avec OAuth2** :
  - **Code d'autorisation** : utilisé pour les applications web.
  - **Mot de passe utilisateur** : utilisé lorsque le client a un contrôle total (comme pour des scripts ou tests internes).
  - **Credentials client** : utilisé pour l’authentification entre serveurs.

##### Exemple d'intégration OAuth2 avec Flask :

1. **Installation** :

   ```bash
   pip install flask flask-oauthlib
   ```

2. **Configuration d'un fournisseur OAuth2** :

   ```python
   from flask import Flask, redirect, request, url_for
   from flask_oauthlib.client import OAuth

   app = Flask(__name__)
   app.secret_key = 'random_secret_key'
   oauth = OAuth(app)

   google = oauth.remote_app(
       'google',
       consumer_key='YOUR_CLIENT_ID',
       consumer_secret='YOUR_CLIENT_SECRET',
       request_token_params={
           'scope': 'email',
       },
       base_url='https://www.googleapis.com/oauth2/v1/',
       request_token_url=None,
       access_token_url='https://accounts.google.com/o/oauth2/token',
       authorize_url='https://accounts.google.com/o/oauth2/auth',
   )

   @app.route('/')
   def index():
       return redirect(url_for('login'))

   @app.route('/login')
   def login():
       return google.authorize(callback=url_for('authorized', _external=True))

   @app.route('/login/authorized')
   def authorized():
       response = google.authorized_response()
       if response is None or response.get('access_token') is None:
           return 'Access denied.'
       session['google_token'] = (response['access_token'], '')
       user_info = google.get('userinfo')
       return f'Hello, {user_info.data["email"]}!'

   if __name__ == '__main__':
       app.run()
   ```

---

##### **JWT** (JSON Web Tokens)

JWT est un standard pour représenter des informations sécurisées sous forme de **tokens signés**. Ces tokens contiennent trois parties :
1. **Header** : type de token et algorithme de signature.
2. **Payload** : données encapsulées.
3. **Signature** : permet de vérifier l'intégrité et l'authenticité.

Les bibliothèques courantes pour JWT en Python incluent **`pyjwt`**.

###### Exemple d'utilisation de JWT :

```python
import jwt
import datetime

SECRET_KEY = 'votre_clé_secrète'

# Génération d’un token JWT
def generate_jwt(payload):
    token = jwt.encode(
        {"payload": payload, "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=1)},
        SECRET_KEY,
        algorithm="HS256",
    )
    return token

# Décodage et vérification d’un token JWT
def decode_jwt(token):
    try:
        decoded = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        return decoded
    except jwt.ExpiredSignatureError:
        return "Le token a expiré"
    except jwt.InvalidTokenError:
        return "Token invalide"

# Exemple d'utilisation
token = generate_jwt({"user_id": 123})
print(f"Token JWT généré : {token}")

decoded = decode_jwt(token)
print(f"Données du token : {decoded}")
```

---

#### **2. Cryptographie asymétrique avancée avec courbes elliptiques (ECC)**

La cryptographie asymétrique à l'aide des **courbes elliptiques (ECC)** offre une sécurité élevée avec des clés plus courtes que les algorithmes traditionnels comme RSA.

- **Utilisations courantes de l’ECC** :
  - Échange sécurisé de clés.
  - Signature numérique (ECDSA).
  - Cryptage/déchiffrement (ECIES).

Python prend en charge ECC via des bibliothèques comme **`cryptography`**.

##### Exemple d’utilisation d’ECC pour signer un message :

1. **Installation** :

   ```bash
   pip install cryptography
   ```

2. **Signature avec ECC** :

   ```python
   from cryptography.hazmat.primitives.asymmetric import ec
   from cryptography.hazmat.primitives import hashes

   # Générer une clé privée ECC
   private_key = ec.generate_private_key(ec.SECP256R1())

   # Signer un message
   message = b"Message à signer"
   signature = private_key.sign(message, ec.ECDSA(hashes.SHA256()))

   # Vérifier la signature
   public_key = private_key.public_key()
   try:
       public_key.verify(signature, message, ec.ECDSA(hashes.SHA256()))
       print("Signature valide.")
   except:
       print("Signature invalide.")
   ```

---

#### **3. Gestion des clés sécurisées et intégration avec des services de secrets**

Les clés cryptographiques doivent être gérées avec soin pour éviter les fuites ou les compromissions.

##### **Principes de gestion sécurisée des clés** :
- **Ne jamais stocker les clés en clair** dans le code source.
- **Utiliser des services de gestion de secrets** comme AWS Secrets Manager, HashiCorp Vault ou Azure Key Vault.
- Appliquer des rotations régulières des clés.

##### **Stockage sécurisé avec `cryptography`** :
La bibliothèque **`cryptography`** permet de stocker des clés de manière sécurisée dans des fichiers protégés par un mot de passe.

###### Exemple :

```python
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa

# Générer une clé RSA
private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)

# Stocker la clé privée dans un fichier sécurisé
password = b"mot_de_passe"
pem = private_key.private_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PrivateFormat.PKCS8,
    encryption_algorithm=serialization.BestAvailableEncryption(password),
)

with open("private_key.pem", "wb") as pem_file:
    pem_file.write(pem)

# Charger la clé privée
with open("private_key.pem", "rb") as pem_file:
    private_key = serialization.load_pem_private_key(
        pem_file.read(), password=password
    )
print("Clé chargée avec succès.")
```

---

#### **Conclusion**

- **OAuth2** et **JWT** permettent une authentification robuste pour des applications modernes.
- La **cryptographie asymétrique avec ECC** est une solution efficace pour des scénarios nécessitant des échanges sécurisés avec des ressources limitées.
- Une bonne gestion des clés via des bibliothèques comme **`cryptography`** ou des services tiers est essentielle pour éviter les failles de sécurité.

Avec ces techniques, Python peut être utilisé pour développer des systèmes sécurisés et conformes aux standards modernes.

### Chap 18. **Développement Web et Applications Réseau**

Python offre des outils puissants pour le développement d'applications web performantes et de services réseau robustes. Voici un aperçu des techniques avancées pour la création d'API asynchrones et de communication réseau.

---

#### **1. Création d'API performantes avec FastAPI et Starlette**

**FastAPI** est un framework Python moderne conçu pour créer des API performantes, évolutives et faciles à utiliser. Basé sur **Starlette** pour la gestion des requêtes HTTP asynchrones et **Pydantic** pour la validation des données, il permet d'exploiter au mieux les fonctionnalités asynchrones de Python.

---

##### **Principaux avantages de FastAPI** :
- Gestion asynchrone des requêtes (avec `asyncio`).
- Documentation interactive générée automatiquement (Swagger UI et ReDoc).
- Validation et typage strict des données via **Pydantic**.
- Performance comparable aux frameworks rapides comme **Node.js** ou **Go**.

---

##### **Exemple d'API avec FastAPI** :

1. **Installation** :

   ```bash
   pip install fastapi uvicorn
   ```

2. **Code d'une API simple** :

   ```python
   from fastapi import FastAPI
   from pydantic import BaseModel

   app = FastAPI()

   # Modèle de données
   class Item(BaseModel):
       name: str
       price: float
       is_offer: bool = False

   # Routes
   @app.get("/")
   async def read_root():
       return {"message": "Bienvenue dans FastAPI"}

   @app.get("/items/{item_id}")
   async def read_item(item_id: int, q: str = None):
       return {"item_id": item_id, "query": q}

   @app.post("/items/")
   async def create_item(item: Item):
       return {"item_name": item.name, "item_price": item.price}

   # Lancer le serveur avec : uvicorn <nom_du_fichier>:app --reload
   ```

3. **Lancer le serveur** :

   ```bash
   uvicorn main:app --reload
   ```

4. **Documentation interactive** :
   - Swagger UI : [http://127.0.0.1:8000/docs](http://127.0.0.1:8000/docs)
   - ReDoc : [http://127.0.0.1:8000/redoc](http://127.0.0.1:8000/redoc)

---

##### **Cas d'utilisation avancés avec FastAPI** :
- **Authentification JWT** : Intégration facile avec des librairies comme `pyjwt`.
- **Streaming de réponses HTTP** : Idéal pour des flux en temps réel ou du streaming de fichiers.
- **WebSockets** : Gestion native pour des communications bidirectionnelles (ex. chat en temps réel).
- **Intégration avec Starlette** : Utiliser des middlewares et des composants supplémentaires.

---

#### **2. Communication réseau avancée avec Twisted et gRPC**

---

##### **Twisted** : Programmation réseau événementielle

**Twisted** est une bibliothèque puissante pour le développement de protocoles réseau, utilisée pour des cas nécessitant une gestion fine des connexions, comme des serveurs de jeux, des chats, ou des applications peer-to-peer.

1. **Installation** :

   ```bash
   pip install twisted
   ```

2. **Exemple de serveur TCP avec Twisted** :

   ```python
   from twisted.internet import reactor, protocol

   class Echo(protocol.Protocol):
       def dataReceived(self, data):
           # Répondre avec les données reçues
           self.transport.write(data)

   class EchoFactory(protocol.Factory):
       def buildProtocol(self, addr):
           return Echo()

   # Démarrer le serveur
   reactor.listenTCP(8000, EchoFactory())
   reactor.run()
   ```

3. **Caractéristiques clés** :
   - Support de nombreux protocoles (HTTP, SMTP, IMAP, etc.).
   - Gestion asynchrone et non bloquante.
   - Intégration avec des bibliothèques comme TLS pour la sécurité.

---

##### **gRPC** : Communication rapide et efficace entre services

**gRPC** (Google Remote Procedure Call) est un framework moderne pour la communication interservices. Basé sur **Protocol Buffers (Protobuf)**, il permet des échanges rapides et typés.

1. **Installation** :

   ```bash
   pip install grpcio grpcio-tools
   ```

2. **Création d’un service gRPC** :

   - **Définir le fichier `.proto`** :

     ```proto
     syntax = "proto3";

     service Greeter {
         rpc SayHello (HelloRequest) returns (HelloReply);
     }

     message HelloRequest {
         string name = 1;
     }

     message HelloReply {
         string message = 1;
     }
     ```

   - **Générer les fichiers Python** :

     ```bash
     python -m grpc_tools.protoc -I . --python_out=. --grpc_python_out=. greeter.proto
     ```

   - **Serveur gRPC** :

     ```python
     from concurrent import futures
     import grpc
     import greeter_pb2
     import greeter_pb2_grpc

     class GreeterServicer(greeter_pb2_grpc.GreeterServicer):
         def SayHello(self, request, context):
             return greeter_pb2.HelloReply(message=f"Bonjour, {request.name}!")

     server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
     greeter_pb2_grpc.add_GreeterServicer_to_server(GreeterServicer(), server)
     server.add_insecure_port('[::]:50051')
     server.start()
     server.wait_for_termination()
     ```

   - **Client gRPC** :

     ```python
     import grpc
     import greeter_pb2
     import greeter_pb2_grpc

     channel = grpc.insecure_channel('localhost:50051')
     stub = greeter_pb2_grpc.GreeterStub(channel)
     response = stub.SayHello(greeter_pb2.HelloRequest(name="Utilisateur"))
     print(response.message)
     ```

---

#### **Cas d’utilisation** :
- **FastAPI et gRPC** : Exposer une API FastAPI tout en utilisant gRPC pour la communication interne entre microservices.
- **Twisted** pour des protocoles personnalisés** : Construire des services réseau nécessitant des protocoles spécifiques.
- **Applications WebSockets et asynchrones** : Chats en temps réel, tableaux de bord de monitoring.

---

#### **Conclusion**

- **FastAPI** est un choix idéal pour créer des API performantes, exploitant les fonctionnalités asynchrones de Python.
- **Twisted** et **gRPC** offrent des outils puissants pour les communications réseau avancées, adaptés aux besoins des protocoles personnalisés ou des échanges rapides entre services.

Avec ces outils, Python devient un acteur incontournable pour le développement de systèmes distribués, évolutifs et fiables.

### Chap 19. **Machine Learning et Data Science**

Python est un langage clé pour le Machine Learning (ML) et la Data Science grâce à son riche écosystème de bibliothèques. Voici les aspects avancés pour la création, l'optimisation de pipelines, le développement de modèles complexes, et le traitement de Big Data.

---

#### **1. Création et optimisation de pipelines avec Scikit-learn**

**Scikit-learn** est une bibliothèque polyvalente pour le ML. Les pipelines permettent de simplifier les workflows complexes en enchaînant les étapes de prétraitement, de sélection de caractéristiques et de modélisation.

##### **Création d’un pipeline** :

1. **Installation** :

   ```bash
   pip install scikit-learn
   ```

2. **Exemple de pipeline** :

   ```python
   from sklearn.pipeline import Pipeline
   from sklearn.preprocessing import StandardScaler
   from sklearn.decomposition import PCA
   from sklearn.ensemble import RandomForestClassifier
   from sklearn.model_selection import train_test_split, GridSearchCV
   from sklearn.datasets import load_iris

   # Chargement des données
   data = load_iris()
   X, y = data.data, data.target
   X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

   # Définition du pipeline
   pipeline = Pipeline([
       ('scaler', StandardScaler()),
       ('pca', PCA(n_components=2)),
       ('classifier', RandomForestClassifier())
   ])

   # Optimisation avec GridSearch
   param_grid = {
       'pca__n_components': [2, 3],
       'classifier__n_estimators': [50, 100, 200],
       'classifier__max_depth': [5, 10, None]
   }
   grid_search = GridSearchCV(pipeline, param_grid, cv=5)
   grid_search.fit(X_train, y_train)

   print(f"Meilleurs paramètres : {grid_search.best_params_}")
   print(f"Score de validation : {grid_search.best_score_}")
   ```

##### **Avantages des pipelines** :
- Réduction des erreurs liées au traitement manuel des données.
- Facilitation de la reproduction des expériences.
- Intégration facile avec des outils comme **GridSearchCV** ou **RandomizedSearchCV** pour l'optimisation hyperparamétrique.

---

#### **2. Développement de modèles complexes avec TensorFlow et PyTorch**

**TensorFlow** et **PyTorch** sont des frameworks populaires pour créer et entraîner des modèles complexes, allant des réseaux de neurones simples aux architectures avancées (RNN, Transformer, GAN).

---

##### **Développement avec TensorFlow** :

1. **Installation** :

   ```bash
   pip install tensorflow
   ```

2. **Exemple d'un modèle de classification avec Keras** :

   ```python
   import tensorflow as tf
   from tensorflow.keras import Sequential
   from tensorflow.keras.layers import Dense, Dropout
   from sklearn.model_selection import train_test_split
   from sklearn.datasets import make_classification

   # Générer des données synthétiques
   X, y = make_classification(n_samples=1000, n_features=20, n_classes=2, random_state=42)
   X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

   # Construire le modèle
   model = Sequential([
       Dense(64, activation='relu', input_shape=(X_train.shape[1],)),
       Dropout(0.5),
       Dense(32, activation='relu'),
       Dense(1, activation='sigmoid')
   ])

   model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
   model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=10, batch_size=32)
   ```

---

##### **Développement avec PyTorch** :

1. **Installation** :

   ```bash
   pip install torch torchvision
   ```

2. **Exemple d’un réseau neuronal simple** :

   ```python
   import torch
   import torch.nn as nn
   import torch.optim as optim
   from sklearn.datasets import make_classification
   from sklearn.model_selection import train_test_split
   from sklearn.preprocessing import StandardScaler

   # Préparer les données
   X, y = make_classification(n_samples=1000, n_features=20, n_classes=2, random_state=42)
   scaler = StandardScaler()
   X = scaler.fit_transform(X)
   X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

   X_train, X_test = torch.tensor(X_train, dtype=torch.float32), torch.tensor(X_test, dtype=torch.float32)
   y_train, y_test = torch.tensor(y_train, dtype=torch.long), torch.tensor(y_test, dtype=torch.long)

   # Définir le modèle
   class SimpleNN(nn.Module):
       def __init__(self):
           super(SimpleNN, self).__init__()
           self.fc1 = nn.Linear(20, 64)
           self.relu = nn.ReLU()
           self.fc2 = nn.Linear(64, 32)
           self.output = nn.Linear(32, 2)

       def forward(self, x):
           x = self.relu(self.fc1(x))
           x = self.relu(self.fc2(x))
           return self.output(x)

   model = SimpleNN()
   criterion = nn.CrossEntropyLoss()
   optimizer = optim.Adam(model.parameters(), lr=0.001)

   # Entraîner le modèle
   for epoch in range(10):
       optimizer.zero_grad()
       outputs = model(X_train)
       loss = criterion(outputs, y_train)
       loss.backward()
       optimizer.step()
       print(f"Epoch {epoch+1}, Loss: {loss.item()}")
   ```

---

#### **3. Traitement de Big Data avec PySpark et intégration Hadoop/Spark**

**PySpark** permet de traiter des volumes massifs de données distribuées en utilisant Apache Spark, tandis que **Hadoop** assure le stockage et la gestion des données.

---

##### **Installation de PySpark** :

```bash
pip install pyspark
```

---

##### **Traitement de données avec PySpark** :

1. **Chargement et transformation de données** :

   ```python
   from pyspark.sql import SparkSession

   spark = SparkSession.builder.appName("BigDataExample").getOrCreate()

   # Charger des données CSV
   df = spark.read.csv("data.csv", header=True, inferSchema=True)

   # Transformation de données
   df_filtered = df.filter(df['age'] > 30).select('name', 'age')
   df_filtered.show()
   ```

2. **Traitement avancé avec RDDs** :

   ```python
   rdd = spark.sparkContext.parallelize([1, 2, 3, 4, 5])
   squared_rdd = rdd.map(lambda x: x ** 2)
   print(squared_rdd.collect())
   ```

---

#### **Applications avancées** :
- **Optimisation des pipelines Spark MLlib** : Intégration de workflows distribués pour le ML.
- **Big Data** : Analyse de données volumineuses en temps réel avec Spark Streaming.
- **Hadoop** : Utilisation pour le stockage distribué et les pipelines ETL.

---

#### **Conclusion**

Ces outils permettent de construire des solutions avancées, allant des modèles simples à l’analyse de données massives en temps réel. Les frameworks comme TensorFlow, PyTorch, et PySpark offrent une flexibilité et une puissance inégalées pour relever les défis des projets de Machine Learning et de Big Data.

### Chap 20 ** Optimisation et Mémoire en Python**

L'optimisation de l'utilisation mémoire est essentielle, surtout pour des applications manipulant des grandes quantités de données ou nécessitant une performance élevée. Python offre des outils intégrés comme `__slots__`, `cProfile`, et `tracemalloc` pour réduire la consommation de mémoire et identifier les goulets d'étranglement.

---

### **1. Utilisation de `__slots__` pour réduire l'utilisation mémoire dans les classes**

Par défaut, les objets Python utilisent un **dictionnaire interne** (`__dict__`) pour stocker leurs attributs. Ce mécanisme, bien que flexible, consomme plus de mémoire. L'utilisation de `__slots__` permet de limiter les attributs à un ensemble prédéfini, supprimant ainsi le besoin d'un dictionnaire et réduisant la mémoire consommée.

#### **Fonctionnement de `__slots__` :**
- `__slots__` est une liste ou un tuple d'attributs autorisés dans une classe.
- Lorsque `__slots__` est défini, Python n'alloue plus de dictionnaire pour chaque instance de la classe.
- Cela rend les classes moins dynamiques mais beaucoup plus économes en mémoire.

---

##### **Exemple d’utilisation de `__slots__` :**

```python
class WithoutSlots:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class WithSlots:
    __slots__ = ['name', 'age']  # Attributs autorisés
    def __init__(self, name, age):
        self.name = name
        self.age = age

# Création d'instances
obj1 = WithoutSlots("Alice", 30)
obj2 = WithSlots("Bob", 25)

# Comparaison de mémoire
import sys
print(f"Sans __slots__ : {sys.getsizeof(obj1.__dict__)} octets")
print(f"Avec __slots__ : {sys.getsizeof(obj2)} octets")
```

#### **Avantages :**
- Réduction significative de la mémoire utilisée.
- Performances légèrement améliorées pour l'accès aux attributs.

#### **Limitations :**
- Les classes avec `__slots__` ne peuvent pas avoir d'attributs dynamiques (ajoutés après l'initialisation).
- Ne fonctionne pas avec l'héritage multiple.

---

### **2. Analyse des performances avec `cProfile` et `tracemalloc`**

---

#### **2.1 Analyse des performances avec `cProfile`**

**`cProfile`** est un outil intégré dans Python pour profiler un programme, c'est-à-dire identifier quelles parties du code consomment le plus de temps. Cela est utile pour optimiser les performances en détectant les fonctions les plus coûteuses.

---

##### **Exemple simple d’utilisation :**

```python
import cProfile

def calcul_intensif():
    total = 0
    for i in range(1000000):
        total += i
    return total

def programme_principal():
    calcul_intensif()
    print("Programme terminé.")

# Profilage
cProfile.run('programme_principal()')
```

---

##### **Interprétation des résultats :**
- **ncalls** : Nombre d’appels pour chaque fonction.
- **tottime** : Temps total passé dans la fonction (sans inclure les appels aux autres fonctions).
- **cumtime** : Temps cumulé (temps passé dans la fonction + temps des sous-appels).

---

#### **2.2 Analyse de l’utilisation mémoire avec `tracemalloc`**

**`tracemalloc`** est une bibliothèque Python permettant de suivre l’utilisation mémoire en identifiant où la mémoire a été allouée. Il est particulièrement utile pour détecter des fuites mémoire ou des allocations excessives.

---

##### **Exemple d’utilisation de `tracemalloc` :**

```python
import tracemalloc

def fonction_qui_utilise_memoire():
    x = [i ** 2 for i in range(10000)]  # Grande liste en mémoire
    return x

# Activer tracemalloc
tracemalloc.start()

# Exécuter le code à profiler
fonction_qui_utilise_memoire()

# Afficher les statistiques mémoire
snapshot = tracemalloc.take_snapshot()
top_stats = snapshot.statistics('lineno')

print("[ Top 10 allocations mémoire ]")
for stat in top_stats[:10]:
    print(stat)
```

---

##### **Interprétation des résultats :**
- `statistics('lineno')` : Classe les allocations mémoire par ligne de code.
- Vous pouvez repérer les lignes de code consommant le plus de mémoire et optimiser ces sections.

---

### **3. Combinaison des outils**

En combinant `cProfile` pour le temps d'exécution et `tracemalloc` pour l’utilisation mémoire, vous obtenez une vue complète des performances et des ressources utilisées par votre programme.

---

#### **Exemple complet :**

```python
import cProfile
import tracemalloc

def fonction_optimisable():
    total = sum(i ** 2 for i in range(10000))  # Consomme beaucoup de ressources
    return total

# Activer tracemalloc
tracemalloc.start()

# Profilage de la fonction
cProfile.run('fonction_optimisable()')

# Capture des allocations mémoire
snapshot = tracemalloc.take_snapshot()
top_stats = snapshot.statistics('lineno')

print("[ Statistiques mémoire ]")
for stat in top_stats[:5]:
    print(stat)
```

---

### **4. Conseils pratiques pour l'optimisation**

1. **Éviter les structures inutiles** :
   - Utiliser des tuples au lieu des listes pour les données immuables.
   - Privilégier les compréhensions de liste/générateur.

2. **Utiliser des bibliothèques externes** :
   - Pour les calculs intensifs, utiliser `NumPy` qui est optimisé pour la performance.

3. **Optimiser les algorithmes** :
   - Identifier les fonctions les plus lentes avec `cProfile`.
   - Améliorer les performances en réduisant la complexité algorithmique.

---

### **Conclusion**

- L’utilisation de `__slots__` peut réduire considérablement la mémoire des classes tout en améliorant les performances.
- `cProfile` et `tracemalloc` sont des outils indispensables pour profiler les performances temporelles et l’utilisation mémoire d’un programme.
- En combinant ces techniques avec des bonnes pratiques d’optimisation, il est possible de concevoir des applications Python plus performantes et plus efficaces.

### Chap 21 ** Interopérabilité avancée en Python**

L’interopérabilité permet à Python de collaborer efficacement avec d’autres langages de programmation, comme C et C++, afin d’améliorer les performances ou d’exploiter des bibliothèques externes. Voici deux techniques avancées : **l’utilisation de `ctypes` et `CFFI` pour appeler des bibliothèques externes**, et **Cython** pour optimiser les parties critiques du code.

---

### **1. Appels à des bibliothèques externes avec `ctypes` et `CFFI`**

#### **1.1 Utilisation de `ctypes`**

`ctypes` est une bibliothèque standard Python qui permet de charger des bibliothèques C dynamiques (DLL sous Windows ou `.so` sous Linux) et d’appeler leurs fonctions.

---

##### **Exemple : Appel d'une bibliothèque C avec `ctypes`**

1. **Créer une bibliothèque C** :

   ```c
   // mathlib.c
   #include <stdio.h>

   int add(int a, int b) {
       return a + b;
   }
   ```

2. **Compiler la bibliothèque** :

   Sous Linux :

   ```bash
   gcc -shared -o libmathlib.so -fPIC mathlib.c
   ```

   Sous Windows :

   ```bash
   gcc -shared -o mathlib.dll -fPIC mathlib.c
   ```

3. **Utiliser `ctypes` en Python** :

   ```python
   import ctypes

   # Charger la bibliothèque partagée
   lib = ctypes.CDLL('./libmathlib.so')  # .dll sous Windows

   # Définir les types des arguments et du retour de la fonction
   lib.add.argtypes = [ctypes.c_int, ctypes.c_int]
   lib.add.restype = ctypes.c_int

   # Appeler la fonction
   result = lib.add(3, 5)
   print(f"Résultat : {result}")  # Résultat : 8
   ```

---

##### **Avantages de `ctypes`** :
- Inclus dans la bibliothèque standard Python.
- Facile à utiliser pour des bibliothèques simples.

##### **Limitations** :
- Moins adapté pour les bibliothèques complexes nécessitant des structures ou des callbacks.

---

#### **1.2 Utilisation de `CFFI`**

`CFFI` (C Foreign Function Interface) est une alternative à `ctypes`, offrant une interface plus intuitive pour interagir avec du code C. Il est particulièrement utile pour les bibliothèques avec des structures complexes.

---

##### **Exemple avec `CFFI`** :

1. **Créer une bibliothèque C** :

   (Utilisez le même fichier C et compilez comme dans l'exemple précédent.)

2. **Utiliser `CFFI` en Python** :

   ```python
   from cffi import FFI

   ffi = FFI()

   # Déclarer la signature des fonctions
   ffi.cdef("""
       int add(int a, int b);
   """)

   # Charger la bibliothèque
   lib = ffi.dlopen("./libmathlib.so")

   # Appeler la fonction
   result = lib.add(3, 5)
   print(f"Résultat avec CFFI : {result}")  # Résultat : 8
   ```

---

##### **Avantages de `CFFI`** :
- Plus puissant que `ctypes` pour des bibliothèques complexes.
- Compatible avec des structures C.

##### **Limitations** :
- Nécessite une installation (`pip install cffi`).

---

### **2. Introduction à Cython**

**Cython** est un outil qui transforme le code Python en C pour des gains significatifs en termes de performance. Il est souvent utilisé pour accélérer les parties critiques des programmes Python.

---

#### **2.1 Principes de base**

- Cython permet d'ajouter des annotations de types (`cdef`) pour compiler du code Python en C.
- Cela réduit l'interprétation à l’exécution, augmentant la vitesse d’exécution.

---

#### **Exemple simple avec Cython**

1. **Créer un fichier `example.pyx`** :

   ```python
   def somme(int n):
       cdef int i, total = 0
       for i in range(n):
           total += i
       return total
   ```

2. **Créer un fichier `setup.py`** :

   ```python
   from setuptools import setup
   from Cython.Build import cythonize

   setup(
       ext_modules=cythonize("example.pyx"),
   )
   ```

3. **Compiler le code** :

   ```bash
   python setup.py build_ext --inplace
   ```

4. **Utiliser le fichier compilé** :

   ```python
   import example

   print(example.somme(1000000))  # Somme rapide grâce à Cython
   ```

---

#### **2.2 Avantages de Cython** :
- Accélère les boucles lourdes et les calculs intensifs.
- Intègre facilement des bibliothèques C existantes.

#### **Limitations** :
- Nécessite des connaissances en C pour les optimisations avancées.
- Augmente la complexité du processus de développement.

---

### **Résumé Comparatif**

| **Méthode**         | **Avantages**                             | **Limites**                            |
|----------------------|-------------------------------------------|----------------------------------------|
| `ctypes`            | Inclus dans Python, simple à utiliser     | Moins adapté pour des structures complexes |
| `CFFI`              | Intuitif, gère bien les structures C      | Besoin d'une installation supplémentaire |
| **Cython**          | Optimisation puissante des performances   | Complexité accrue pour le développement |

---

### **Conclusion**

L'interopérabilité avancée avec des bibliothèques externes est une compétence essentielle pour les développeurs Python travaillant sur des applications nécessitant des performances élevées. Selon les besoins, `ctypes`, `CFFI`, ou **Cython** offrent des solutions adaptées, allant de l'accès simple à des bibliothèques C à l'optimisation des calculs lourds via des compilations C.

### Chap 22 ** Programmation réseau avancée**

La programmation réseau avancée en Python permet de développer des applications capables de gérer des communications TCP, UDP, ou WebSocket de manière performante. Python offre des bibliothèques modernes comme **`asyncio`** pour la programmation asynchrone et **`websockets`** pour des connexions WebSocket bidirectionnelles.

---

### **1. Création de serveurs TCP/UDP avec `asyncio`**

`asyncio` est une bibliothèque native de Python pour gérer des entrées/sorties asynchrones, particulièrement utile dans des scénarios réseau.

---

#### **1.1 Serveur TCP avec `asyncio`**

Un serveur TCP (Transmission Control Protocol) garantit une communication fiable entre client et serveur.

##### **Exemple : Serveur TCP avec `asyncio`**

```python
import asyncio

async def handle_client(reader, writer):
    addr = writer.get_extra_info('peername')
    print(f"Connexion établie avec {addr}")

    while True:
        data = await reader.read(100)
        if not data:
            break  # Fin de connexion
        print(f"Données reçues : {data.decode()}")
        writer.write(data)  # Echo
        await writer.drain()  # Assurez-vous que les données sont envoyées

    print(f"Connexion terminée avec {addr}")
    writer.close()
    await writer.wait_closed()

async def main():
    server = await asyncio.start_server(handle_client, '127.0.0.1', 8888)
    addr = server.sockets[0].getsockname()
    print(f"Serveur TCP démarré sur {addr}")

    async with server:
        await server.serve_forever()

asyncio.run(main())
```

##### **Points clés** :
- Le serveur écoute sur `127.0.0.1:8888`.
- Les données reçues sont renvoyées au client (serveur echo).

---

#### **1.2 Serveur UDP avec `asyncio`**

UDP (User Datagram Protocol) est plus léger que TCP mais ne garantit pas la fiabilité des transmissions.

##### **Exemple : Serveur UDP avec `asyncio`**

```python
import asyncio

async def handle_udp(reader, writer):
    while True:
        data, addr = await reader.read()
        print(f"Données reçues de {addr}: {data.decode()}")
        writer.sendto(b"Message reçu!", addr)

async def main():
    loop = asyncio.get_event_loop()
    transport, protocol = await loop.create_datagram_endpoint(
        lambda: asyncio.DatagramProtocol(),
        local_addr=('127.0.0.1', 9999),
    )
    print("Serveur UDP démarré sur 127.0.0.1:9999")

    try:
        await asyncio.sleep(3600)  # Garder le serveur actif
    finally:
        transport.close()

asyncio.run(main())
```

##### **Points clés** :
- Un serveur UDP ne maintient pas de connexion persistante.
- Utilisez `reader.read()` et `writer.sendto()` pour recevoir et envoyer des messages.

---

### **2. Gestion des connexions WebSocket avec le module `websockets`**

Le module **`websockets`** fournit une API simple pour créer des serveurs et des clients WebSocket. Les WebSockets permettent une communication bidirectionnelle et en temps réel, souvent utilisée pour des chats, des tableaux de bord en direct ou des jeux.

---

#### **2.1 Serveur WebSocket avec `websockets`**

##### **Exemple : Serveur WebSocket**

1. **Installation** :

   ```bash
   pip install websockets
   ```

2. **Code du serveur** :

   ```python
   import asyncio
   import websockets

   async def echo(websocket, path):
       print(f"Client connecté : {path}")
       async for message in websocket:
           print(f"Message reçu : {message}")
           await websocket.send(f"Echo : {message}")

   # Lancer le serveur
   async def main():
       async with websockets.serve(echo, "127.0.0.1", 8765):
           print("Serveur WebSocket démarré sur ws://127.0.0.1:8765")
           await asyncio.Future()  # Garde le serveur actif

   asyncio.run(main())
   ```

3. **Points clés** :
   - Le serveur écoute sur `ws://127.0.0.1:8765`.
   - Il renvoie un message "echo" pour chaque message reçu.

---

#### **2.2 Client WebSocket avec `websockets`**

##### **Exemple : Client WebSocket**

```python
import asyncio
import websockets

async def communicate():
    async with websockets.connect("ws://127.0.0.1:8765") as websocket:
        await websocket.send("Salut serveur!")
        response = await websocket.recv()
        print(f"Réponse du serveur : {response}")

asyncio.run(communicate())
```

---

### **3. Points importants sur `asyncio` et `websockets`**

- **Avantages de l'approche asynchrone** :
  - Les serveurs peuvent gérer plusieurs connexions simultanées sans bloquer les autres.
  - Les WebSockets permettent une communication en temps réel, idéale pour les applications interactives.

- **Limites** :
  - L’approche asynchrone nécessite une gestion soignée des exceptions pour éviter les blocages ou les erreurs silencieuses.
  - Les WebSockets ne sont pas toujours compatibles avec des environnements fortement contraints en ressources réseau.

---

### **Résumé**

| **Protocole**       | **Utilisation**                               | **Cas d’usage**                     |
|----------------------|-----------------------------------------------|--------------------------------------|
| **TCP**             | Connexions fiables et persistantes            | Serveurs d’applications, jeux en ligne |
| **UDP**             | Connexions rapides, non fiables               | Vidéos en streaming, DNS            |
| **WebSockets**      | Communication bidirectionnelle en temps réel | Chats, tableaux de bord, jeux       |

Avec `asyncio` et `websockets`, Python offre une solution robuste et performante pour développer des applications réseau avancées.

### Chap 23 ** Cryptographie avancée**

La cryptographie est essentielle pour garantir la confidentialité, l'intégrité et l'authenticité des données dans les systèmes modernes. Cette section explore deux concepts avancés : **l'utilisation des courbes elliptiques (ECC)** pour la signature et le chiffrement, et **la gestion sécurisée des clés** avec des modules comme `cryptography`.

---

### **1. Utilisation des courbes elliptiques (ECC)**

Les **courbes elliptiques (ECC)** sont une méthode de cryptographie asymétrique offrant une sécurité équivalente à des clés beaucoup plus courtes que RSA. Cela les rend idéales pour les systèmes où les ressources (bande passante, stockage) sont limitées.

#### **1.1 Concepts fondamentaux**
- **Chiffrement ECC** : Utilise des points sur une courbe elliptique pour établir une clé publique et privée.
- **Signature ECC (ECDSA)** : Permet de signer des messages avec une clé privée et de vérifier la signature avec une clé publique.
- **Échange de clés ECC (ECDH)** : Établit une clé secrète partagée entre deux parties.

#### **1.2 Exemple d'utilisation avec `cryptography`**

##### **Installation**

```bash
pip install cryptography
```

##### **Signature numérique avec ECDSA**

```python
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import hashes

# Générer une clé privée
private_key = ec.generate_private_key(ec.SECP256R1())

# Signer un message
message = b"Message à signer"
signature = private_key.sign(message, ec.ECDSA(hashes.SHA256()))

# Vérifier la signature avec la clé publique
public_key = private_key.public_key()
try:
    public_key.verify(signature, message, ec.ECDSA(hashes.SHA256()))
    print("Signature valide.")
except Exception as e:
    print("Signature invalide:", e)
```

##### **Échange de clés avec ECDH**

```python
# Génération de deux paires de clés
private_key_1 = ec.generate_private_key(ec.SECP256R1())
private_key_2 = ec.generate_private_key(ec.SECP256R1())

# Génération d'une clé partagée
shared_key_1 = private_key_1.exchange(ec.ECDH(), private_key_2.public_key())
shared_key_2 = private_key_2.exchange(ec.ECDH(), private_key_1.public_key())

print(shared_key_1 == shared_key_2)  # Affiche True : la clé partagée est identique
```

---

### **2. Gestion sécurisée des clés avec `cryptography`**

La gestion des clés est essentielle pour garantir la sécurité des systèmes cryptographiques. Les clés doivent être générées, stockées et utilisées de manière sécurisée pour éviter les fuites ou les compromissions.

#### **2.1 Génération et stockage des clés**

##### **Sérialisation des clés**
Le module `cryptography` permet de sérialiser (sauvegarder) les clés dans des fichiers, protégés ou non par un mot de passe.

###### **Exemple : Sauvegarde et chargement d'une clé privée**

```python
from cryptography.hazmat.primitives.serialization import Encoding, PrivateFormat, NoEncryption
from cryptography.hazmat.primitives.asymmetric import rsa

# Générer une clé privée RSA
private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)

# Sauvegarder la clé privée sans mot de passe
pem = private_key.private_bytes(
    encoding=Encoding.PEM,
    format=PrivateFormat.PKCS8,
    encryption_algorithm=NoEncryption()
)

with open("private_key.pem", "wb") as f:
    f.write(pem)

# Charger la clé privée
from cryptography.hazmat.primitives.serialization import load_pem_private_key

with open("private_key.pem", "rb") as f:
    loaded_private_key = load_pem_private_key(f.read(), password=None)
```

---

#### **2.2 Gestion des clés avec services externes**
- **HashiCorp Vault** ou **AWS KMS** : Gèrent les clés et effectuent les opérations cryptographiques sur des environnements sécurisés.
- **HSM (Hardware Security Module)** : Stocke et protège les clés sur du matériel dédié.

---

#### **2.3 Protection contre les fuites**
Utilisez les bonnes pratiques suivantes pour protéger vos clés :
1. **Ne jamais stocker de clés en clair** dans le code source.
2. **Limiter les accès** en utilisant des permissions restrictives sur les fichiers contenant les clés.
3. **Appliquer des rotations régulières** pour réduire les impacts en cas de compromission.

---

### **3. Avantages des courbes elliptiques et de la gestion sécurisée des clés**

#### **Courbes elliptiques :**
- **Efficacité** : Clés plus courtes pour une sécurité équivalente (par exemple, une clé ECC de 256 bits offre une sécurité similaire à une clé RSA de 3072 bits).
- **Rapidité** : Moins d'opérations coûteuses comparées à RSA.

#### **Gestion sécurisée des clés :**
- Réduction des risques d’exfiltration grâce à un stockage sécurisé.
- Conformité avec les réglementations comme **GDPR** ou **PCI DSS**.

---

### **Résumé**

| **Aspect**                 | **Description**                                                          |
|----------------------------|--------------------------------------------------------------------------|
| **ECC (courbes elliptiques)** | Utilisées pour les signatures numériques (ECDSA) et l’échange de clés (ECDH). |
| **Gestion des clés**        | Inclut la sérialisation, la protection et l’utilisation sécurisée.      |
| **Modules Python**          | Utilisation de `cryptography` pour des opérations simples et efficaces. |

Ces techniques permettent de sécuriser les communications et les données dans des applications modernes, tout en respectant les contraintes de performance et de mémoire.
