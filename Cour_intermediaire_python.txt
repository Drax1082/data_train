Niveau Intermédiaire 

### Chapitre 1 **Compréhension de liste (List Comprehension)**

La **compréhension de liste** est une technique puissante et concise pour créer de nouvelles listes en appliquant des expressions et des conditions de manière déclarative. Elle permet de générer des listes rapidement tout en améliorant la lisibilité du code et en réduisant le nombre de lignes nécessaires par rapport à l'utilisation de boucles `for` classiques.

#### 1. **Structure de base de la compréhension de liste**

La structure de base d'une compréhension de liste est la suivante :

```python
[expression for element in iterable]
```
- **expression** : C'est ce que vous souhaitez ajouter dans la nouvelle liste, qui peut être une simple valeur ou un calcul appliqué à chaque élément de l'itérable.
- **for element in iterable** : Cette partie parcourt chaque élément de l'itérable (par exemple une liste, un ensemble, une plage de nombres, etc.) et applique l'expression à chaque élément.

**Exemple :**

```python
# Créer une liste des carrés des nombres de 0 à 9
squares = [x**2 for x in range(10)]
print(squares)
```

**Sortie :**

```
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

#### 2. **Ajout de conditions dans la compréhension de liste**

Vous pouvez ajouter des conditions pour filtrer les éléments de l'itérable. La syntaxe pour une condition est placée à la fin de la compréhension de liste :
```python
[expression for element in iterable if condition]
```
- **condition** : Une expression conditionnelle qui permet de filtrer les éléments qui satisfont cette condition.

**Exemple :**

```python
# Créer une liste des carrés des nombres pairs entre 0 et 9
even_squares = [x**2 for x in range(10) if x % 2 == 0]
print(even_squares)
```

**Sortie :**

```
[0, 4, 16, 36, 64]
```
Dans cet exemple, la condition `x % 2 == 0` permet de ne sélectionner que les nombres pairs avant d'appliquer l'expression `x**2`.

#### 3. **Compréhension de liste avec plusieurs conditions**

Il est possible d'ajouter plusieurs conditions dans une compréhension de liste. Chaque condition est placée après le `if` ou dans la même clause `if` avec des opérateurs logiques (comme `and`, `or`).

**Exemple :**

```python
# Créer une liste des carrés des nombres pairs supérieurs à 3
even_squares_above_3 = [x**2 for x in range(10) if x % 2 == 0 and x > 3]
print(even_squares_above_3)
```

**Sortie :**

```
[16, 36, 64]
```

#### 4. **Utilisation d'expressions complexes dans la compréhension**

La partie **expression** peut être aussi complexe que nécessaire. Cela peut inclure des appels de fonction, des opérations mathématiques, ou même des expressions conditionnelles à l'intérieur de l'expression elle-même.

**Exemple :**

```python
# Créer une liste des résultats de l'addition de 10 à chaque nombre de 0 à 4
incremented_numbers = [x + 10 for x in range(5)]
print(incremented_numbers)
```

**Sortie :**

```
[10, 11, 12, 13, 14]
```

#### 5. **Compréhension de liste imbriquée**

Il est également possible d'utiliser des compréhensions de liste imbriquées. Cela signifie que vous pouvez avoir une compréhension de liste à l'intérieur d'une autre. Cela est utile pour traiter des structures de données comme des matrices ou des tableaux à plusieurs dimensions.

**Exemple :**

```python
# Créer une matrice 3x3 avec des valeurs multiples
matrix = [[(i + j) for j in range(3)] for i in range(3)]
print(matrix)
```

**Sortie :**

```
[[0, 1, 2], [1, 2, 3], [2, 3, 4]]
```
Dans cet exemple, la compréhension de liste imbriquée crée une matrice 3x3 où chaque élément est la somme de ses indices.

#### 6. **Utilisation de la compréhension de liste avec des dictionnaires et des ensembles**

Les compréhensions de liste peuvent également être utilisées pour créer des dictionnaires ou des ensembles de manière similaire.

- **Compréhension de dictionnaire :**

```python
# Créer un dictionnaire où les clés sont les nombres et les valeurs leurs carrés
square_dict = {x: x**2 for x in range(5)}
print(square_dict)
```

**Sortie :**

```
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
```

- **Compréhension d'ensemble :**

```python
# Créer un ensemble des carrés des nombres de 0 à 9
square_set = {x**2 for x in range(10)}
print(square_set)
```

**Sortie :**

```
{0, 1, 4, 9, 16, 25, 36, 49, 64, 81}
```

#### 7. **Performance des compréhensions de liste**

Les compréhensions de liste sont non seulement plus concises, mais elles sont aussi généralement plus performantes que les boucles `for` classiques. Elles sont optimisées au niveau du compilateur Python et évitent la nécessité de créer un objet temporaire pour chaque itération.

**Exemple de comparaison de performance :**

```python
import time

# Utilisation d'une boucle for classique
start_time = time.time()
squares_loop = []
for x in range(1000000):
    squares_loop.append(x**2)
print("Temps avec boucle for : ", time.time() - start_time)

# Utilisation de la compréhension de liste
start_time = time.time()
squares_comprehension = [x**2 for x in range(1000000)]
print("Temps avec compréhension de liste : ", time.time() - start_time)
```

En règle générale, la compréhension de liste est plus rapide en raison de son optimisation.

#### Conclusion

La compréhension de liste est un outil puissant en Python pour générer des listes de manière concise et élégante. Elle permet d'écrire des expressions complexes de manière lisible tout en améliorant les performances du code. L'utilisation de conditions et de structures imbriquées rend cette technique encore plus flexible et polyvalente.

### Chapitre 2 **Fonctions Lambda en Python**

Les **fonctions lambda** sont des fonctions anonymes en Python, créées avec le mot-clé `lambda`. Elles permettent de définir des fonctions simples de manière concise et généralement en une seule ligne. Contrairement aux fonctions classiques définies avec `def`, les fonctions lambda ne nécessitent pas de nom et sont souvent utilisées pour des opérations simples ou comme arguments dans des fonctions de traitement.

#### 1. **Syntaxe de base des fonctions lambda**

La syntaxe d'une fonction lambda est la suivante :

```python
lambda arguments: expression
```
- **arguments** : Ce sont les paramètres d'entrée de la fonction (similaires à ceux des fonctions classiques).
- **expression** : L'expression est évaluée et renvoyée comme résultat de la fonction lambda.

**Exemple simple :**

```python
# Fonction lambda qui additionne deux nombres
add = lambda x, y: x + y
print(add(2, 3))  # Sortie : 5
```
Ici, `lambda x, y: x + y` définit une fonction qui prend deux arguments (`x` et `y`), et renvoie leur somme.

#### 2. **Utilisation des fonctions lambda avec des fonctions intégrées**

Les fonctions lambda sont souvent utilisées en combinaison avec des fonctions intégrées de Python comme `map()`, `filter()`, et `sorted()`.

- **`map()`** : Applique une fonction à tous les éléments d'un itérable et renvoie une nouvelle liste.

```python
# Appliquer une fonction lambda pour doubler chaque élément de la liste
numbers = [1, 2, 3, 4]
doubled = map(lambda x: x * 2, numbers)
print(list(doubled))  # Sortie : [2, 4, 6, 8]
```

- **`filter()`** : Filtre les éléments d'un itérable selon une condition définie dans la fonction lambda.

```python
# Filtrer les nombres pairs de la liste
numbers = [1, 2, 3, 4, 5, 6]
evens = filter(lambda x: x % 2 == 0, numbers)
print(list(evens))  # Sortie : [2, 4, 6]
```

- **`sorted()`** : Trier une liste en utilisant une fonction lambda pour définir la clé de tri.

```python
# Trier une liste de tuples par le deuxième élément
pairs = [(1, 2), (3, 1), (5, 0)]
sorted_pairs = sorted(pairs, key=lambda x: x[1])
print(sorted_pairs)  # Sortie : [(5, 0), (3, 1), (1, 2)]
```

#### 3. **Utilisation des fonctions lambda avec des arguments par défaut**

Comme pour les fonctions classiques, les fonctions lambda peuvent accepter des arguments par défaut. Cela permet de créer des fonctions lambda plus flexibles.

**Exemple :**

```python
# Fonction lambda avec un argument par défaut
multiply = lambda x, y=2: x * y
print(multiply(3))  # Sortie : 6 (car y prend la valeur par défaut 2)
print(multiply(3, 4))  # Sortie : 12 (y prend la valeur 4)
```

#### 4. **Fonctions lambda et expressions conditionnelles**

Les fonctions lambda peuvent inclure des expressions conditionnelles pour appliquer des décisions simples dans une seule ligne.

**Syntaxe d'une expression conditionnelle dans une lambda :**

```python
lambda arguments: expression1 if condition else expression2
```

- **condition** : L'expression conditionnelle qui décide quelle expression sera évaluée.
- **expression1** et **expression2** : Les deux expressions possibles selon que la condition soit vraie ou fausse.

**Exemple :**

```python
# Fonction lambda qui renvoie "pair" si le nombre est pair, sinon "impair"
check_parity = lambda x: "pair" if x % 2 == 0 else "impair"
print(check_parity(4))  # Sortie : pair
print(check_parity(5))  # Sortie : impair
```

#### 5. **Limites des fonctions lambda**

Bien que les fonctions lambda soient utiles pour des opérations simples, elles ne sont pas adaptées pour des opérations complexes. En effet, elles sont limitées à une seule expression et ne peuvent pas contenir de déclarations complexes, de boucles ou de structures de contrôle.

**Exemple d'une fonction lambda invalide :**

```python
# Ceci est incorrect car une fonction lambda ne peut pas contenir plusieurs déclarations
lambda x: if x > 0: print("Positif") else: print("Négatif")
```
Dans ce cas, on ne peut pas utiliser des structures comme `if` directement dans une lambda avec des instructions multiples.

#### 6. **Fonctions lambda dans les applications avancées**

Les fonctions lambda sont également couramment utilisées dans les applications avancées telles que les callbacks, où une fonction est transmise à une autre fonction pour être exécutée à un moment ultérieur.

**Exemple :**

```python
# Passer une fonction lambda comme argument pour exécuter un calcul personnalisé
def apply_function(f, value):
    return f(value)

result = apply_function(lambda x: x**2, 4)
print(result)  # Sortie : 16
```

#### 7. **Comparaison avec les fonctions définies avec `def`**

Les fonctions lambda sont idéales pour des opérations simples et concises. Cependant, elles ont des limitations qui rendent l’utilisation des fonctions classiques (`def`) préférable pour des opérations plus complexes.

- **Fonction lambda :**

```python
# Fonction lambda pour additionner deux nombres
add = lambda x, y: x + y
```

- **Fonction classique :**

```python
# Fonction classique pour additionner deux nombres
def add(x, y):
    return x + y
```

Les fonctions définies avec `def` sont plus lisibles, peuvent être documentées avec des docstrings, et peuvent inclure des instructions plus complexes (boucles, conditions multiples, etc.).

#### 8. **Avantages des fonctions lambda**

- **Concises et lisibles** : Elles permettent de définir des fonctions simples en une ligne, ce qui rend le code plus compact.
- **Flexibles** : Elles peuvent être utilisées pour des opérations rapides et dans des contextes où une fonction nommée classique serait trop lourde.
- **Parfaites pour les fonctions d'ordre supérieur** : Les fonctions lambda sont couramment utilisées comme arguments dans des fonctions comme `map()`, `filter()`, et `reduce()`.

#### Conclusion

Les fonctions lambda sont un outil pratique dans le langage Python pour définir rapidement des fonctions simples et concises. Elles sont particulièrement utiles dans les cas où une fonction est nécessaire pour une tâche rapide, comme dans les appels aux fonctions de traitement fonctionnel (`map()`, `filter()`, etc.). Cependant, elles sont limitées à des expressions simples et ne conviennent pas aux opérations plus complexes.

### Chapitre 3 **Fonctions Génératrices en Python**

Les **fonctions génératrices** sont des fonctions spéciales en Python qui permettent de produire des éléments de manière **paresseuse** (lazy evaluation), un élément à la fois, au lieu de retourner une liste entière. Elles utilisent le mot-clé `yield` pour produire des valeurs, ce qui permet de gérer efficacement la mémoire, surtout lorsqu'on travaille avec de grands ensembles de données.

#### 1. **Syntaxe de base d'une fonction génératrice**

Une fonction génératrice ressemble à une fonction classique, mais au lieu de retourner une valeur avec `return`, elle utilise `yield` pour produire des valeurs à chaque itération. Chaque appel à `yield` suspend l'exécution de la fonction et conserve son état, de sorte que l'exécution peut être reprise là où elle s'est arrêtée.

**Exemple simple :**

```python
# Fonction génératrice qui produit les carrés des nombres de 1 à n
def generate_squares(n):
    for i in range(1, n + 1):
        yield i * i

# Création d'un générateur
squares = generate_squares(5)

# Consommation des éléments du générateur
for square in squares:
    print(square)  # Sortie : 1, 4, 9, 16, 25
```

Dans cet exemple, la fonction `generate_squares` produit les carrés des nombres de 1 à `n` un à un. À chaque itération, l'appel à `yield` suspend la fonction et retourne un carré. Lorsque la fonction est reprise, elle continue à partir de l'endroit où elle s'était arrêtée.

#### 2. **Le comportement paresseux des générateurs**

Les générateurs sont souvent utilisés dans les cas où les données sont trop volumineuses pour tenir en mémoire. Au lieu de générer toute la liste d’un coup, un générateur renvoie un élément à la fois et calcule chaque élément à la demande (lorsque l'on le demande explicitement via une itération).

**Exemple de générateur pour de grandes données :**

```python
# Fonction génératrice qui génère une séquence infinie de nombres
def infinite_numbers():
    num = 0
    while True:
        yield num
        num += 1

# Consommer seulement les 5 premiers nombres
counter = infinite_numbers()
for _ in range(5):
    print(next(counter))  # Sortie : 0, 1, 2, 3, 4
```

Ici, le générateur `infinite_numbers` produit une séquence infinie de nombres, mais la fonction s'arrête d'évaluer un nombre à la fois à chaque appel de `next()`. Cela évite d’allouer de la mémoire pour des millions de nombres à la fois.

#### 3. **Avantages des générateurs**

Les générateurs présentent plusieurs avantages par rapport aux autres structures de données comme les listes ou les tuples :

- **Utilisation de la mémoire optimisée** : Contrairement aux listes qui stockent tous les éléments en mémoire, les générateurs ne stockent qu'un élément à la fois, ce qui permet de gérer efficacement de très grands ensembles de données.
- **Performance améliorée** : Comme les générateurs produisent les valeurs à la demande, ils sont souvent plus rapides que la construction d'une liste complète, surtout pour de grandes séquences ou des données infinies.
- **Réduction de la complexité** : Lorsqu'une fonction génère une séquence d'éléments, l'utilisation de générateurs permet de simplifier le code et de le rendre plus lisible.

**Exemple :**

```python
# Générateur pour extraire les premiers éléments pairs d'une grande séquence
def get_even_numbers(limit):
    for num in range(limit):
        if num % 2 == 0:
            yield num

evens = get_even_numbers(10)
for even in evens:
    print(even)  # Sortie : 0, 2, 4, 6, 8
```

#### 4. **Comparaison avec les fonctions classiques**

Les fonctions classiques retournent toutes les valeurs en une seule fois (par exemple, dans une liste ou un autre conteneur), ce qui peut être inefficace si l'ensemble des données est volumineux.

**Fonction classique qui retourne une liste complète :**

```python
# Fonction classique qui retourne une liste complète
def generate_squares_list(n):
    return [i * i for i in range(1, n + 1)]

squares_list = generate_squares_list(5)
print(squares_list)  # Sortie : [1, 4, 9, 16, 25]
```

**Fonction génératrice pour une approche paresseuse :**

```python
# Fonction génératrice qui produit les carrés un par un
def generate_squares(n):
    for i in range(1, n + 1):
        yield i * i

# Consommation des éléments du générateur
squares = generate_squares(5)
for square in squares:
    print(square)  # Sortie : 1, 4, 9, 16, 25
```

La fonction génératrice `generate_squares` produit les résultats de manière paresseuse, un élément à la fois, ce qui est plus efficace en termes de mémoire, surtout si la fonction doit gérer de grands ensembles de données.

#### 5. **Utilisation des générateurs avec `next()` et `StopIteration`**

La fonction `next()` est utilisée pour obtenir le prochain élément d'un générateur. Lorsque tous les éléments ont été produits, un générateur lève l'exception `StopIteration`.

**Exemple d'utilisation de `next()` :**

```python
# Générateur de nombres
def generate_numbers():
    yield 1
    yield 2
    yield 3

gen = generate_numbers()
print(next(gen))  # Sortie : 1
print(next(gen))  # Sortie : 2
print(next(gen))  # Sortie : 3
# Appeler next() après que le générateur a épuisé ses éléments
try:
    print(next(gen))  # Lève StopIteration
except StopIteration:
    print("Fin du générateur")
```

Le générateur lève une exception `StopIteration` lorsque tous les éléments ont été produits, indiquant qu'il n'y a plus rien à itérer.

#### 6. **Générateurs et pipeline de données**

Les générateurs sont souvent utilisés pour créer des pipelines de données. Par exemple, on peut chaîner plusieurs générateurs pour effectuer une série de transformations sur les données, chaque étape n'étant calculée que lorsque nécessaire.

**Exemple de pipeline de générateurs :**

```python
# Générateur pour filtrer les nombres pairs
def filter_even(numbers):
    for number in numbers:
        if number % 2 == 0:
            yield number

# Générateur pour doubler chaque nombre
def double(numbers):
    for number in numbers:
        yield number * 2

numbers = range(10)
filtered = filter_even(numbers)
doubled = double(filtered)

for result in doubled:
    print(result)  # Sortie : 0, 4, 8, 12, 16
```

Dans cet exemple, la séquence de nombres est d'abord filtrée pour ne garder que les nombres pairs, puis chaque nombre pair est doublé. Les étapes sont effectuées de manière paresseuse, ce qui rend l'ensemble plus efficace.

#### 7. **Expression génératrice vs compréhension de liste**

Les générateurs peuvent être créés de manière similaire aux compréhensions de liste, mais la différence réside dans le fait qu'une **compréhension de liste** crée immédiatement toute la liste en mémoire, tandis qu'un **générateur** évalue les éléments un par un et n'occupe pas de mémoire pour stocker la liste complète.

**Exemple de compréhension de liste :**

```python
# Liste complète des carrés
squares_list = [x * x for x in range(5)]
print(squares_list)  # Sortie : [0, 1, 4, 9, 16]
```

**Exemple d'expression génératrice :**

```python
# Générateur des carrés (paresseux)
squares_gen = (x * x for x in range(5))
for square in squares_gen:
    print(square)  # Sortie : 0, 1, 4, 9, 16
```

L'expression génératrice est plus économe en mémoire, car elle produit les éléments un par un.

#### 8. **Résumé des avantages des générateurs**

- **Mémoire optimisée** : Les générateurs ne chargent pas toute la séquence en mémoire, ce qui est idéal pour les ensembles de données volumineux.
- **Performances améliorées** : Étant donné qu'un générateur produit les valeurs à la demande, il peut être plus rapide que de créer des structures de données complètes.
- **Simplicité** : Les générateurs peuvent simplifier le code, notamment lorsqu'on manipule des flux de données ou des séquences infinies.
- **Flexibilité** : Ils sont souvent utilisés dans des contextes où les données doivent être traitées au fur et à mesure, comme dans des pipelines ou des flux de données continus.

#### Conclusion

Les **fonctions génératrices** offrent une approche efficace pour traiter de grandes quantités de données de manière paresseuse. Elles sont largement utilisées dans les situations où les données doivent être produites au fur et à mesure et sont particulièrement adaptées pour économiser de la mémoire et améliorer la performance des

 applications traitant de grandes séquences ou des flux de données continus.

### Chapitre 4 **Décorateurs en Python**

Les **décorateurs** sont un mécanisme puissant en Python permettant de modifier ou d’étendre le comportement de fonctions ou de méthodes, sans avoir besoin de modifier leur code interne. Ils permettent d'ajouter des fonctionnalités supplémentaires de manière élégante, notamment pour la gestion des comportements transversaux, comme la gestion des logs, la validation des entrées, ou encore l'optimisation des performances.

#### 1. **Définition d'un décorateur**

Un décorateur est essentiellement une fonction qui prend une autre fonction en argument et qui retourne une nouvelle fonction modifiée. Un décorateur est appliqué à une fonction en utilisant la syntaxe du symbole `@` suivi du nom du décorateur, placé juste avant la définition de la fonction cible.

La structure de base d’un décorateur ressemble à ceci :

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        # Code exécuté avant l'appel de la fonction
        result = func(*args, **kwargs)  # Appel de la fonction d'origine
        # Code exécuté après l'appel de la fonction
        return result
    return wrapper
```

Ici, `func` est la fonction cible qui sera modifiée, et `wrapper` est la nouvelle fonction qui encapsule `func`.

#### 2. **Exemple d’un décorateur simple**

Prenons un décorateur simple qui mesure le temps d’exécution d’une fonction :

```python
import time

def timing_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()  # Démarre le chronomètre
        result = func(*args, **kwargs)  # Exécute la fonction cible
        end_time = time.time()  # Arrête le chronomètre
        print(f"{func.__name__} took {end_time - start_time} seconds to execute.")
        return result
    return wrapper

@timing_decorator
def slow_function():
    time.sleep(2)  # Simule une fonction lente

slow_function()  # Sortie : slow_function took 2.0xxxxxx seconds to execute.
```

Ici, le décorateur `timing_decorator` mesure le temps d’exécution de la fonction `slow_function`. Lorsqu'on applique le décorateur avec le symbole `@`, la fonction originale est « enveloppée » dans la fonction `wrapper`, et le comportement de la fonction cible est modifié en y ajoutant un chronomètre.

#### 3. **Pourquoi utiliser des décorateurs ?**

Les décorateurs permettent d'ajouter des comportements supplémentaires aux fonctions ou méthodes sans toucher à leur code original. Cela est particulièrement utile pour :

- **La gestion des comportements transversaux** : Par exemple, la gestion des exceptions, la journalisation (logging), la validation des entrées, ou l'optimisation des performances.
- **L’optimisation du code** : Les décorateurs permettent d'éviter la duplication de code, car un même décorateur peut être appliqué à plusieurs fonctions.
- **La séparation des préoccupations** : Ils permettent de séparer la logique principale de l’application des aspects transversaux comme les logs ou la gestion des erreurs.

#### 4. **Exemple d’un décorateur pour la validation des entrées**

Un autre cas d’utilisation des décorateurs est la validation des arguments d'une fonction. Par exemple, on peut créer un décorateur qui vérifie que l'argument d'une fonction est un nombre positif avant de l'exécuter.

```python
def positive_input_decorator(func):
    def wrapper(x):
        if x < 0:
            raise ValueError("L'entrée doit être un nombre positif.")
        return func(x)
    return wrapper

@positive_input_decorator
def square_root(x):
    return x ** 0.5

print(square_root(16))  # Sortie : 4.0
print(square_root(-16))  # Lève ValueError: L'entrée doit être un nombre positif.
```

Ici, le décorateur `positive_input_decorator` vérifie si l'argument passé à la fonction `square_root` est positif avant de permettre son exécution. Si l'argument est négatif, il lève une exception `ValueError`.

#### 5. **Décorateurs avec plusieurs arguments**

Les décorateurs peuvent être plus complexes, surtout lorsqu'ils doivent prendre plusieurs arguments. Il est possible de créer des décorateurs avec des arguments supplémentaires, ce qui les rend encore plus puissants.

**Exemple de décorateur avec un argument supplémentaire :**

```python
def repeat_decorator(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(n):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat_decorator(3)
def greet(name):
    print(f"Bonjour, {name}!")

greet("Alice")  # Sortie : Bonjour, Alice! (affiché 3 fois)
```

Ici, le décorateur `repeat_decorator` prend un argument `n` qui spécifie le nombre de fois que la fonction cible doit être appelée. Le décorateur `@repeat_decorator(3)` appelle la fonction `greet` trois fois, ce qui permet de répéter une action.

#### 6. **Chainer plusieurs décorateurs**

Il est possible d’appliquer plusieurs décorateurs à une même fonction. Lorsqu'on applique plusieurs décorateurs, Python les applique dans l’ordre inverse, c’est-à-dire de bas en haut dans le code.

**Exemple de plusieurs décorateurs :**

```python
def decorator_one(func):
    def wrapper(*args, **kwargs):
        print("Décorateur 1")
        return func(*args, **kwargs)
    return wrapper

def decorator_two(func):
    def wrapper(*args, **kwargs):
        print("Décorateur 2")
        return func(*args, **kwargs)
    return wrapper

@decorator_one
@decorator_two
def hello():
    print("Bonjour")

hello()
```

**Sortie :**
```
Décorateur 1
Décorateur 2
Bonjour
```

Ici, `hello` est décorée d'abord par `decorator_two`, puis par `decorator_one`. Python applique les décorateurs dans l'ordre inverse de leur déclaration.

#### 7. **Les décorateurs de méthodes de classe**

Les décorateurs peuvent également être appliqués aux méthodes de classe ou aux méthodes statiques. Un décorateur courant dans ce cas est `@classmethod` et `@staticmethod`.

**Exemple d'un décorateur `classmethod` :**

```python
class MyClass:
    @classmethod
    def greet(cls):
        print(f"Bonjour depuis la classe {cls.__name__}!")

MyClass.greet()  # Sortie : Bonjour depuis la classe MyClass!
```

Le décorateur `@classmethod` transforme une méthode en méthode de classe, ce qui permet de l'appeler directement sur la classe et non sur une instance.

**Exemple d'un décorateur `staticmethod` :**

```python
class MyClass:
    @staticmethod
    def greet():
        print("Bonjour depuis une méthode statique!")

MyClass.greet()  # Sortie : Bonjour depuis une méthode statique!
```

Le décorateur `@staticmethod` transforme une méthode en méthode statique, ce qui permet de l'appeler directement sur la classe sans nécessiter d'instance.

#### 8. **Résumé des avantages des décorateurs**

Les décorateurs sont un moyen puissant d’étendre ou de modifier le comportement de fonctions et de méthodes sans toucher directement à leur code. Voici les principaux avantages des décorateurs :

- **Réutilisation du code** : Un décorateur peut être appliqué à plusieurs fonctions, ce qui évite la duplication de code.
- **Séparation des préoccupations** : Ils permettent de séparer la logique principale d’une fonction de comportements transversaux comme la journalisation, la gestion des erreurs, ou la validation des entrées.
- **Lisibilité** : Les décorateurs rendent le code plus lisible en regroupant des fonctionnalités supplémentaires dans des fonctions externes et réutilisables.

#### Conclusion

Les **décorateurs** en Python sont un outil puissant permettant de modifier ou d'étendre le comportement d'autres fonctions ou méthodes sans modifier leur code interne. Ils sont très utilisés pour ajouter des comportements transversaux comme la gestion des erreurs, la validation des données, ou l'optimisation des performances. Ils permettent de rendre le code plus modulaire, réutilisable et lisible.

### Chapitre 5 **Gestion des exceptions en Python (Try/Except/Finally)**

La **gestion des exceptions** en Python permet de capturer et de traiter les erreurs qui peuvent survenir pendant l'exécution d'un programme. Au lieu de laisser l'erreur interrompre l'exécution du programme, on peut l'intercepter, la traiter de manière appropriée, et ainsi rendre le programme plus robuste et moins susceptible de planter en cas de problème. Python fournit plusieurs mécanismes pour gérer ces erreurs, principalement à travers les blocs `try`, `except` et `finally`.

#### 1. **Le bloc `try`**

Le bloc `try` est utilisé pour encapsuler un code qui peut potentiellement générer une exception. Lorsque Python exécute un programme et rencontre une instruction dans le bloc `try` qui déclenche une exception, l'exécution du code dans ce bloc s'arrête immédiatement et l'exception est envoyée au bloc `except` associé, si présent.

#### 2. **Le bloc `except`**

Le bloc `except` est utilisé pour intercepter l'exception levée dans le bloc `try` et exécuter du code pour la gérer. Il peut capturer des exceptions spécifiques ou toutes les exceptions possibles. Si une exception correspond à un type spécifié, le code à l’intérieur du bloc `except` sera exécuté. Si aucune exception n’est levée, ce bloc est ignoré.

#### 3. **Le bloc `finally`**

Le bloc `finally` contient du code qui sera exécuté **dans tous les cas**, que l'exception ait été levée ou non. Cela permet d'assurer l'exécution de certaines actions de nettoyage, comme la fermeture de fichiers ou la libération de ressources, indépendamment du fait qu'une exception soit survenue ou non. Le bloc `finally` est optionnel.

#### 4. **Syntaxe de base :**

```python
try:
    # Code susceptible de générer une exception
except SomeException as e:
    # Code pour gérer l'exception
finally:
    # Code à exécuter dans tous les cas
```

#### 5. **Exemple avec gestion d’une exception spécifique**

Prenons un exemple où l’on tente de diviser un nombre par un autre. Si le diviseur est égal à zéro, une exception `ZeroDivisionError` sera levée. Nous allons la capturer et afficher un message d'erreur.

```python
try:
    x = 10 / 0
except ZeroDivisionError as e:
    print(f"Erreur : {e}")
finally:
    print("Bloc finally exécuté.")
```

**Sortie :**

```
Erreur : division by zero
Bloc finally exécuté.
```

Dans cet exemple, la division par zéro génère une exception `ZeroDivisionError`. Cette exception est capturée par le bloc `except`, et le message d'erreur est affiché. Le bloc `finally` est toujours exécuté, quelle que soit l'issue du bloc `try`.

#### 6. **Gestion de plusieurs exceptions**

Il est possible de gérer différentes exceptions de manière séparée en utilisant plusieurs blocs `except`. Python teste les exceptions dans l’ordre dans lequel elles sont définies. Dès qu'une exception correspond, le bloc `except` approprié est exécuté.

```python
try:
    x = int(input("Entrez un nombre : "))
    result = 10 / x
except ZeroDivisionError as e:
    print("Erreur : Division par zéro.")
except ValueError as e:
    print("Erreur : Entrée invalide. Veuillez entrer un nombre.")
finally:
    print("Bloc finally exécuté.")
```

**Exemples de sortie :**

- Si l'utilisateur entre un zéro, la sortie sera :
  ```
  Erreur : Division par zéro.
  Bloc finally exécuté.
  ```
- Si l'utilisateur entre une valeur non numérique, la sortie sera :
  ```
  Erreur : Entrée invalide. Veuillez entrer un nombre.
  Bloc finally exécuté.
  ```

#### 7. **Capturer toutes les exceptions avec `except` générique**

Il est également possible d'attraper toutes les exceptions sans spécifier un type particulier. Cela peut être utile si vous voulez capturer toutes les erreurs possibles, mais cela doit être utilisé avec prudence, car il pourrait masquer des erreurs imprévues.

```python
try:
    x = 10 / 0
except Exception as e:
    print(f"Une erreur s'est produite : {e}")
finally:
    print("Bloc finally exécuté.")
```

**Sortie :**

```
Une erreur s'est produite : division by zero
Bloc finally exécuté.
```

Dans ce cas, l'exception `ZeroDivisionError` est capturée par le bloc `except` qui utilise `Exception`, la classe de base de toutes les exceptions en Python.

#### 8. **Ressources à libérer avec `finally`**

Le bloc `finally` est particulièrement utile pour garantir que des actions de nettoyage sont effectuées, indépendamment du fait qu’une exception ait eu lieu ou non. Par exemple, on peut l'utiliser pour fermer un fichier ou une connexion à une base de données.

**Exemple avec la gestion d’un fichier :**

```python
try:
    file = open("example.txt", "r")
    data = file.read()
    # Simuler une exception
    x = 10 / 0
except ZeroDivisionError:
    print("Erreur de division.")
finally:
    file.close()  # Le fichier est toujours fermé, qu'une exception ait été levée ou non
    print("Le fichier a été fermé.")
```

**Sortie :**

```
Erreur de division.
Le fichier a été fermé.
```

Ici, même si une exception est levée pendant l'exécution du bloc `try`, le fichier est toujours fermé grâce au bloc `finally`.

#### 9. **Lever des exceptions avec `raise`**

Il est également possible de lever des exceptions de manière explicite dans le code, en utilisant l'instruction `raise`. Cela peut être utile pour forcer une erreur si une condition particulière est rencontrée dans le programme.

```python
def validate_age(age):
    if age < 18:
        raise ValueError("L'âge doit être supérieur ou égal à 18.")
    print("Âge valide.")

try:
    validate_age(16)
except ValueError as e:
    print(f"Erreur : {e}")
finally:
    print("Vérification terminée.")
```

**Sortie :**

```
Erreur : L'âge doit être supérieur ou égal à 18.
Vérification terminée.
```

Ici, une exception `ValueError` est levée explicitement dans la fonction `validate_age` lorsque l'âge est inférieur à 18, et elle est capturée et gérée par le bloc `except`.

#### 10. **Exception personnalisée**

Il est également possible de définir des exceptions personnalisées en créant une nouvelle classe d'exception. Cela permet de mieux contrôler les erreurs spécifiques à une application ou à un contexte particulier.

```python
class CustomError(Exception):
    pass

try:
    raise CustomError("C'est une erreur personnalisée.")
except CustomError as e:
    print(f"Erreur capturée : {e}")
```

**Sortie :**

```
Erreur capturée : C'est une erreur personnalisée.
```

#### 11. **Résumé des concepts clés**

- **Bloc `try`** : Contient le code qui peut générer une exception.
- **Bloc `except`** : Capture les exceptions générées dans le bloc `try` et exécute le code de gestion d’erreur.
- **Bloc `finally`** : Code qui sera exécuté dans tous les cas, qu’une exception soit levée ou non.
- **`raise`** : Permet de lever une exception explicitement dans le programme.
- **Exception personnalisée** : Création de nouvelles exceptions spécifiques à votre application.

#### Conclusion

La **gestion des exceptions** avec `try`, `except`, et `finally` est essentielle pour rendre un programme Python plus robuste et tolérant aux erreurs. En capturant et en gérant les erreurs de manière appropriée, on peut éviter que le programme ne plante brutalement et assurer un nettoyage ou une fermeture appropriée des ressources. Les décorateurs, les exceptions personnalisées, et l’utilisation des blocs `finally` permettent de rendre la gestion des erreurs encore plus flexible et puissante.

### Chapitre 6 **Modules et Paquets en Python**

En Python, l’organisation et la structuration du code sont facilitées par l’utilisation des **modules** et des **paquets**. Ces concepts permettent de mieux gérer les projets en séparant le code en fichiers plus petits et réutilisables, ce qui améliore la lisibilité, la maintenance et la modularité du code.

#### 1. **Module**
Un **module** en Python est un fichier contenant du code Python. Il peut contenir des fonctions, des classes et des variables, et il permet de structurer le code en petites unités logiques et réutilisables. Un fichier Python avec une extension `.py` est automatiquement considéré comme un module. Le nom du fichier devient le nom du module.

##### Utilisation d'un module :
- **Création d'un module** : On peut créer un module en enregistrant du code Python dans un fichier avec l'extension `.py`. Par exemple, un fichier nommé `calcul.py` contenant des fonctions mathématiques simples est un module.

```python
# calcul.py
def addition(a, b):
    return a + b

def multiplication(a, b):
    return a * b
```

- **Utilisation d’un module** : Un autre fichier Python peut importer et utiliser ce module pour accéder à ses fonctions.

```python
# programme.py
import calcul

resultat_addition = calcul.addition(5, 3)
resultat_multiplication = calcul.multiplication(4, 6)

print(resultat_addition)  # Affiche 8
print(resultat_multiplication)  # Affiche 24
```

- **Importation sélective** : Vous pouvez également importer des fonctions spécifiques d'un module en utilisant la syntaxe `from ... import ...`.

```python
from calcul import addition

resultat = addition(10, 5)
print(resultat)  # Affiche 15
```

- **Renommer un module ou une fonction** : Il est possible de renommer les modules ou fonctions lors de leur importation en utilisant le mot-clé `as`.

```python
import calcul as c

resultat = c.addition(1, 2)
print(resultat)  # Affiche 3
```

#### 2. **Paquet (Package)**
Un **paquet** en Python est un répertoire contenant plusieurs modules. Il permet de regrouper des modules liés entre eux sous un même répertoire afin de mieux organiser le projet. Un paquet doit contenir un fichier spécial nommé `__init__.py` pour indiquer à Python que ce répertoire doit être traité comme un paquet. Le fichier `__init__.py` peut être vide ou contenir du code d'initialisation pour le paquet.

##### Structure d’un paquet :
La structure d’un paquet peut ressembler à ceci :

```
mon_paquet/
│
├── __init__.py
├── module1.py
├── module2.py
└── sous_paquet/
    ├── __init__.py
    ├── module3.py
    └── module4.py
```

- **Accéder aux modules d’un paquet** : Vous pouvez importer des modules d’un paquet de la même manière que pour un module classique, en utilisant la syntaxe `import`. Si le paquet contient un sous-paquet, vous pouvez y accéder en spécifiant le chemin du sous-paquet.

```python
# programme.py
import mon_paquet.module1

mon_paquet.module1.fonction1()

from mon_paquet.sous_paquet import module3
module3.fonction3()
```

#### 3. **Les fonctions spéciales d’un paquet**

- **`__init__.py`** : Ce fichier est essentiel pour que Python reconnaisse un répertoire comme un paquet. Dans ce fichier, vous pouvez définir des initialisations ou des importations globales pour votre paquet.

```python
# mon_paquet/__init__.py
from .module1 import fonction1
from .module2 import fonction2
```

Cela permet de simplifier l’importation des modules de votre paquet en regroupant certains éléments sous un même nom.

```python
# programme.py
from mon_paquet import fonction1

fonction1()
```

Ici, au lieu de devoir importer directement `mon_paquet.module1.fonction1`, vous pouvez importer directement `fonction1` depuis le paquet, grâce à l'importation dans le fichier `__init__.py`.

#### 4. **Importation relative et absolue**

- **Importation absolue** : Lorsqu’un module ou un paquet est importé en spécifiant son chemin complet depuis la racine du projet, on parle d’importation absolue. C’est la méthode la plus courante.

```python
import mon_paquet.module1
```

- **Importation relative** : Python permet d’utiliser des importations relatives, c’est-à-dire d’importer des modules dans un même paquet ou sous-paquet à l’aide de chemins relatifs. Cela peut être utile pour organiser de manière plus flexible les imports à l’intérieur de grands projets.

```python
# Dans mon_paquet/sous_paquet/module4.py
from .module3 import fonction3  # Importation relative
from ..module2 import fonction2  # Importation depuis un niveau supérieur
```

#### 5. **Utilisation de `sys.path` pour ajouter des chemins personnalisés**

La liste `sys.path` contient les répertoires où Python cherche les modules à importer. Vous pouvez ajouter un répertoire à cette liste pour que Python y cherche des modules, ce qui est pratique si vous organisez vos modules en dehors du répertoire du projet.

```python
import sys
sys.path.append('/chemin/vers/mon/paquet')

import mon_paquet
```

#### 6. **Installation de paquets tiers avec `pip`**

En plus de vos propres paquets, Python permet d’installer des paquets externes via le gestionnaire de paquets `pip`. Ces paquets peuvent être installés depuis des archives locales ou des dépôts en ligne comme PyPI (Python Package Index).

- **Installation d'un paquet via `pip`** : 

```bash
pip install numpy
```

Après l'installation, vous pouvez importer et utiliser le module dans votre code Python.

```python
import numpy as np

arr = np.array([1, 2, 3])
```

#### 7. **Avantages des modules et paquets**

- **Modularité** : Les modules et paquets permettent de diviser un projet en plusieurs fichiers, rendant le code plus lisible, maintenable et réutilisable.
- **Réutilisation** : Vous pouvez réutiliser un module ou un paquet dans différents projets, réduisant ainsi la duplication du code.
- **Organisation** : Un projet bien structuré avec des modules et des paquets est plus facile à gérer, surtout lorsqu’il devient plus volumineux.

#### 8. **Résumé des concepts clés**

- **Module** : Un fichier Python `.py` contenant des fonctions, classes ou variables. On l’utilise pour organiser le code.
- **Paquet** : Un répertoire contenant plusieurs modules, et qui nécessite un fichier `__init__.py` pour être reconnu par Python.
- **Importation absolue et relative** : Permet d'importer des modules et paquets en spécifiant leur chemin complet ou relatif.
- **Gestion des dépendances** : Utilisation de `pip` pour installer des paquets externes et les importer dans vos projets.
- **Organisation du projet** : Structurer le projet en modules et paquets pour une gestion optimale.

#### Conclusion

L’utilisation des **modules et paquets** est essentielle pour organiser le code Python de manière efficace et modulaire. Cela permet de rendre les projets plus lisibles, plus maintenables, et facilite leur réutilisation dans d’autres projets. Grâce aux outils comme l’importation, les paquets, et le gestionnaire de dépendances `pip`, Python permet de créer des projets bien structurés et faciles à gérer, même à grande échelle.

### Chapitre 7 **Manipulation des fichiers (Lecture/Écriture) en Python**

La manipulation des fichiers en Python permet de lire, écrire et gérer les fichiers stockés sur le disque. Python offre des outils puissants et simples pour interagir avec différents types de fichiers (textes, binaires, CSV, JSON, etc.) à l’aide des modes appropriés. Cela inclut la lecture, l’écriture, l’ajout de données, ainsi que la gestion des erreurs liées aux fichiers.

#### 1. **Ouverture de fichiers**

Pour interagir avec un fichier, la première étape consiste à l'ouvrir avec la fonction `open()`. Cette fonction prend en paramètre le chemin du fichier ainsi que le mode dans lequel le fichier doit être ouvert. 

La syntaxe est la suivante :

```python
file = open("chemin/vers/fichier", mode)
```

##### Modes d’ouverture de fichiers :
- **`'r'`** : Lecture (Read). Ouvre le fichier en lecture seule. Le fichier doit exister.
- **`'w'`** : Écriture (Write). Ouvre le fichier en écriture, crée le fichier s'il n'existe pas. Si le fichier existe, son contenu est écrasé.
- **`'a'`** : Ajout (Append). Ouvre le fichier en écriture, ajoute les données à la fin du fichier existant, sans écraser son contenu.
- **`'b'`** : Mode binaire. Utilisé en combinaison avec les autres modes (`'rb'`, `'wb'`, etc.) pour ouvrir un fichier en mode binaire.
- **`'x'`** : Création exclusive (exclusive creation). Ouvre le fichier pour l’écriture, mais échoue si le fichier existe déjà.
- **`'t'`** : Mode texte (Text). C'est le mode par défaut et il peut être combiné avec d’autres modes (par exemple `'rt'` pour lire un fichier texte).
  
#### 2. **Lecture de fichiers**

Une fois un fichier ouvert en mode lecture (`'r'`), vous pouvez en extraire le contenu de plusieurs manières :

- **`read()`** : Lit tout le contenu du fichier en une seule fois.

  ```python
  with open("mon_fichier.txt", "r") as file:
      contenu = file.read()
      print(contenu)
  ```

- **`readline()`** : Lit une ligne à la fois, utile pour lire un fichier ligne par ligne.

  ```python
  with open("mon_fichier.txt", "r") as file:
      ligne = file.readline()
      while ligne:
          print(ligne.strip())  # `.strip()` pour enlever les retours à la ligne
          ligne = file.readline()
  ```

- **`readlines()`** : Lit toutes les lignes et les renvoie sous forme de liste.

  ```python
  with open("mon_fichier.txt", "r") as file:
      lignes = file.readlines()
      for ligne in lignes:
          print(ligne.strip())
  ```

#### 3. **Écriture dans un fichier**

L’écriture dans un fichier se fait en mode `'w'` (écrasement) ou `'a'` (ajout). Il est également possible d’écrire des chaînes de caractères, des nombres ou des objets sous forme de texte.

- **`write()`** : Écrit une chaîne de caractères dans un fichier. Si le fichier est ouvert en mode `'w'`, il écrasera son contenu précédent, sinon il l'ajoutera en mode `'a'`.

  ```python
  with open("mon_fichier.txt", "w") as file:
      file.write("Bonjour, ceci est un test.\n")
  ```

- **`writelines()`** : Écrit plusieurs lignes dans un fichier, attend une séquence (comme une liste) d'éléments. Les éléments de la liste ne sont pas automatiquement séparés par des retours à la ligne.

  ```python
  lignes = ["Première ligne.\n", "Deuxième ligne.\n", "Troisième ligne.\n"]
  with open("mon_fichier.txt", "w") as file:
      file.writelines(lignes)
  ```

#### 4. **Mode binaire**

Les fichiers binaires sont souvent utilisés pour les images, les vidéos, les fichiers audio et d’autres types de données non textuelles. Dans ce cas, vous devez ouvrir le fichier en mode binaire avec `'rb'` ou `'wb'`.

- **Lecture d'un fichier binaire** : Pour lire un fichier binaire, vous devez utiliser la méthode `read()` avec le mode `'rb'`.

  ```python
  with open("image.jpg", "rb") as file:
      contenu_binaire = file.read()
  ```

- **Écriture d'un fichier binaire** : De même, pour écrire des données binaires, vous utilisez le mode `'wb'`.

  ```python
  with open("image_copy.jpg", "wb") as file:
      file.write(contenu_binaire)
  ```

#### 5. **Gestion des erreurs et fermeture des fichiers**

Lorsque vous ouvrez un fichier, il est important de le fermer une fois que vous avez terminé de l'utiliser, afin de libérer les ressources et garantir que toutes les écritures sont correctement effectuées. La méthode `close()` est utilisée pour cela, mais une approche plus courante et plus sûre consiste à utiliser un **contexte de gestionnaire de fichiers**, avec l'instruction `with`. Cela garantit que le fichier est correctement fermé, même en cas d’erreur.

```python
with open("mon_fichier.txt", "r") as file:
    contenu = file.read()
# Pas besoin de file.close(), car 'with' se charge de fermer le fichier
```

#### 6. **Gestion des exceptions liées aux fichiers**

Lors de la manipulation de fichiers, des erreurs peuvent survenir, par exemple si le fichier n’existe pas ou si vous n’avez pas les autorisations nécessaires. Vous pouvez gérer ces exceptions avec un bloc `try`-`except`.

```python
try:
    with open("mon_fichier.txt", "r") as file:
        contenu = file.read()
except FileNotFoundError:
    print("Le fichier n'existe pas.")
except PermissionError:
    print("Vous n'avez pas la permission d'accéder à ce fichier.")
except Exception as e:
    print(f"Une erreur est survenue : {e}")
```

#### 7. **Travail avec des fichiers CSV**

Python offre la bibliothèque **`csv`** pour travailler avec des fichiers CSV, qui sont couramment utilisés pour stocker des données tabulaires. La lecture et l'écriture dans des fichiers CSV sont simples à effectuer avec les fonctions `csv.reader` et `csv.writer`.

- **Lire un fichier CSV** :

  ```python
  import csv
  with open('mon_fichier.csv', 'r') as file:
      lecteur = csv.reader(file)
      for ligne in lecteur:
          print(ligne)
  ```

- **Écrire dans un fichier CSV** :

  ```python
  import csv
  with open('mon_fichier.csv', 'w', newline='') as file:
      ecrivain = csv.writer(file)
      ecrivain.writerow(['Nom', 'Prénom', 'Âge'])
      ecrivain.writerow(['Dupont', 'Jean', 28])
  ```

#### 8. **Travail avec des fichiers JSON**

Le module **`json`** permet de lire et écrire des fichiers JSON, qui sont utilisés pour échanger des données dans des applications web, par exemple.

- **Lire un fichier JSON** :

  ```python
  import json
  with open('mon_fichier.json', 'r') as file:
      data = json.load(file)
      print(data)
  ```

- **Écrire dans un fichier JSON** :

  ```python
  import json
  data = {"nom": "Jean", "prénom": "Dupont", "âge": 28}
  with open('mon_fichier.json', 'w') as file:
      json.dump(data, file)
  ```

#### 9. **Résumé des concepts clés**

- **Ouverture de fichiers** : Utiliser `open()` avec différents modes (`'r'`, `'w'`, `'a'`, etc.) pour ouvrir un fichier selon l’opération souhaitée.
- **Lecture de fichiers** : Utiliser `read()`, `readline()`, ou `readlines()` pour lire le contenu du fichier.
- **Écriture dans un fichier** : Utiliser `write()` ou `writelines()` pour écrire des données dans un fichier.
- **Gestion des fichiers binaires** : Ouvrir les fichiers en mode binaire avec `'rb'` ou `'wb'` pour traiter des données non textuelles.
- **Gestion des erreurs** : Utiliser `try`-`except` pour capturer les erreurs liées aux fichiers et garantir une gestion appropriée des erreurs.
- **Gestion des ressources** : Utiliser `with` pour ouvrir et fermer automatiquement un fichier en garantissant sa fermeture correcte.
- **Fichiers CSV et JSON** : Utiliser les modules `csv` et `json` pour manipuler des fichiers dans ces formats spécifiques.

#### Conclusion

La manipulation des fichiers en Python est un aspect essentiel pour gérer des données persistantes, qu'il s'agisse de fichiers texte, binaires, CSV, ou JSON. Python offre des outils puissants et simples pour effectuer toutes les opérations nécessaires, tout en garantissant une gestion efficace des erreurs et des ressources.

### Chapitre 8 **Listes, tuples et dictionnaires avancés**

Les **listes**, **tuples**, et **dictionnaires** sont des structures de données de collection fondamentales en Python. Elles permettent de stocker, d'organiser et de manipuler des ensembles de données. Cette section explore des techniques avancées pour la gestion de ces structures, y compris l'itération, la modification, ainsi que l'application de fonctions spécifiques pour transformer et manipuler ces collections.

#### 1. **Listes avancées**

Les listes sont des structures de données qui peuvent contenir plusieurs éléments, modifiables et ordonnés. Python offre plusieurs méthodes et fonctionnalités pour travailler efficacement avec les listes.

##### a. **Itération avancée sur les listes**

- **Itération avec `enumerate()`** : Pour obtenir à la fois l'index et la valeur lors de l'itération.
  ```python
  ma_liste = ["a", "b", "c", "d"]
  for index, valeur in enumerate(ma_liste):
      print(f"Index {index}: {valeur}")
  ```
- **Listes imbriquées** : Utilisation de boucles imbriquées pour manipuler des listes contenant d'autres listes.
  ```python
  liste_imbricatee = [[1, 2], [3, 4], [5, 6]]
  for sous_liste in liste_imbricatee:
      for element in sous_liste:
          print(element)
  ```

##### b. **Modification et manipulation avancée des listes**

- **Ajout d'éléments avec `insert()` et `extend()`** :

  - `insert(index, valeur)` permet d'ajouter un élément à un index spécifique.
  - `extend(iterable)` permet d'ajouter tous les éléments d'un itérable (liste, ensemble, etc.) à la fin de la liste.
  ```python
  ma_liste = [1, 2, 3]
  ma_liste.insert(1, 'a')  # Insertion à l'index 1
  ma_liste.extend([4, 5])  # Ajout de plusieurs éléments
  ```

- **Suppression d'éléments avec `pop()` et `remove()`** :

  - `pop(index)` retire et renvoie l'élément à l'index spécifié.
  - `remove(valeur)` supprime la première occurrence de la valeur dans la liste.
  ```python
  ma_liste = [1, 2, 3, 4, 5]
  ma_liste.pop(2)  # Supprime l'élément à l'index 2 (3)
  ma_liste.remove(4)  # Supprime la première occurrence de 4
  ```

##### c. **Compréhension de liste avancée**

- Vous pouvez utiliser des expressions conditionnelles complexes dans une compréhension de liste.

  ```python
  # Créer une liste de carrés des nombres pairs
  chiffres = [1, 2, 3, 4, 5, 6]
  carrés_pairs = [x**2 for x in chiffres if x % 2 == 0]
  print(carrés_pairs)  # [4, 16, 36]
  ```

#### 2. **Tuples avancés**

Les tuples sont des collections ordonnées et immuables. Une fois créés, leurs éléments ne peuvent pas être modifiés. Cependant, ils sont utilisés pour des situations où l’immuabilité est importante et offrent une performance légèrement meilleure que les listes.

##### a. **Itération sur les tuples**

L'itération sur les tuples est similaire à celle des listes, mais comme les tuples sont immuables, vous devez comprendre que vous ne pouvez pas les modifier pendant l'itération.

```python
mon_tuple = (1, 2, 3, 4)
for element in mon_tuple:
    print(element)
```

##### b. **Manipulation avancée des tuples**

- **Concaténation et multiplication de tuples** : Vous pouvez concaténer plusieurs tuples ou les multiplier.

  ```python
  tuple1 = (1, 2, 3)
  tuple2 = (4, 5)
  tuple_concaténé = tuple1 + tuple2  # (1, 2, 3, 4, 5)
  tuple_multiplié = tuple1 * 2  # (1, 2, 3, 1, 2, 3)
  ```

##### c. **Accès aux éléments du tuple**

Comme pour les listes, l'accès aux éléments d'un tuple se fait par index. Vous pouvez également utiliser des tranches pour obtenir des sous-parties du tuple.

```python
mon_tuple = (10, 20, 30, 40)
print(mon_tuple[1])  # 20
print(mon_tuple[1:3])  # (20, 30)
```

#### 3. **Dictionnaires avancés**

Les dictionnaires sont des collections non ordonnées de paires clé-valeur. Les clés sont uniques, et chaque clé est associée à une valeur. Les dictionnaires permettent un accès rapide aux éléments en fonction des clés.

##### a. **Itération sur les dictionnaires**

- **Itération sur les clés, valeurs et paires clé-valeur** :

  - `dict.keys()` renvoie un itérable sur les clés.
  - `dict.values()` renvoie un itérable sur les valeurs.
  - `dict.items()` renvoie un itérable sur les paires clé-valeur.
  ```python
  mon_dict = {"a": 1, "b": 2, "c": 3}
  for clé, valeur in mon_dict.items():
      print(f"{clé}: {valeur}")
  ```

##### b. **Manipulation avancée des dictionnaires**

- **Ajout et modification des éléments d’un dictionnaire** : Vous pouvez ajouter de nouvelles paires ou modifier les valeurs existantes en utilisant les clés.

  ```python
  mon_dict = {"a": 1, "b": 2}
  mon_dict["c"] = 3  # Ajout d'une nouvelle paire
  mon_dict["a"] = 10  # Modification de la valeur associée à la clé "a"
  ```

- **Suppression d’éléments** : Vous pouvez utiliser `del` pour supprimer une paire clé-valeur ou la méthode `pop()`.

  ```python
  mon_dict = {"a": 1, "b": 2, "c": 3}
  del mon_dict["b"]  # Suppression de la paire avec la clé "b"
  valeur = mon_dict.pop("a")  # Suppression et récupération de la valeur associée à "a"
  ```

##### c. **Compréhension de dictionnaire**

Tout comme les listes, vous pouvez utiliser des expressions conditionnelles dans une compréhension de dictionnaire pour créer de nouveaux dictionnaires à partir d'itérables.

```python
# Créer un dictionnaire avec les carrés des nombres
nombres = [1, 2, 3, 4, 5]
dictionnaire_carré = {x: x**2 for x in nombres}
print(dictionnaire_carré)  # {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
```

##### d. **Dictionnaires imbriqués**

Les dictionnaires peuvent également contenir d’autres dictionnaires comme valeurs, permettant ainsi une structure de données plus complexe.

```python
dico_embarque = {"A": {"nom": "Alice", "âge": 30}, "B": {"nom": "Bob", "âge": 25}}
print(dico_embarque["A"]["nom"])  # "Alice"
```

#### 4. **Opérations avancées sur les collections**

##### a. **Fusionner des dictionnaires**

Depuis Python 3.5+, vous pouvez utiliser l’opérateur `**` pour fusionner plusieurs dictionnaires.
```python
d1 = {"a": 1, "b": 2}
d2 = {"c": 3, "d": 4}
fusion = {**d1, **d2}
print(fusion)  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}
```

##### b. **Tri des collections**

Les listes, tuples et dictionnaires peuvent être triés en utilisant des fonctions comme `sorted()`, mais les dictionnaires ne sont pas ordonnés jusqu’à Python 3.7+.

- Tri d’une liste :
  ```python
  ma_liste = [5, 2, 9, 1]
  sorted_liste = sorted(ma_liste)  # [1, 2, 5, 9]
  ```

- Tri des dictionnaires par clé ou valeur :

  ```python
  mon_dict = {"b": 3, "a": 2, "c": 1}
  trié_par_clé = dict(sorted(mon_dict.items()))  # Trie par clés
  trié_par_valeur = dict(sorted(mon_dict.items(), key=lambda item: item[1]))  # Trie par valeur
  ```

#### 5. **Résumé des concepts clés**

- **Listes** : Collections ordonnées et modifiables, permettant l'itération, l'ajout, la suppression, la modification, et l'application de transformations via la compréhension de liste.
- **Tuples** : Collections ordonnées et immuables, utiles pour des situations nécessitant une performance optimale et

 l'immuabilité.
- **Dictionnaires** : Collections de paires clé-valeur, efficaces pour un accès rapide aux éléments via des clés. La manipulation avancée inclut l’itération, la modification, et la fusion de dictionnaires.

### Conclusion
Ces concepts permettent une gestion avancée et performante des structures de données en Python, et peuvent être combinés pour résoudre des problèmes plus complexes de manière élégante et efficace.

### Chapitre 9 **Compréhension de dictionnaire**

La **compréhension de dictionnaire** est une technique puissante en Python permettant de créer des dictionnaires de manière concise et efficace. Elle repose sur une syntaxe similaire à celle des **compréhensions de liste**, mais elle inclut des paires clé-valeur. Cette méthode permet d’appliquer des transformations ou des filtres tout en créant des dictionnaires.

#### 1. **Syntaxe de la compréhension de dictionnaire**

La syntaxe de base d’une compréhension de dictionnaire est la suivante :

```python
{clé_expression: valeur_expression for élément in itérable if condition}
```

- **`clé_expression`** : Une expression qui détermine la clé du dictionnaire.
- **`valeur_expression`** : Une expression qui détermine la valeur associée à la clé.
- **`itérable`** : Une séquence ou un objet itérable à partir duquel les éléments seront extraits.
- **`condition` (facultatif)** : Un test conditionnel pour filtrer les éléments à inclure dans le dictionnaire.

#### 2. **Création de dictionnaires simples avec une compréhension**

Une compréhension de dictionnaire peut être utilisée pour créer rapidement un dictionnaire à partir d’une liste, d’un ensemble ou d’un autre dictionnaire.

Exemple 1 : Créer un dictionnaire avec des carrés des nombres dans une liste.

```python
nombres = [1, 2, 3, 4, 5]
dictionnaire_carrés = {x: x**2 for x in nombres}
print(dictionnaire_carrés)  
# Résultat : {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
```

Ici, chaque élément de la liste `nombres` est utilisé comme clé, et la valeur associée est le carré de ce nombre.

#### 3. **Ajout de conditions dans la compréhension de dictionnaire**

Vous pouvez également ajouter une **condition** pour filtrer les éléments à inclure dans le dictionnaire. Par exemple, créer un dictionnaire des carrés des nombres pairs uniquement.

```python
nombres = [1, 2, 3, 4, 5]
dictionnaire_carrés_pairs = {x: x**2 for x in nombres if x % 2 == 0}
print(dictionnaire_carrés_pairs)
# Résultat : {2: 4, 4: 16}
```

Dans cet exemple, seule la valeur `x` qui est paire est incluse dans le dictionnaire, et chaque clé correspond à un nombre pair avec sa valeur étant son carré.

#### 4. **Manipulation de dictionnaires avec une compréhension**

Une compréhension de dictionnaire peut aussi être utilisée pour transformer des dictionnaires existants en appliquant des modifications à leurs clés ou valeurs.

Exemple 2 : Modifier les valeurs d’un dictionnaire existant en les multipliant par 2.

```python
dico_original = {'a': 1, 'b': 2, 'c': 3}
dico_modifié = {k: v*2 for k, v in dico_original.items()}
print(dico_modifié)
# Résultat : {'a': 2, 'b': 4, 'c': 6}
```

Ici, le dictionnaire `dico_modifié` est créé en multipliant chaque valeur de `dico_original` par 2.

#### 5. **Utilisation de plusieurs sources dans une compréhension de dictionnaire**

Vous pouvez combiner plusieurs itérables dans une compréhension de dictionnaire pour créer un dictionnaire plus complexe. Par exemple, combiner une liste de clés et une liste de valeurs.

```python
clés = ['a', 'b', 'c']
valeurs = [1, 2, 3]
dico_combiné = {clés[i]: valeurs[i] for i in range(len(clés))}
print(dico_combiné)
# Résultat : {'a': 1, 'b': 2, 'c': 3}
```

Dans cet exemple, les éléments de la liste `clés` sont associés aux éléments correspondants dans la liste `valeurs`.

#### 6. **Création de dictionnaires imbriqués avec une compréhension**

Il est également possible de créer des dictionnaires imbriqués avec des compréhensions de dictionnaires. Par exemple, créer un dictionnaire où chaque valeur est elle-même un dictionnaire.

```python
clés = ['a', 'b', 'c']
valeurs = [1, 2, 3]
dico_imbriqué = {clé: {'valeur': valeur} for clé, valeur in zip(clés, valeurs)}
print(dico_imbriqué)
# Résultat : {'a': {'valeur': 1}, 'b': {'valeur': 2}, 'c': {'valeur': 3}}
```

Dans cet exemple, chaque clé est associée à un dictionnaire contenant une clé `valeur` avec la valeur correspondante.

#### 7. **Utilisation de fonctions dans une compréhension de dictionnaire**

Vous pouvez également appliquer des fonctions aux clés ou valeurs dans la compréhension de dictionnaire. Par exemple, en appliquant une fonction qui modifie la valeur associée à chaque clé.

```python
def majuscule(s):
    return s.upper()

clés = ['a', 'b', 'c']
valeurs = [1, 2, 3]
dico_majuscule = {majuscule(clé): valeur for clé, valeur in zip(clés, valeurs)}
print(dico_majuscule)
# Résultat : {'A': 1, 'B': 2, 'C': 3}
```

Dans cet exemple, la fonction `majuscule` est appliquée à chaque clé du dictionnaire.

#### 8. **Optimisation des performances avec des compréhensions**

Les compréhensions de dictionnaire sont non seulement plus concises que les boucles classiques, mais elles peuvent également offrir des **performances optimisées**. Par exemple, l’utilisation de `items()` pour accéder aux paires clé-valeur d’un dictionnaire dans une compréhension est plus rapide que d'utiliser une boucle classique.

#### 9. **Résumé des concepts clés**

- **Création rapide de dictionnaires** : La compréhension de dictionnaire permet de créer des dictionnaires en une ligne de code, en itérant sur des itérables et en appliquant des transformations ou des filtres.
- **Filtrage avec condition** : Il est possible d’ajouter une condition pour inclure uniquement certains éléments dans le dictionnaire.
- **Transformation des dictionnaires existants** : Les compréhensions permettent de modifier les clés ou les valeurs des dictionnaires de manière concise.
- **Complexité** : Vous pouvez imbriquer des compréhensions ou combiner plusieurs sources pour créer des structures plus complexes.

### Conclusion
La compréhension de dictionnaire est un outil puissant pour créer des dictionnaires de manière élégante et efficace, tout en optimisant la lisibilité et la performance de votre code Python.

### Chapitre 10 **Méthodes de classe et objets**

En Python, les **méthodes de classe** sont des fonctions qui appartiennent à une classe et qui peuvent être appelées sur des instances de cette classe. Elles sont utilisées pour définir les comportements des objets créés à partir de la classe. Le langage Python permet aussi d’utiliser des **méthodes spéciales** qui sont des fonctions intégrées permettant de personnaliser le comportement des objets, comme `__init__`, `__str__`, `__repr__`, etc. La gestion des **attributs d'instance** permet de manipuler et de gérer les données propres à chaque objet.

#### 1. **Création de classes et objets**

Avant de parler des méthodes de classe, voyons d'abord comment créer une classe en Python. Une **classe** est un modèle pour créer des objets (des instances). Elle contient des attributs et des méthodes qui définissent les comportements et les caractéristiques de ses instances.

```python
class Personne:
    def __init__(self, nom, age):
        self.nom = nom
        self.age = age

    def se_presenter(self):
        return f"Bonjour, je m'appelle {self.nom} et j'ai {self.age} ans."
```

Ici, la classe `Personne` a deux attributs d'instance (`nom` et `age`) et une méthode (`se_presenter`) qui permet à l'objet de se présenter.

#### 2. **Méthodes spéciales**

Les méthodes spéciales sont des méthodes pré-définies par Python pour modifier ou personnaliser le comportement de certains opérateurs ou fonctions intégrées.

##### **Méthode `__init__` (Constructeur)**

La méthode `__init__` est un **constructeur** spécial. Elle est appelée automatiquement lorsque vous créez une nouvelle instance de la classe. Elle sert à initialiser les attributs de l'objet.

```python
class Voiture:
    def __init__(self, marque, modèle):
        self.marque = marque
        self.modèle = modèle

    def afficher_info(self):
        return f"Voiture: {self.marque} {self.modèle}"

# Création d'une instance
voiture = Voiture('Toyota', 'Corolla')
```

Ici, la méthode `__init__` initialise les attributs `marque` et `modèle` de l'instance `voiture`.

##### **Méthode `__str__` (Représentation en chaîne de caractères)**

La méthode `__str__` est appelée lorsque l’on veut obtenir une **représentation sous forme de chaîne** de caractères de l'objet, généralement lors de l'utilisation de la fonction `print()`. Elle permet de personnaliser l'affichage d'un objet.

```python
class Personne:
    def __init__(self, nom, age):
        self.nom = nom
        self.age = age

    def __str__(self):
        return f"{self.nom} ({self.age} ans)"

# Création d'une instance
personne = Personne('Alice', 30)
print(personne)  # Affichera "Alice (30 ans)"
```

Ici, la méthode `__str__` permet de personnaliser l'affichage d'un objet `Personne` lors de l'appel à `print()`, en retournant une chaîne décrivant l'objet.

##### **Méthode `__repr__` (Représentation officielle)**

La méthode `__repr__` est utilisée pour retourner une **représentation officielle** de l'objet. Elle est appelée lorsque vous utilisez l’interpréteur interactif ou la fonction `repr()`. L'objectif est d’avoir une chaîne qui pourrait être utilisée pour recréer l’objet, ou à défaut, une représentation suffisamment détaillée.

```python
class Personne:
    def __init__(self, nom, age):
        self.nom = nom
        self.age = age

    def __repr__(self):
        return f"Personne('{self.nom}', {self.age})"

# Création d'une instance
personne = Personne('Bob', 25)
print(repr(personne))  # Affichera "Personne('Bob', 25)"
```

Ici, la méthode `__repr__` retourne une chaîne qui pourrait potentiellement être utilisée pour recréer l'objet à partir de cette chaîne.

#### 3. **Méthodes de classe et attributs d'instance**

Les **attributs d'instance** sont des variables qui appartiennent à une instance spécifique de la classe. Ils sont généralement initialisés dans la méthode `__init__` et sont accessibles via l'objet créé.

##### **Accès aux attributs d'instance**

L'accès aux attributs d'instance se fait via l'objet créé, en utilisant la syntaxe `objet.attribut`. Voici un exemple où l'attribut `nom` est modifié après la création de l'objet.

```python
class Etudiant:
    def __init__(self, nom, note):
        self.nom = nom
        self.note = note

    def modifier_note(self, nouvelle_note):
        self.note = nouvelle_note

etudiant = Etudiant('Alice', 15)
etudiant.modifier_note(18)
print(etudiant.note)  # Affichera 18
```

Ici, la méthode `modifier_note` permet de mettre à jour l'attribut `note` d'un étudiant.

##### **Méthodes de classe**

Les méthodes de classe sont des fonctions définies au sein de la classe et qui peuvent être appelées sur l’objet ou même sur la classe elle-même. Elles peuvent accéder aux **attributs de classe** (et non aux attributs d'instance). Pour définir une méthode de classe, vous utilisez le décorateur `@classmethod` et le premier argument doit être `cls`, représentant la classe elle-même.

```python
class CompteBancaire:
    taux_interet = 0.05  # Attribut de classe

    def __init__(self, titulaire, solde):
        self.titulaire = titulaire
        self.solde = solde

    @classmethod
    def modifier_taux_interet(cls, nouveau_taux):
        cls.taux_interet = nouveau_taux

    @classmethod
    def taux_actuel(cls):
        return cls.taux_interet

# Modification du taux d'intérêt via la méthode de classe
CompteBancaire.modifier_taux_interet(0.07)
print(CompteBancaire.taux_actuel())  # Affichera 0.07
```

Dans cet exemple, la méthode de classe `modifier_taux_interet` modifie l'attribut de classe `taux_interet` pour tous les objets de la classe `CompteBancaire`. La méthode `taux_actuel` permet d'obtenir la valeur actuelle de cet attribut.

#### 4. **Méthodes statiques**

Les **méthodes statiques** sont des méthodes qui n'ont pas besoin d'accéder à l'instance ou à la classe. Elles sont définies avec le décorateur `@staticmethod` et ne prennent ni `self` ni `cls` comme argument. Elles sont utilisées pour des opérations qui ne dépendent pas de l'état de l'objet ou de la classe.

```python
class Utilitaire:
    @staticmethod
    def additionner(a, b):
        return a + b

# Appel de la méthode statique sans créer d'instance
resultat = Utilitaire.additionner(3, 4)
print(resultat)  # Affichera 7
```

Dans cet exemple, la méthode statique `additionner` effectue une simple addition sans avoir besoin d'une instance de la classe.

#### 5. **Résumé des concepts clés**

- **Méthodes d'instance** : Des fonctions définies au sein de la classe qui opèrent sur les attributs spécifiques à l'instance.
- **`__init__`** : Le constructeur, utilisé pour initialiser les attributs d'une instance lors de sa création.
- **`__str__`** : Permet de définir la représentation sous forme de chaîne de caractères pour l'affichage.
- **`__repr__`** : Permet de définir la représentation plus détaillée et "officielle" de l'objet, souvent utilisée pour la reconstruction de l'objet.
- **Méthodes de classe** : Définies avec le décorateur `@classmethod`, elles agissent sur la classe elle-même et ses attributs de classe.
- **Méthodes statiques** : Des fonctions dans une classe qui ne nécessitent pas l'accès aux attributs ou méthodes de l'instance ou de la classe, définies avec le décorateur `@staticmethod`.

### Conclusion
Ces mécanismes de classes et d'objets permettent d’encapsuler le comportement et les caractéristiques des objets de manière modulaire et réutilisable. Ils facilitent la création d'applications plus structurées et compréhensibles.

### Chapitre 11 **Héritage et polymorphisme**

L'**héritage** et le **polymorphisme** sont des concepts fondamentaux de la **programmation orientée objet** (POO) qui permettent de créer des relations entre classes, de réutiliser du code et de modifier le comportement des objets de manière flexible. L'héritage permet à une classe dérivée (ou sous-classe) de recevoir les caractéristiques (attributs et méthodes) d'une classe de base (ou super-classe). Le polymorphisme, quant à lui, permet à différentes classes d'utiliser la même interface ou méthode, mais avec des comportements spécifiques à chaque classe.

#### 1. **Héritage**

L'héritage est un mécanisme qui permet à une classe de **hériter des propriétés et des comportements** d'une autre classe. La classe qui hérite est appelée **classe dérivée** ou **sous-classe**, et la classe dont elle hérite est appelée **classe de base** ou **super-classe**.

L'héritage permet d'éviter la duplication de code, car la classe dérivée peut utiliser les attributs et méthodes de la classe de base, tout en ayant la possibilité de les **modifier** ou **compléter**.

##### **Syntaxe de l'héritage**

En Python, une sous-classe est créée en plaçant le nom de la classe de base entre parenthèses après le nom de la sous-classe.

```python
class Animal:
    def __init__(self, nom):
        self.nom = nom

    def parler(self):
        return "L'animal fait un bruit."

class Chien(Animal):
    def __init__(self, nom, race):
        super().__init__(nom)  # Appel du constructeur de la super-classe
        self.race = race

    def parler(self):  # Redéfinition de la méthode parler
        return "Le chien aboie."

# Création d'instances
animal = Animal("Animal")
chien = Chien("Rex", "Labrador")

print(animal.parler())  # Affichera "L'animal fait un bruit."
print(chien.parler())   # Affichera "Le chien aboie."
```

Dans cet exemple, la classe `Chien` hérite de la classe `Animal` et redéfinit la méthode `parler`. La méthode `super().__init__(nom)` dans la sous-classe appelle le constructeur de la super-classe pour initialiser l'attribut `nom`.

#### 2. **Polymorphisme**

Le **polymorphisme** est un concept qui permet à des objets de types différents de répondre à une même méthode ou fonction, mais avec des comportements différents. En d'autres termes, le polymorphisme permet de définir des méthodes dans les classes dérivées qui portent le même nom que celles des classes de base, mais qui peuvent avoir des implémentations spécifiques à chaque classe dérivée.

Le polymorphisme permet d'utiliser des objets de types différents de manière uniforme.

##### **Exemple de polymorphisme**

Dans l'exemple ci-dessous, bien que la méthode `parler` existe dans toutes les classes (de base et dérivées), chaque classe définit son propre comportement pour cette méthode. Cela permet à un même appel de méthode (`parler()`) de produire des résultats différents en fonction de l'objet sur lequel il est appelé.

```python
class Chat(Animal):
    def parler(self):
        return "Le chat miaule."

# Création d'instances
chat = Chat("Minou")
chien = Chien("Rex", "Labrador")

# Polymorphisme
animaux = [chat, chien]

for animal in animaux:
    print(animal.parler())
```

Ici, le même appel `parler()` génère un comportement différent selon l'instance, qu'il s'agisse d'un `Chat` ou d'un `Chien`. Le polymorphisme permet de traiter ces objets de manière uniforme, tout en exécutant le code spécifique à chaque type d'objet.

##### **Avantages du polymorphisme**

1. **Flexibilité** : Le polymorphisme permet d'écrire des fonctions qui peuvent accepter des arguments de différents types, ce qui simplifie l'extension du programme.
2. **Extensibilité** : De nouvelles classes peuvent être ajoutées sans avoir besoin de modifier le code existant. Seules les méthodes spécifiques aux nouvelles classes doivent être définies.

#### 3. **Utilisation de `super()`**

La fonction `super()` permet d'appeler une méthode de la classe de base depuis la classe dérivée. Cela est particulièrement utile lorsque vous souhaitez appeler une méthode de la classe de base tout en ajoutant une fonctionnalité supplémentaire ou en modifiant le comportement de la méthode.

##### **Exemple d'utilisation de `super()`**

```python
class Voiture:
    def __init__(self, marque):
        self.marque = marque

    def demarrer(self):
        return f"La voiture {self.marque} démarre."

class VoitureElectrique(Voiture):
    def __init__(self, marque, batterie):
        super().__init__(marque)  # Appel du constructeur de la classe de base
        self.batterie = batterie

    def demarrer(self):
        return f"La voiture électrique {self.marque} démarre avec {self.batterie}% de batterie."

# Création d'objets
voiture = Voiture("Toyota")
voiture_electrique = VoitureElectrique("Tesla", 80)

print(voiture.demarrer())  # Affichera "La voiture Toyota démarre."
print(voiture_electrique.demarrer())  # Affichera "La voiture électrique Tesla démarre avec 80% de batterie."
```

Dans cet exemple, la classe `VoitureElectrique` hérite de la classe `Voiture` et utilise `super().__init__(marque)` pour appeler le constructeur de la classe `Voiture` et initialiser l'attribut `marque`.

#### 4. **Héritage multiple**

Python permet également l'héritage multiple, ce qui signifie qu'une classe peut hériter de plusieurs classes de base. Cela permet à une classe de combiner les comportements et attributs de plusieurs classes.

##### **Exemple d'héritage multiple**

```python
class Volant:
    def voler(self):
        return "L'objet vole."

class Nageur:
    def nager(self):
        return "L'objet nage."

class Oiseau(Volant, Nageur):
    pass

oiseau = Oiseau()
print(oiseau.voler())  # Affichera "L'objet vole."
print(oiseau.nager())  # Affichera "L'objet nage."
```

Dans cet exemple, la classe `Oiseau` hérite de deux classes de base, `Volant` et `Nageur`, ce qui lui permet d'avoir les comportements des deux classes.

#### 5. **Méthodes abstraites et héritage**

Dans les systèmes plus complexes, il peut être nécessaire de définir des **méthodes abstraites** dans des classes de base. Ces méthodes ne contiennent pas de logique, mais servent de modèle pour les sous-classes, qui doivent les implémenter. Pour cela, vous pouvez utiliser le module `abc` (Abstract Base Class).

##### **Exemple de méthodes abstraites**

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def parler(self):
        pass

class Chien(Animal):
    def parler(self):
        return "Le chien aboie."

class Chat(Animal):
    def parler(self):
        return "Le chat miaule."

# L'instanciation de Animal échouera
# animal = Animal()  # Erreur, Animal est abstraite

chien = Chien()
print(chien.parler())  # Affichera "Le chien aboie."

chat = Chat()
print(chat.parler())  # Affichera "Le chat miaule."
```

Dans cet exemple, la méthode `parler` est une méthode abstraite, ce qui signifie que toute sous-classe de `Animal` doit fournir une implémentation de cette méthode.

#### 6. **Résumé des concepts clés**

- **Héritage** : Mécanisme permettant à une classe dérivée de **hériter** des propriétés et méthodes d'une classe de base.
- **Polymorphisme** : Permet d'avoir différentes implémentations d'une même méthode dans des classes différentes, traitées de manière uniforme.
- **`super()`** : Fonction qui permet d'appeler une méthode de la classe de base dans une classe dérivée.
- **Héritage multiple** : Une classe peut hériter de plusieurs classes, ce qui permet de combiner des comportements provenant de plusieurs sources.
- **Méthodes abstraites** : Permet de définir des méthodes sans implémentation dans une classe de base, forçant les sous-classes à fournir leur propre implémentation.


### Conclusion
Ces concepts permettent de créer des systèmes complexes et modulaires en **réutilisant le code** et en favorisant la **flexibilité** du comportement des objets.

### Chapitre 12 **Méthodes statiques et de classe**

Les **méthodes statiques** et les **méthodes de classe** sont des concepts qui permettent de définir des méthodes liées à la classe elle-même, plutôt qu'à une instance d'objet. Ces méthodes peuvent être utilisées pour encapsuler des fonctionnalités spécifiques à la classe sans avoir besoin d'une instance de celle-ci. Les deux types de méthodes sont définis à l'aide de décorateurs spécifiques : `@staticmethod` pour les méthodes statiques et `@classmethod` pour les méthodes de classe.

#### 1. **Méthode statique (`@staticmethod`)**

Une **méthode statique** est une méthode qui est **liée à la classe** mais qui ne prend pas de référence à l'instance de la classe (pas de `self`) ni à la classe elle-même (pas de `cls`). Elle fonctionne de manière indépendante de l'état de l'objet et de la classe. Elle est utilisée principalement lorsque la méthode ne doit pas accéder aux attributs ou méthodes de la classe, mais qu’elle est néanmoins liée à cette classe par sa logique.

Les méthodes statiques sont utiles lorsque vous avez une fonction qui ne nécessite pas de connaître l'état interne de la classe, mais que vous voulez l'associer à une classe logique.

##### **Syntaxe de `@staticmethod`**

```python
class Exemple:
    @staticmethod
    def methode_statique():
        return "Méthode statique appelée."

# Appel de la méthode statique sans créer d'instance
print(Exemple.methode_statique())  # Affichera "Méthode statique appelée."
```

Dans cet exemple, la méthode `methode_statique` est appelée directement à partir de la classe, sans avoir besoin d'instancier un objet. Elle ne prend ni `self` ni `cls` comme argument.

##### **Quand utiliser une méthode statique ?**
- Lorsque la méthode ne dépend d'aucune donnée spécifique à une instance.
- Pour effectuer des calculs ou des transformations qui sont logiquement liés à la classe, mais qui ne nécessitent pas d'accès aux attributs ou méthodes de la classe ou de l'objet.

#### 2. **Méthode de classe (`@classmethod`)**

Une **méthode de classe** est une méthode qui prend comme premier argument la classe elle-même, et non l'instance. Cela lui permet d'accéder aux attributs de la classe et de les modifier. Les méthodes de classe sont utilisées pour des opérations qui concernent la classe dans son ensemble, et non un objet particulier.

Une méthode de classe est définie avec le décorateur `@classmethod`, et son premier argument est **généralement nommé `cls`** (pour "class").

##### **Syntaxe de `@classmethod`**

```python
class Exemple:
    compteur = 0  # Attribut de classe

    def __init__(self, nom):
        self.nom = nom
        Exemple.compteur += 1  # Augmente le compteur chaque fois qu'une instance est créée

    @classmethod
    def afficher_compteur(cls):
        return f"Il y a {cls.compteur} instances de la classe Exemple."

# Création d'instances
e1 = Exemple("Objet 1")
e2 = Exemple("Objet 2")

# Appel de la méthode de classe sans instancier un objet
print(Exemple.afficher_compteur())  # Affichera "Il y a 2 instances de la classe Exemple."
```

Ici, la méthode `afficher_compteur` est une méthode de classe, elle accède à l'attribut de classe `compteur` et retourne le nombre d'instances créées. Notez qu’elle est appelée sur la classe elle-même (`Exemple.afficher_compteur()`), et non sur une instance spécifique.

##### **Quand utiliser une méthode de classe ?**
- Lorsque vous avez besoin de modifier ou d'accéder aux **attributs de classe**, et non à ceux d'une instance.
- Pour créer des **méthodes d'usine** qui peuvent retourner des objets de la classe sans nécessiter un constructeur classique.
- Pour gérer des comportements ou des données qui concernent l'ensemble de la classe plutôt que des instances spécifiques.

#### 3. **Différences entre `@staticmethod` et `@classmethod`**

| Caractéristique         | `@staticmethod`                                    | `@classmethod`                                |
|-------------------------|----------------------------------------------------|-----------------------------------------------|
| **Premier argument**     | Aucun (`self` ou `cls` n'est pas utilisé)          | Reçoit un argument `cls` représentant la classe |
| **Accès aux attributs**  | Ne peut pas accéder à des attributs de classe ou d'instance | Peut accéder et modifier des attributs de classe |
| **Usage**                | Lorsque la méthode ne dépend pas de l'état de la classe ou de l'objet | Lorsque la méthode a besoin d'interagir avec la classe ou ses attributs |
| **Appel**                | Appelée sur la classe ou une instance sans modifier l'état de la classe ou de l'objet | Appelée sur la classe ou une instance et peut modifier l'état de la classe |

#### 4. **Méthodes de classe comme méthodes d'usine**

Une utilisation fréquente des méthodes de classe est de les utiliser comme **méthodes d'usine**, c'est-à-dire des méthodes qui permettent de créer des instances de la classe d'une manière différente du constructeur classique (`__init__`).

##### **Exemple d'une méthode d'usine**

```python
class Voiture:
    def __init__(self, marque, modele):
        self.marque = marque
        self.modele = modele

    @classmethod
    def from_string(cls, chaine):
        marque, modele = chaine.split('-')
        return cls(marque, modele)  # Crée une instance à partir d'une chaîne

# Utilisation de la méthode d'usine
voiture = Voiture.from_string("Toyota-Camry")
print(voiture.marque)  # Affichera "Toyota"
print(voiture.modele)  # Affichera "Camry"
```

Dans cet exemple, `from_string` est une méthode de classe utilisée pour créer une instance de `Voiture` à partir d'une chaîne de caractères. Cela permet de traiter des formats d'entrée ou des données de manière plus flexible.

#### 5. **Résumé des concepts clés**

- **Méthode statique (`@staticmethod`)** : 
  - Liée à la classe mais ne prend pas d'argument relatif à l'objet (`self`) ou à la classe (`cls`).
  - Ne peut pas accéder aux attributs ou méthodes d'instance ou de classe.
  - Utile pour des fonctions qui sont logiquement associées à une classe, mais indépendantes de l'état des objets ou de la classe elle-même.
  
- **Méthode de classe (`@classmethod`)** :
  - Liée à la classe et prend comme premier argument `cls`, représentant la classe.
  - Peut accéder et modifier les attributs de classe, et est souvent utilisée pour des méthodes d'usine ou pour manipuler des données globales à la classe.
  - Permet de créer des instances ou de gérer des comportements communs à toute la classe.

### Conclusion
Ces deux types de méthodes offrent des moyens puissants et flexibles de gérer les fonctionnalités au niveau de la classe, en fonction de l'état de l'objet ou de la classe.

### Chapitre 13 **Modules tiers (bibliothèques externes)**

Les **modules tiers** ou **bibliothèques externes** sont des ensembles de fonctions et d'outils créés par des développeurs extérieurs à la bibliothèque standard de Python. Ils permettent d'étendre les fonctionnalités de Python en offrant des solutions prêtes à l'emploi pour des tâches spécifiques. Ces modules peuvent être utilisés pour simplifier des processus complexes, améliorer la performance, ou intégrer des fonctionnalités avancées, telles que le calcul scientifique, la manipulation de données, ou la communication réseau.

Python bénéficie d'un écosystème riche en modules tiers, qui peuvent être installés via le gestionnaire de paquets `pip`. Certains des modules tiers les plus populaires incluent **NumPy** (pour les calculs scientifiques), **Pandas** (pour la manipulation de données), **Requests** (pour les requêtes HTTP), et **Matplotlib** (pour la visualisation de données).

#### 1. **Installation des modules tiers**

Avant d'utiliser un module tiers dans un projet Python, vous devez d'abord l'installer. Python utilise le gestionnaire de paquets `pip` pour installer ces modules. Vous pouvez installer un module via la ligne de commande comme suit :

```bash
pip install nom_du_module
```

Exemple pour installer **NumPy** :

```bash
pip install numpy
```

Une fois installé, vous pouvez l'importer dans votre code Python comme suit :

```python
import numpy as np
```

#### 2. **Exemples de bibliothèques tierces courantes**

##### **NumPy** : pour les calculs scientifiques

**NumPy** est une bibliothèque fondamentale pour les calculs scientifiques en Python. Elle fournit des structures de données puissantes comme les **tableaux multidimensionnels** et des fonctions pour effectuer des opérations mathématiques complexes sur ces tableaux.

**Fonctionnalités :**
- Création de tableaux N-dimensionnels.
- Opérations mathématiques rapides (addition, multiplication, transformations linéaires).
- Fonctionnalités pour le traitement de matrices et d'algèbre linéaire.

**Installation :**

```bash
pip install numpy
```

**Exemple d'utilisation :**

```python
import numpy as np

# Création d'un tableau NumPy
tableau = np.array([1, 2, 3, 4])

# Opération mathématique sur le tableau
tableau_au_carree = tableau ** 2
print(tableau_au_carree)  # Affiche [1 4 9 16]
```

##### **Pandas** : pour la manipulation de données

**Pandas** est une bibliothèque populaire pour la manipulation de données sous forme de tables (données structurées). Elle offre des outils pour lire, nettoyer, et analyser des données provenant de divers formats (CSV, Excel, bases de données, etc.).

**Fonctionnalités :**
- Structures de données puissantes : `DataFrame` (tableaux à 2 dimensions) et `Series` (tableaux à 1 dimension).
- Lecture et écriture de données à partir de fichiers externes (CSV, Excel, SQL, etc.).
- Manipulation de données : filtrage, agrégation, fusion.

**Installation :**

```bash
pip install pandas
```

**Exemple d'utilisation :**

```python
import pandas as pd

# Création d'un DataFrame à partir d'une liste de dictionnaires
data = {'Nom': ['Alice', 'Bob', 'Charlie'], 'Âge': [25, 30, 35]}
df = pd.DataFrame(data)

# Affichage du DataFrame
print(df)

# Accès aux données d'une colonne
print(df['Nom'])  # Affiche les noms des personnes
```

##### **Requests** : pour effectuer des requêtes HTTP

La bibliothèque **Requests** permet d'effectuer facilement des requêtes HTTP, ce qui est utile pour interagir avec des API web ou récupérer des données à partir de sites web.

**Fonctionnalités :**
- Envoi de requêtes HTTP (GET, POST, PUT, DELETE, etc.).
- Gestion des réponses HTTP (récupération du statut, des en-têtes, du contenu, etc.).
- Prise en charge de l'authentification, des sessions, des cookies.

**Installation :**

```bash
pip install requests
```

**Exemple d'utilisation :**

```python
import requests

# Envoi d'une requête GET
response = requests.get('https://api.github.com')

# Affichage du statut de la réponse
print(response.status_code)  # Affiche le code de statut HTTP

# Affichage du contenu de la réponse en JSON
data = response.json()
print(data)
```

##### **Matplotlib** : pour la visualisation de données

**Matplotlib** est une bibliothèque utilisée pour générer des graphiques 2D (comme des courbes, histogrammes, et diagrammes en secteurs), très utilisée dans l'analyse de données et les rapports visuels.

**Fonctionnalités :**
- Création de graphiques de différentes sortes : courbes, barres, diagrammes circulaires, etc.
- Personnalisation des graphiques (titres, légendes, couleurs, axes).
- Exportation des graphiques dans divers formats (PNG, PDF, SVG).

**Installation :**

```bash
pip install matplotlib
```

**Exemple d'utilisation :**

```python
import matplotlib.pyplot as plt

# Création de données
x = [1, 2, 3, 4, 5]
y = [1, 4, 9, 16, 25]

# Création d'un graphique
plt.plot(x, y)

# Ajout de titres et labels
plt.title('Graphique Exemple')
plt.xlabel('X')
plt.ylabel('Y')

# Affichage du graphique
plt.show()
```

#### 3. **Utilisation de modules tiers dans les projets**

L'utilisation de modules tiers dans vos projets peut considérablement simplifier le développement et accélérer la réalisation de vos applications. Ces bibliothèques offrent une large gamme de fonctionnalités pour des domaines aussi variés que :
- **Le traitement des données** (Pandas, NumPy).
- **La visualisation** (Matplotlib, Seaborn).
- **La communication réseau** (Requests, Socket).
- **Le machine learning et l'IA** (TensorFlow, Scikit-learn).
- **Les interfaces graphiques** (Tkinter, PyQt).

Les modules tiers sont généralement bien documentés et largement utilisés par la communauté Python, ce qui permet d'avoir un accès facile à des ressources et à du support.

#### 4. **Gestion des dépendances et des versions**

Lorsque vous travaillez avec des bibliothèques tierces dans un projet, il est important de gérer les dépendances. Cela garantit que les versions des bibliothèques sont cohérentes avec celles requises par votre code. Un fichier `requirements.txt` est souvent utilisé pour lister les bibliothèques et leurs versions spécifiques.

##### **Création d'un fichier `requirements.txt`**

```bash
pip freeze > requirements.txt
```

Ce fichier peut ensuite être utilisé pour installer toutes les dépendances d'un projet :

```bash
pip install -r requirements.txt
```

#### 5. **Résumé des concepts clés**

- Les **modules tiers** permettent d'étendre les fonctionnalités de Python en ajoutant des outils spécialisés pour des tâches spécifiques.
- Vous pouvez installer des modules tiers avec le gestionnaire de paquets `pip`.
- Les bibliothèques populaires incluent **NumPy** pour les calculs numériques, **Pandas** pour la manipulation de données, **Requests** pour les requêtes HTTP, et **Matplotlib** pour la visualisation de données.
- Pour une gestion optimale des projets, il est essentiel de gérer les dépendances à l'aide de fichiers comme `requirements.txt`.

### Conclusion
Les modules tiers sont essentiels pour travailler efficacement dans des domaines spécialisés et offrir des solutions rapides et fiables à des problèmes courants en Python.

### Chapitre 14 **Commutateurs (Match/Case)**

La structure **`match`** introduite dans **Python 3.10** permet de réaliser des évaluations conditionnelles de manière plus lisible et plus structurée que les classiques blocs `if/elif/else`. Elle fonctionne de manière similaire aux commutateurs (`switch/case`) dans d'autres langages de programmation, mais avec plus de flexibilité, notamment grâce à l'utilisation de **pattern matching** (correspondance de motifs).

Le **`match`** permet de comparer une valeur à plusieurs motifs possibles (`case`), et d'exécuter un bloc de code lorsque le motif correspond à la valeur. Cette structure peut être utilisée pour une évaluation plus complexe des données, notamment pour des types comme les objets, les dictionnaires, ou les tuples, avec la possibilité d'extraire des informations des valeurs correspondantes.

#### 1. **Syntaxe de base**

La syntaxe de la structure `match` est la suivante :

```python
match variable:
    case motif_1:
        # bloc de code si motif_1 correspond
    case motif_2:
        # bloc de code si motif_2 correspond
    case _:
        # bloc de code si aucun motif ne correspond (cas par défaut)
```

- **`variable`** : C'est la valeur que vous souhaitez évaluer.
- **`motif_1`, `motif_2`** : Ce sont les motifs avec lesquels vous comparez la valeur.
- **`_`** : Cela correspond à un motif générique, un "joker", qui capte tous les cas qui n'ont pas été pris en compte.

#### 2. **Fonctionnement et utilisation**

La structure `match/case` fonctionne en effectuant une comparaison entre la valeur et chaque motif, de haut en bas. Dès qu'un motif est trouvé qui correspond à la valeur, le bloc de code associé à ce motif est exécuté, et l'exécution de la structure `match` s'arrête.

##### Exemple simple :

```python
def jour_de_la_semaine(jour):
    match jour:
        case "lundi":
            print("Début de la semaine")
        case "mercredi":
            print("Milieu de la semaine")
        case "vendredi":
            print("Fin de la semaine")
        case _:
            print("Jour inconnu")

# Test
jour_de_la_semaine("mercredi")  # Affiche: Milieu de la semaine
```

Dans cet exemple, on teste la variable `jour` contre plusieurs motifs (les jours spécifiques de la semaine). Si `jour` correspond à l'un des cas définis, le code associé est exécuté. Le motif `_` est le cas par défaut et s'exécute si aucun autre cas ne correspond.

#### 3. **Pattern Matching Avancé**

Le `match` dans Python 3.10 ne se limite pas à une simple comparaison de valeurs, il peut être beaucoup plus puissant grâce à des fonctionnalités avancées comme la correspondance avec des objets, des listes, des dictionnaires ou des tuples, et même l'extraction de valeurs à partir des structures de données.

##### a. **Correspondance avec des tuples ou des séquences**

Le `match` peut être utilisé pour décomposer des tuples ou des listes en leurs éléments, permettant ainsi de comparer et d'extraire des valeurs spécifiques.

```python
def test_tuple(val):
    match val:
        case (a, b):  # Correspond à un tuple à deux éléments
            print(f"Tuile avec deux éléments: {a}, {b}")
        case (a, b, c):  # Correspond à un tuple à trois éléments
            print(f"Tuile avec trois éléments: {a}, {b}, {c}")
        case _:
            print("Autre cas")

# Test
test_tuple((1, 2))  # Affiche: Tuile avec deux éléments: 1, 2
test_tuple((1, 2, 3))  # Affiche: Tuile avec trois éléments: 1, 2, 3
```

##### b. **Correspondance avec des dictionnaires**

La correspondance avec des dictionnaires permet de vérifier si certains éléments spécifiques existent dans un dictionnaire et d'extraire leur valeur.

```python
def test_dict(val):
    match val:
        case {"nom": nom, "age": age}:  # Correspond à un dictionnaire avec les clés "nom" et "age"
            print(f"Nom: {nom}, Âge: {age}")
        case _:
            print("Autre cas")

# Test
test_dict({"nom": "Alice", "age": 30})  # Affiche: Nom: Alice, Âge: 30
```

Dans cet exemple, on utilise la structure `match` pour correspondre avec des dictionnaires et extraire les valeurs associées aux clés spécifiques (`"nom"` et `"age"`).

##### c. **Correspondance avec des objets complexes**

Vous pouvez également utiliser `match/case` pour travailler avec des objets et extraire des valeurs de leurs attributs. Cela est particulièrement utile pour les classes et les objets complexes.

```python
class Personne:
    def __init__(self, nom, age):
        self.nom = nom
        self.age = age

def test_objet(val):
    match val:
        case Personne(nom, age):  # Correspond à un objet de type Personne
            print(f"Personne: {nom}, Âge: {age}")
        case _:
            print("Autre cas")

# Test
personne = Personne("Bob", 25)
test_objet(personne)  # Affiche: Personne: Bob, Âge: 25
```

Ici, nous correspondons à un objet `Personne` et extrayons ses attributs `nom` et `age`.

#### 4. **Utilisation d'expressions régulières dans `match`**

Le `match` peut également être utilisé avec des expressions régulières, ce qui permet d'effectuer des correspondances basées sur des motifs plus complexes, comme des chaînes de caractères.

```python
import re

def test_regex(val):
    match val:
        case re.match(r"\d+", n):  # Correspond à une chaîne contenant uniquement des chiffres
            print(f"Nombre trouvé: {n}")
        case _:
            print("Non un nombre")

# Test
test_regex("12345")  # Affiche: Nombre trouvé: 12345
```

Dans cet exemple, le `match` est utilisé avec une expression régulière pour vérifier si une chaîne de caractères est composée uniquement de chiffres.

#### 5. **Résumé des concepts clés**

- **`match`** est une structure de contrôle introduite dans Python 3.10, qui permet de réaliser des évaluations conditionnelles avec une syntaxe plus claire et plus expressive que les blocs `if/elif/else`.
- Le `match` fonctionne de manière similaire à un `switch/case`, mais avec un pouvoir beaucoup plus étendu, en permettant de faire correspondre des motifs complexes (tuples, dictionnaires, objets, etc.).
- Vous pouvez extraire des valeurs à partir des motifs et travailler avec des types de données structurés comme des objets ou des listes.
- Le **`_`** est un motif générique qui capte les cas par défaut, et permet d'implémenter des logiques plus flexibles.
- Le `match` en Python permet également d'utiliser des expressions régulières et des objets complexes pour des correspondances plus détaillées.

### Conclusion
Cette fonctionnalité améliore la lisibilité du code et permet de gérer des cas complexes de manière plus élégante et concise.

### Chapitre 15 **Type hints et annotations**

Les **annotations de type** sont une fonctionnalité de Python introduite dans la version 3.5, qui permet aux développeurs de spécifier explicitement les types de variables, de paramètres de fonction et de valeurs de retour. Bien que Python soit un langage dynamiquement typé, les annotations de type offrent plusieurs avantages, notamment une meilleure lisibilité du code, un support accru des outils d'analyse statique (comme **mypy**) et une meilleure intégration dans les IDE pour la suggestion de types et la vérification des erreurs.

#### 1. **Syntaxe des annotations de type**

Les annotations de type sont intégrées à la syntaxe Python à travers des **syntaxes simples** ou des **types plus complexes**.

##### a. **Annotations de type pour les variables**

Les annotations de type peuvent être utilisées pour spécifier le type attendu d'une variable. Cette annotation est placée après le nom de la variable, séparée par un deux-points (`:`).

```python
x: int = 10  # x est un entier
nom: str = "Alice"  # nom est une chaîne de caractères
```

Ici, `x` est annoté comme étant un **entier** et `nom` comme étant une **chaîne de caractères**.

##### b. **Annotations de type pour les arguments de fonction**

Les annotations de type peuvent également être utilisées pour indiquer les types des paramètres d'une fonction.

```python
def addition(a: int, b: int) -> int:
    return a + b
```

Dans cet exemple :
- `a` et `b` sont des **entiers** (int).
- La fonction renvoie également un **entier** (indiqué après le `->`).

##### c. **Annotations de type pour la valeur de retour**

La syntaxe `-> type` est utilisée pour spécifier le type de la valeur de retour d'une fonction.

```python
def salutation(nom: str) -> str:
    return "Bonjour " + nom
```

Ici, la fonction `salutation` prend un argument de type `str` (chaîne de caractères) et renvoie également une valeur de type `str`.

#### 2. **Types complexes**

Les annotations de type ne se limitent pas aux types de base comme `int`, `str`, ou `float`. Il est possible de spécifier des types plus complexes, comme des collections (listes, dictionnaires), des types optionnels, ou des types personnalisés.

##### a. **Listes et dictionnaires**

Pour indiquer qu'un argument ou une variable est une liste ou un dictionnaire contenant des éléments de types spécifiques, on peut utiliser les types génériques du module `typing`.

```python
from typing import List, Dict

def somme_liste(nombres: List[int]) -> int:
    return sum(nombres)

def dico_utilisateur(utilisateurs: Dict[str, int]) -> str:
    return f"Il y a {len(utilisateurs)} utilisateurs."
```

- **`List[int]`** indique une **liste d'entiers**.
- **`Dict[str, int]`** indique un **dictionnaire** avec des **clés de type `str`** et des **valeurs de type `int`**.

##### b. **Types optionnels avec `Optional`**

Le type `Optional` est utilisé pour indiquer qu'un paramètre ou une variable peut avoir une valeur `None`, en plus de son type habituel.

```python
from typing import Optional

def trouver_element(liste: List[int], element: int) -> Optional[int]:
    try:
        return liste.index(element)
    except ValueError:
        return None
```

Ici, `Optional[int]` signifie que la fonction peut renvoyer soit un **entier**, soit `None`.

##### c. **Union de types avec `Union`**

L'annotation `Union` permet de spécifier que le type d'une variable ou d'un argument peut être l'un de plusieurs types possibles.

```python
from typing import Union

def traiter_input(val: Union[int, str]) -> str:
    if isinstance(val, int):
        return f"Entier: {val}"
    elif isinstance(val, str):
        return f"Chaîne: {val}"
    else:
        return "Type inconnu"
```

Dans cet exemple, la fonction `traiter_input` accepte soit un **entier**, soit une **chaîne de caractères**.

##### d. **Tuple avec `Tuple`**

La syntaxe `Tuple` permet de spécifier les types des éléments d'un tuple, y compris le nombre d'éléments s'il est fixe.

```python
from typing import Tuple

def coordonnees() -> Tuple[int, int]:
    return (10, 20)
```

Ici, la fonction `coordonnees` renvoie un **tuple** composé de deux **entiers**.

#### 3. **Utilisation de `Any`**

Si vous n'êtes pas sûr du type d'une variable, vous pouvez utiliser `Any`, qui indique que cette variable peut être de n'importe quel type.

```python
from typing import Any

def echo(val: Any) -> Any:
    return val
```

Le type `Any` est utile lorsque vous travaillez avec des valeurs de types indéfinis ou dynamiques, mais son utilisation réduit l'efficacité des vérifications de type statique.

#### 4. **Fonctionnalités avancées avec `TypeVar` et `Callable`**

##### a. **`TypeVar` pour les types génériques**

La classe `TypeVar` permet de créer des **types génériques**. Elle permet de spécifier que plusieurs variables ont le même type, mais ce type n'est pas défini à l'avance.

```python
from typing import TypeVar

T = TypeVar('T')

def premier_element(val: List[T]) -> T:
    return val[0]
```

Ici, `T` est un **type variable** qui permet de spécifier qu'un argument de type `List[T]` sera une liste d'éléments du même type, et que la fonction `premier_element` renverra le même type.

##### b. **`Callable` pour les fonctions comme types**

Le type `Callable` permet de spécifier des fonctions comme types. Il permet de définir les types d'arguments et de retour d'une fonction.

```python
from typing import Callable

def execute(fonction: Callable[[int, int], int]) -> int:
    return fonction(2, 3)

# Exemple d'utilisation
def addition(a: int, b: int) -> int:
    return a + b

resultat = execute(addition)  # Retourne 5
```

Ici, `Callable[[int, int], int]` indique que la fonction passée en paramètre doit accepter deux entiers en arguments et renvoyer un entier.

#### 5. **Outils de vérification des types**

Il existe des outils de vérification statique des types comme **mypy** qui permettent de s'assurer que le code respecte bien les annotations de type. Ces outils peuvent être utilisés pour vérifier que les types des variables et des paramètres de fonction sont correctement respectés, ce qui améliore la robustesse du code.

```bash
# Installer mypy
pip install mypy

# Vérification d'un fichier Python avec mypy
mypy mon_script.py
```

#### 6. **Résumé des concepts clés**

- **Les annotations de type** permettent de spécifier le type des variables, des arguments et des valeurs de retour des fonctions.
- Elles **améliorent la lisibilité** du code, permettent une **vérification statique** avec des outils comme `mypy`, et aident à éviter les erreurs de type.
- Python offre des types simples comme **`int`**, **`str`**, et **`float`**, mais aussi des types complexes comme **`List`**, **`Dict`**, **`Tuple`**, **`Optional`**, **`Union`**, et **`Any`**.
- Vous pouvez utiliser des fonctionnalités avancées comme **`Callable`** et **`TypeVar`** pour les fonctions génériques et la gestion dynamique des types.
- Bien que Python reste un langage **dynamiquement typé**, les annotations de type ajoutent un niveau de sécurité et de précision qui est particulièrement utile dans les projets complexes.

### Conclusion
Les annotations de type ne changent pas le comportement du code à l'exécution, mais offrent un meilleur outillage pour le développement, l'optimisation du code et la détection des erreurs.

### Chapitre 16 **Gestion de la mémoire et des ressources**

La gestion de la mémoire et des ressources est un aspect fondamental du développement en Python, bien que le langage repose principalement sur un **ramasse-miettes** (garbage collector) pour automatiser la gestion de la mémoire. Cependant, Python offre aussi des mécanismes permettant aux développeurs de mieux contrôler l'utilisation des ressources, en particulier pour les ressources limitées ou coûteuses, telles que les fichiers ou les connexions réseau.

#### 1. **Le ramasse-miettes (Garbage Collection)**

Python utilise un **ramasse-miettes (garbage collector)** pour gérer la mémoire automatiquement en supprimant les objets qui ne sont plus utilisés, ce qui permet de libérer de la mémoire sans intervention manuelle. Cependant, ce mécanisme n'est pas parfait et peut parfois entraîner des fuites de mémoire si les objets restent référencés dans des structures complexes.

##### a. **Référence comptée**

Python utilise principalement un système de **référence comptée** pour suivre les objets en mémoire. Chaque objet dans Python possède un compteur de références qui est incrémenté chaque fois qu'une nouvelle référence à cet objet est créée et décrémenté chaque fois qu'une référence est supprimée. Lorsque le compteur atteint zéro, cela signifie qu'aucune référence n'existe plus pour cet objet, et il peut être libéré.

Exemple :
```python
a = [1, 2, 3]  # Création de l'objet
b = a  # b fait référence à a
del a  # Suppression de la référence a, mais l'objet n'est pas supprimé tant que b existe
del b  # À ce moment, l'objet est supprimé
```

##### b. **Garbage Collector et cycles**

Le ramasse-miettes de Python gère également les **cycles de référence**, où deux ou plusieurs objets se réfèrent mutuellement, empêchant leur suppression automatique. Dans ce cas, Python utilise un **collecteur de cycles** pour identifier et supprimer ces cycles de référence.

```python
import gc

gc.collect()  # Force le ramasse-miettes à effectuer une collecte manuelle
```

Bien que Python gère automatiquement la mémoire, l’utilisation d'outils comme `gc` permet de contrôler ce processus.

#### 2. **Gestion des ressources avec `with` (Context Managers)**

Le mot-clé `with` est utilisé pour gérer des ressources qui nécessitent un nettoyage ou une libération explicite après usage. Il est notamment employé pour les **fichiers**, **connexions réseau**, ou **verrous** dans les environnements multi-threads.

Le mécanisme sous-jacent au `with` repose sur les **gestes contextuels** (`context managers`), qui s'assurent que les ressources sont correctement acquises et libérées, même en cas d'exception.

##### a. **Fichiers**

Lors de l'ouverture d'un fichier, vous pouvez utiliser le bloc `with` pour garantir que le fichier est bien fermé après utilisation, sans avoir besoin d'appeler explicitement `file.close()`.

```python
with open('mon_fichier.txt', 'r') as f:
    contenu = f.read()
# Le fichier est automatiquement fermé à la fin du bloc, même en cas d'exception.
```

##### b. **Verrous et Concurrence**

Lors de l'utilisation de **verrous** pour gérer des ressources partagées dans un environnement concurrent, `with` permet de garantir que le verrou est acquis et libéré correctement.

```python
import threading

verrou = threading.Lock()

with verrou:
    # Code critique où l'accès aux ressources partagées est contrôlé
    pass  # Exemple d'accès à une ressource partagée
# Le verrou est automatiquement libéré ici.
```

##### c. **Context Manager personnalisé**

Vous pouvez créer vos propres **context managers** en définissant des classes avec les méthodes spéciales `__enter__` et `__exit__`. Cela permet de gérer des ressources spécifiques de manière propre et contrôlée.

```python
class ConnexionBaseDeDonnees:
    def __enter__(self):
        # Initialisation de la connexion
        self.conn = "Connexion à la base de données"
        return self.conn

    def __exit__(self, exc_type, exc_value, traceback):
        # Libération de la connexion
        print("Fermeture de la connexion à la base de données.")
        self.conn = None

with ConnexionBaseDeDonnees() as db_conn:
    print("Utilisation de la connexion :", db_conn)
# La connexion est automatiquement fermée à la fin du bloc `with`
```

#### 3. **Références faibles (Weak References)**

Dans certaines situations, il peut être nécessaire de créer des références à des objets sans les empêcher d'être collectés par le garbage collector. Cela peut être utile pour la gestion de caches, de pools d'objets, ou d'autres structures de données où vous souhaitez éviter de créer des références fortes qui empêcheraient la collecte de l'objet.

Python fournit le module `weakref` pour créer des **références faibles**.

```python
import weakref

class MonObjet:
    def __init__(self, nom):
        self.nom = nom

obj = MonObjet("Exemple")
ref = weakref.ref(obj)  # Crée une référence faible à l'objet

# L'objet peut être collecté par le garbage collector même si ref existe
del obj
print(ref())  # Affiche None car l'objet a été collecté
```

Les références faibles permettent à l'objet de vivre sa vie normalement, mais sans empêcher sa collecte lorsque toutes les autres références sont supprimées.

#### 4. **Gestion des ressources avec `try/except/finally`**

Bien que l'utilisation de `with` soit la méthode privilégiée pour la gestion des ressources, vous pouvez aussi gérer la libération des ressources manuellement à l'aide des blocs `try/except/finally`. Le bloc `finally` est exécuté quelle que soit la survenue d'une exception et permet de s'assurer que certaines opérations de nettoyage sont réalisées.

```python
file = None
try:
    file = open("mon_fichier.txt", "r")
    # Traitement du fichier
except IOError:
    print("Erreur d'entrée/sortie.")
finally:
    if file:
        file.close()  # Fermeture du fichier, qu'une exception se produise ou non
```

#### 5. **Optimisation de la gestion de la mémoire**

Bien que Python gère automatiquement la mémoire, il existe certaines stratégies pour **optimiser l'utilisation de la mémoire** dans des programmes à grande échelle :

- **Eviter la création excessive d'objets** dans les boucles, en réutilisant des objets lorsque possible.
- Utiliser des **structures de données immutables** (comme les tuples ou les chaînes de caractères) lorsqu'elles conviennent, car elles peuvent être partagées efficacement entre différentes parties du programme.
- **Profilage de la mémoire** avec des outils comme `tracemalloc` pour identifier les fuites de mémoire ou les objets inutilisés qui sont toujours référencés.
- Utiliser des structures comme les **`deque`** ou les **`array`** du module `collections` ou `array` respectivement pour des performances mémoire optimisées sur de grandes quantités de données.

#### 6. **Résumé des concepts clés**

- Le **ramasse-miettes (garbage collector)** de Python gère la mémoire automatiquement en supprimant les objets non utilisés, mais peut parfois laisser des objets dans des cycles de référence non collectés.
- Le **mot-clé `with`** et les **context managers** permettent une gestion élégante et automatique des ressources, notamment pour les fichiers, les verrous ou toute ressource nécessitant un nettoyage explicite.
- Les **références faibles** (via le module `weakref`) permettent de créer des références qui n'empêchent pas les objets d'être collectés par le garbage collector.
- Le bloc `finally` dans les instructions `try/except/finally` peut également être utilisé pour garantir la libération des ressources, même en cas d'exception.
- Des outils comme `gc` et `tracemalloc` permettent de surveiller et de gérer l'utilisation de la mémoire dans les programmes Python.

### Chapitre 17 **Multithreading et Multiprocessing**

Python offre plusieurs mécanismes permettant d'exécuter des tâches en parallèle, notamment à travers le **multithreading** et le **multiprocessing**. Ces techniques permettent d'optimiser l'utilisation des ressources du système, d'améliorer la réactivité des applications et de paralléliser des tâches lourdes. Cependant, elles possèdent des caractéristiques et des usages différents, que l'on explore ci-dessous.

#### 1. **Multithreading**

Le **multithreading** permet d'exécuter plusieurs tâches en parallèle au sein d'un même processus en utilisant des **threads**. Chaque thread représente un flux d'exécution distinct. Le multithreading est particulièrement utile pour des tâches **I/O-bound** (comme les lectures et écritures de fichiers, la gestion des requêtes réseau, etc.), où l'attente des opérations d'entrée/sortie peut être masquée pendant que d'autres tâches sont effectuées.

##### a. **GIL (Global Interpreter Lock)**

Python utilise le **Global Interpreter Lock** (GIL), un mécanisme qui garantit qu'à tout moment, un seul thread exécute du bytecode Python. Cela signifie que, bien que le multithreading puisse être utilisé pour améliorer la réactivité dans le cas de tâches I/O-bound, il ne permet pas d'exécuter réellement plusieurs threads en parallèle pour les tâches **CPU-bound** (qui nécessitent un calcul intensif), car le GIL limite l'exécution à un seul thread Python à la fois.

##### b. **Création et gestion des threads**

Pour utiliser les threads en Python, le module `threading` est souvent utilisé. Il fournit une interface simple pour créer et gérer des threads.

```python
import threading

def fonction():
    print("Thread en cours d'exécution")

# Créer un thread
thread = threading.Thread(target=fonction)

# Démarrer le thread
thread.start()

# Attendre la fin de l'exécution du thread
thread.join()
```

##### c. **Limites du multithreading**

Bien que le multithreading puisse être efficace pour des tâches I/O-bound, il présente des limites pour les tâches CPU-bound, car le GIL empêche une véritable exécution parallèle sur plusieurs cœurs de processeur. Si vous devez exécuter des calculs lourds, le **multiprocessing** est souvent préféré.

#### 2. **Multiprocessing**

Le **multiprocessing** permet d'exécuter plusieurs processus distincts en parallèle. Contrairement au multithreading, chaque processus possède sa propre **mémoire et espace d'adressage**, ce qui permet de contourner les limitations imposées par le GIL. Le multiprocessing est particulièrement utile pour les tâches **CPU-bound**, où des calculs intensifs nécessitent une exécution parallèle réelle sur plusieurs cœurs du processeur.

##### a. **Création de processus avec `multiprocessing`**

Le module `multiprocessing` permet de créer et de gérer des processus en parallèle. Chaque processus fonctionne indépendamment, ce qui le rend idéal pour exploiter pleinement les capacités de traitement d'un ordinateur multicœur.

```python
import multiprocessing

def fonction():
    print("Processus en cours d'exécution")

# Créer un processus
processus = multiprocessing.Process(target=fonction)

# Démarrer le processus
processus.start()

# Attendre la fin du processus
processus.join()
```

##### b. **Partage des données entre processus**

Les processus étant indépendants, ils ne partagent pas directement de mémoire. Pour échanger des données entre processus, il est nécessaire d'utiliser des **queues**, des **pipes** ou des **mémoires partagées** fournies par le module `multiprocessing`.

Exemple avec `Queue` pour partager des données entre processus :

```python
import multiprocessing

def envoyer_donnees(queue):
    queue.put("Donnée partagée")

# Créer une queue pour partager les données
queue = multiprocessing.Queue()

# Créer un processus qui envoie des données
processus = multiprocessing.Process(target=envoyer_donnees, args=(queue,))
processus.start()
processus.join()

# Récupérer les données
data = queue.get()
print(data)
```

##### c. **Pools de processus**

Le module `multiprocessing` fournit également la classe `Pool` qui permet de gérer un ensemble de processus en parallèle, simplifiant l'exécution de tâches parallèles sur un grand nombre de données.

```python
import multiprocessing

def fonction(x):
    return x * x

# Créer un pool de 4 processus
with multiprocessing.Pool(4) as pool:
    resultats = pool.map(fonction, [1, 2, 3, 4, 5])
    print(resultats)  # Affiche [1, 4, 9, 16, 25]
```

#### 3. **Comparaison entre Multithreading et Multiprocessing**

| **Caractéristique**     | **Multithreading**                                      | **Multiprocessing**                                      |
|-------------------------|---------------------------------------------------------|---------------------------------------------------------|
| **Utilisation des cœurs**| Utilise un seul cœur en raison du GIL.                  | Utilise plusieurs cœurs en parallèle.                    |
| **Tâches adaptées**      | Idéal pour les tâches I/O-bound (ex: lecture/écriture). | Idéal pour les tâches CPU-bound (ex: calculs lourds).    |
| **Mémoire partagée**     | Partage de la même mémoire, avec des problèmes potentiels de concurrence. | Chaque processus a son propre espace mémoire.            |
| **Facilité de gestion**  | Moins de surcharge dans le démarrage des threads.      | Peut entraîner plus de surcharge en raison de la création de processus séparés. |

#### 4. **Applications pratiques du multithreading et multiprocessing**

- **Multithreading** est utile pour les tâches telles que :
  - La gestion des requêtes réseau.
  - Les interfaces utilisateur qui doivent rester réactives pendant l'exécution d'opérations longues.
  - Le téléchargement parallèle de fichiers.
  - La lecture/écriture simultanée de fichiers sans bloquer le programme principal.

- **Multiprocessing** est utile pour les tâches suivantes :
  - L'exécution de calculs intensifs sur plusieurs cœurs.
  - Le traitement parallèle de grandes quantités de données (par exemple, analyse d'images, calculs scientifiques).
  - La mise en œuvre de systèmes distribués ou d'applications nécessitant l'exécution parallèle de nombreux processus indépendants.

#### 5. **Synchronisation entre threads et processus**

En multithreading et multiprocessing, il est souvent nécessaire de synchroniser les différentes unités d'exécution pour éviter les **conditions de course** (race conditions) et garantir une exécution correcte des tâches. Python fournit plusieurs mécanismes pour cela, notamment :

- **Verrous** (Locks) pour les threads : Pour s'assurer qu'une seule unité d'exécution accède à une ressource partagée à un moment donné.
- **Sémaphores**, **événements** et **barrières** pour gérer la synchronisation dans des scénarios plus complexes.
  
Exemple de synchronisation avec un verrou (`Lock`):

```python
import threading

lock = threading.Lock()

def fonction():
    with lock:
        # Code critique où l'accès aux ressources partagées est contrôlé
        print("Accès à une ressource partagée")

thread1 = threading.Thread(target=fonction)
thread2 = threading.Thread(target=fonction)
thread1.start()
thread2.start()
thread1.join()
thread2.join()
```

#### 6. **Résumé des concepts clés**

- **Multithreading** permet d'exécuter plusieurs tâches en parallèle dans un même processus, mais il est limité par le GIL dans les tâches CPU-bound.
- **Multiprocessing** permet de créer plusieurs processus distincts et parallèles, ce qui est mieux adapté pour les tâches CPU-bound.
- Le **module `threading`** est utilisé pour le multithreading, et le **module `multiprocessing`** est utilisé pour gérer plusieurs processus parallèles.
- La synchronisation est essentielle dans les deux cas pour garantir une exécution correcte des programmes.

### Chapitre 18 **Tests unitaires**

Les **tests unitaires** sont un aspect fondamental du développement logiciel moderne, permettant de vérifier qu'une unité de code (souvent une fonction ou une méthode) fonctionne comme prévu. Cela garantit que le programme fonctionne correctement et facilite la détection rapide des régressions lors des modifications ou évolutions du code. Python propose plusieurs outils pour l'écriture et l'exécution de tests unitaires, parmi lesquels les plus populaires sont `unittest` et `pytest`.

#### 1. **Introduction aux tests unitaires**

Un test unitaire est conçu pour tester une **petite unité de code** de manière isolée, afin de s'assurer qu'elle se comporte comme attendu. Typiquement, cela concerne :
- La vérification des résultats des fonctions/méthodes pour différentes entrées.
- La gestion des exceptions ou erreurs attendues.
- La validation des comportements sous des conditions spécifiques (entrées valides et invalides).

Les tests unitaires aident à :
- **Valider** le comportement du code.
- **Détecter rapidement** les erreurs.
- **Faciliter la maintenance** du code en cas de changements.

#### 2. **Framework `unittest`**

`unittest` est le framework standard de Python pour les tests unitaires. Il est inspiré de JUnit (pour Java) et fournit une structure pour organiser et exécuter les tests. Il permet également de gérer des assertions, des exceptions, et de configurer un environnement de test.

##### a. **Structure d'un test unitaire avec `unittest`**

Les tests sont organisés sous forme de classes qui héritent de `unittest.TestCase`. Chaque méthode de test doit commencer par `test_` et est exécutée de manière isolée.

```python
import unittest

# Exemple d'une fonction à tester
def addition(a, b):
    return a + b

class TestAddition(unittest.TestCase):
    def test_addition_positifs(self):
        self.assertEqual(addition(2, 3), 5)

    def test_addition_negatifs(self):
        self.assertEqual(addition(-1, -1), -2)

    def test_addition_melange(self):
        self.assertEqual(addition(-1, 1), 0)

if __name__ == '__main__':
    unittest.main()
```

##### b. **Principales méthodes d'assertion**

Les tests unitaires s'appuient sur des méthodes d'assertion pour valider les résultats des fonctions. Quelques exemples :

- `assertEqual(a, b)` : Vérifie que `a == b`.
- `assertNotEqual(a, b)` : Vérifie que `a != b`.
- `assertTrue(x)` : Vérifie que `x` est vrai.
- `assertFalse(x)` : Vérifie que `x` est faux.
- `assertIsNone(x)` : Vérifie que `x` est `None`.
- `assertRaises(exc, func, *args, **kwargs)` : Vérifie qu'une exception spécifique est levée lors de l'appel d'une fonction.

##### c. **Exécution des tests**

Les tests peuvent être exécutés depuis la ligne de commande avec la commande `python -m unittest` ou directement en exécutant le fichier contenant les tests.

```bash
python -m unittest test_module.py
```

Les résultats des tests seront affichés, avec des messages d'erreur en cas de défaillance.

#### 3. **Framework `pytest`**

`pytest` est un autre framework populaire, plus flexible et facile à utiliser que `unittest`. Il supporte des assertions plus intuitives, la gestion automatique des tests, et des rapports de test détaillés.

##### a. **Structure d'un test unitaire avec `pytest`**

Contrairement à `unittest`, il n'est pas nécessaire de créer une classe pour chaque test. Les tests sont définis sous forme de fonctions simples.

```python
# Exemple d'une fonction à tester
def addition(a, b):
    return a + b

# Test avec pytest
def test_addition_positifs():
    assert addition(2, 3) == 5

def test_addition_negatifs():
    assert addition(-1, -1) == -2

def test_addition_melange():
    assert addition(-1, 1) == 0
```

##### b. **Principales fonctionnalités de `pytest`**

- **Assertions améliorées** : `pytest` permet d'utiliser directement des expressions comme `assert a == b` sans avoir besoin de méthodes d'assertion spéciales.
- **Exécution des tests** : Les tests peuvent être exécutés avec la commande `pytest` dans le terminal. Il est également possible de filtrer les tests à exécuter par nom ou par marque.
  
```bash
pytest test_module.py
```

- **Fixtures** : `pytest` permet de gérer les configurations ou les pré-conditions avant l'exécution des tests avec les **fixtures**. Les fixtures sont des fonctions qui préparent l'état avant un test.

```python
import pytest

@pytest.fixture
def setup_data():
    return [1, 2, 3]

def test_addition_positifs(setup_data):
    assert sum(setup_data) == 6
```

##### c. **Rapports et débogage**

`pytest` fournit des rapports détaillés sur l'exécution des tests, avec des informations sur les échecs et les erreurs. Il permet également de visualiser les traces d'exception et de debugger plus facilement les tests échoués.

#### 4. **Conseils pour écrire de bons tests unitaires**

- **Testez des unités isolées** : Chaque test doit se concentrer sur une seule unité de code (fonction, méthode).
- **Nommer clairement les tests** : Les noms des tests doivent refléter ce qu'ils vérifient, par exemple : `test_addition_positifs`, `test_multiplication_zero`.
- **Couvrez les cas limites** : Testez les entrées normales, mais aussi les cas limites (valeurs nulles, vides, extrêmes, etc.).
- **Évitez les tests redondants** : Un test unitaire doit vérifier un comportement spécifique et ne pas répéter les tests d'autres fonctions.
- **Utilisez des fixtures** pour configurer l'état de l'application avant les tests et nettoyer après.

#### 5. **Exemples d'utilisation de tests unitaires**

- **Vérification des résultats d'une fonction mathématique** : Tester une fonction d'addition, de multiplication, ou des calculs complexes.
- **Gestion des exceptions** : Tester que certaines erreurs ou exceptions sont correctement levées en fonction des entrées.
- **Interaction avec une base de données** : Tester les requêtes et les connexions à une base de données (en utilisant des mocks pour éviter les dépendances réelles).

#### 6. **Mocking et tests d'interaction**

Les tests unitaires peuvent aussi impliquer la simulation de comportements externes, comme des appels à des API ou des interactions avec une base de données. **`unittest.mock`** ou **`pytest-mock`** permettent de "mocker" (simuler) ces interactions pour rendre les tests plus rapides et isolés.

```python
from unittest.mock import patch

# Exemple avec mock
def get_data_from_api():
    # Simule un appel à une API externe
    return {"data": "some data"}

@patch('module.get_data_from_api')
def test_api_call(mock_get_data):
    mock_get_data.return_value = {"data": "mocked data"}
    assert get_data_from_api() == {"data": "mocked data"}
```

#### 7. **Résumé**

- **Tests unitaires** : Méthode pour tester des petites unités de code (fonction/méthode) de manière isolée.
- **`unittest` et `pytest`** : Frameworks principaux pour écrire et exécuter des tests unitaires en Python. `unittest` fait partie de la bibliothèque standard, tandis que `pytest` est un outil plus flexible et puissant, souvent préféré dans la communauté.
- **Assertions** : Les tests valident les comportements attendus du code en utilisant des assertions pour comparer les résultats obtenus et attendus.
- **Fixtures et mocks** : Utilisés pour préparer les environnements de test et simuler des comportements externes.

Les tests unitaires jouent un rôle crucial dans la qualité et la stabilité du code, en permettant de détecter des bugs tôt dans le processus de développement.

### Chapitre 19 **Fonctions récursives**

Les **fonctions récursives** sont des fonctions qui s’appellent elles-mêmes afin de résoudre un problème. Elles sont particulièrement efficaces pour résoudre des problèmes qui peuvent être divisés en sous-problèmes similaires ou qui présentent une structure de type « diviser pour régner ».

#### 1. **Principe de la récursion**

Une fonction est dite **récursive** lorsque, dans son corps, elle effectue un appel à elle-même. Cependant, pour éviter une récursion infinie, il est nécessaire de définir une **condition d'arrêt**. Sans cette condition, la fonction continuerait à s'appeler indéfiniment, entraînant un dépassement de la pile d'appels (stack overflow).

La **récursion** suit généralement deux étapes :
1. **Cas de base** : La condition qui permet de terminer la récursion. Cela correspond à la situation la plus simple, où la fonction peut renvoyer une valeur directement sans effectuer d'appel récursif.
2. **Appel récursif** : La fonction s'appelle elle-même sur un sous-ensemble plus petit ou plus simple du problème initial.

#### 2. **Structure d'une fonction récursive**

Une fonction récursive se compose généralement de :
- Un cas de base : le critère qui arrête l’appel récursif.
- Un appel récursif : la fonction appelle elle-même avec des arguments modifiés, généralement réduits à chaque itération.

```python
def factorielle(n):
    # Cas de base
    if n == 0:
        return 1
    # Appel récursif
    else:
        return n * factorielle(n - 1)
```

Dans cet exemple, la fonction `factorielle` calcule la factorielle de `n` en multipliant `n` par la factorielle de `n - 1`. La condition de base est `n == 0`, où la fonction retourne simplement `1`, car la factorielle de `0` est définie comme étant `1`.

#### 3. **Exemples classiques de fonctions récursives**

Voici quelques exemples classiques où la récursion est souvent utilisée :

##### a. **Calcul de la factorielle**

La **factorielle** d’un nombre `n`, notée `n!`, est le produit de tous les entiers de `1` à `n`. Elle peut être définie récursivement comme suit :
- Cas de base : `0! = 1`
- Cas général : `n! = n * (n-1)!`

```python
def factorielle(n):
    if n == 0:
        return 1
    return n * factorielle(n - 1)
```

##### b. **Calcul de la suite de Fibonacci**

La suite de **Fibonacci** est définie par la relation :
- Cas de base : `F(0) = 0`, `F(1) = 1`
- Cas général : `F(n) = F(n-1) + F(n-2)`

```python
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)
```

##### c. **Recherche dans une structure arborescente (ex. arbre binaire)**

Dans un arbre binaire, chaque nœud a deux sous-arbres. Pour effectuer une recherche ou traverser un arbre binaire, la récursion est souvent utilisée, en parcourant l'arbre depuis la racine jusqu'aux feuilles.

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def rechercher(nœud, valeur):
    if nœud is None:
        return False
    if nœud.value == valeur:
        return True
    # Recherche récursive dans les sous-arbres
    return rechercher(nœud.left, valeur) or rechercher(nœud.right, valeur)
```

#### 4. **Avantages de la récursion**

La récursion peut être un outil puissant dans plusieurs contextes :
- **Simplicité** : Certains problèmes sont naturellement récursifs, comme les calculs de factorielle, les suites de Fibonacci, ou les problèmes de recherche dans des structures arborescentes. La récursion permet de représenter ces problèmes de manière concise et élégante.
- **Diviser pour régner** : De nombreux algorithmes récursifs reposent sur le principe de diviser un problème en sous-problèmes similaires, chacun étant résolu indépendamment avant de recombiner les résultats.

#### 5. **Inconvénients et précautions**

Bien que la récursion soit élégante et parfois nécessaire, elle comporte certains inconvénients :
- **Problèmes de performance** : Dans certains cas, la récursion peut être moins performante que des boucles itératives en raison du **coût des appels de fonction**. De plus, chaque appel récursif consomme de la mémoire (empilement des appels), ce qui peut mener à une **dépassement de pile** si la profondeur de récursion est trop élevée.
- **Risque de dépassement de pile (stack overflow)** : Si la condition d'arrêt n'est pas correctement définie ou si les appels récursifs sont trop nombreux, la pile d'exécution peut se remplir et provoquer un dépassement de mémoire. C'est ce qu'on appelle un **stack overflow**.

#### 6. **Optimisation de la récursion**

Il existe des techniques permettant d’optimiser la récursion et d’éviter certains problèmes de performance :
- **Récursion terminale** : Il s'agit d'une optimisation où l'appel récursif est la dernière instruction exécutée dans la fonction. Cela permet à certains langages de programmation (comme le Python optimisé) d’éviter de conserver les appels précédents dans la pile d’exécution.
- **Mémorisation (Memoization)** : Cette technique consiste à enregistrer les résultats des appels récursifs déjà effectués pour éviter de recalculer la même chose plusieurs fois. Python offre le module `functools.lru_cache` pour la mémorisation automatique.

```python
from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)
```

#### 7. **Résumé**

- **Récursion** : Une fonction récursive s'appelle elle-même pour résoudre un problème.
- **Cas de base et appel récursif** : La récursion nécessite un cas de base pour éviter une boucle infinie et des appels récursifs qui réduisent progressivement la complexité du problème.
- **Applications** : La récursion est utilisée dans des algorithmes comme le calcul de la factorielle, la suite de Fibonacci, les recherches dans des structures arborescentes, etc.
- **Optimisation** : Des techniques comme la récursion terminale et la mémorisation peuvent être utilisées pour améliorer l’efficacité des fonctions récursives.

En résumé, les fonctions récursives sont un outil puissant pour résoudre des problèmes complexes de manière élégante, mais il est crucial de s'assurer que les conditions d'arrêt sont bien définies pour éviter les dépassements de pile et d'autres problèmes de performance.

### Chapitre 20 **Gestion des dépendances (pip, virtualenv)**

La gestion des dépendances est une partie essentielle du développement en Python, surtout lorsqu'on travaille avec des bibliothèques externes ou lorsque le projet a des besoins spécifiques en termes de versions de ces bibliothèques. Cela garantit que toutes les parties de votre projet fonctionnent correctement ensemble, sans conflit ni incompatibilité.

Voici les concepts clés et outils liés à la gestion des dépendances en Python :

#### 1. **`pip` (Python Package Installer)**

`pip` est l'outil de gestion de paquets par défaut en Python. Il permet d'installer, de désinstaller, de mettre à jour et de gérer les bibliothèques tierces utilisées dans un projet. `pip` se connecte au **Python Package Index (PyPI)**, qui est le dépôt principal de paquets Python.

##### a. **Installation d'un paquet**

Pour installer une bibliothèque avec `pip`, on utilise la commande suivante dans le terminal ou la ligne de commande :
```bash
pip install nom_du_paquet
```
Par exemple, pour installer **requests** (une bibliothèque pour effectuer des requêtes HTTP) :
```bash
pip install requests
```

##### b. **Installation avec une version spécifique**

Il est possible d’installer une version précise d’un paquet :
```bash
pip install requests==2.25.1
```

##### c. **Mise à jour d’un paquet**

Pour mettre à jour un paquet à sa dernière version disponible :
```bash
pip install --upgrade requests
```

##### d. **Désinstallation d’un paquet**

Pour désinstaller un paquet de votre environnement :
```bash
pip uninstall requests
```

##### e. **Lister les paquets installés**

Vous pouvez obtenir la liste de tous les paquets installés dans votre environnement avec la commande :
```bash
pip list
```

##### f. **Exporter les dépendances**

Si vous souhaitez créer un fichier de **dépendances** pour un projet, vous pouvez utiliser `pip freeze` pour générer un fichier `requirements.txt` :
```bash
pip freeze > requirements.txt
```
Ce fichier contient toutes les dépendances du projet avec leurs versions exactes.

##### g. **Installation depuis un fichier requirements.txt**

Pour installer toutes les dépendances listées dans un fichier `requirements.txt`, utilisez :
```bash
pip install -r requirements.txt
```
Cela permet de garantir que tous les membres d’un projet ou de l’équipe utilisent les mêmes versions des bibliothèques.

#### 2. **Environnements virtuels (`virtualenv`, `venv`)**

Un **environnement virtuel** est un espace isolé dans lequel vous pouvez installer des dépendances spécifiques à un projet sans interférer avec le reste de votre système. Cela permet d'éviter les conflits entre les versions de bibliothèques utilisées par différents projets.

##### a. **Création d’un environnement virtuel**

Python propose deux outils pour créer des environnements virtuels :
- `virtualenv` (ancien outil)
- `venv` (module intégré dans Python à partir de la version 3.3)

###### Avec `venv` (préféré pour les versions récentes de Python) :
```bash
python3 -m venv nom_de_l_environnement
```

Cela crée un répertoire `nom_de_l_environnement` qui contient un environnement isolé avec une copie propre de Python.

##### b. **Activation de l'environnement virtuel**

Pour activer l'environnement virtuel, suivez les instructions en fonction de votre système d’exploitation :

- **Windows** :
```bash
nom_de_l_environnement\Scripts\activate
```
- **MacOS/Linux** :
```bash
source nom_de_l_environnement/bin/activate
```

Une fois activé, votre terminal devrait afficher le nom de l'environnement, ce qui indique que vous êtes dans cet environnement virtuel.

##### c. **Installation des dépendances dans l’environnement virtuel**

Une fois l’environnement virtuel activé, toutes les bibliothèques installées avec `pip` seront installées uniquement dans cet environnement, sans affecter le reste du système. Par exemple :
```bash
pip install requests
```

##### d. **Désactivation de l’environnement virtuel**

Lorsque vous avez fini de travailler dans l'environnement virtuel, vous pouvez le désactiver en utilisant la commande :
```bash
deactivate
```

Cela vous ramène à l’environnement Python global.

#### 3. **Utilisation d’un fichier `requirements.txt` dans un environnement virtuel**

Il est courant d’utiliser un fichier `requirements.txt` pour gérer les dépendances de votre projet et garantir la cohérence des environnements entre les membres d’une équipe. Voici comment l’utiliser avec un environnement virtuel :

1. **Créer un environnement virtuel** :
```bash
python3 -m venv venv
```

2. **Activer l’environnement virtuel** :
```bash
source venv/bin/activate   # sur MacOS/Linux
venv\Scripts\activate      # sur Windows
```

3. **Installer les dépendances à partir de `requirements.txt`** :
```bash
pip install -r requirements.txt
```

Cela garantit que toutes les bibliothèques nécessaires au projet sont installées dans l’environnement virtuel.

#### 4. **Gestion des dépendances dans un environnement de développement**

L'utilisation des environnements virtuels permet de gérer plusieurs projets Python sur une même machine, sans que les bibliothèques et les versions de Python n'entrent en conflit. De plus, chaque environnement virtuel peut avoir ses propres dépendances, ce qui permet une isolation parfaite des projets.

##### a. **Exemple de fichier `requirements.txt`**
Voici un exemple de contenu d’un fichier `requirements.txt` :
```
requests==2.25.1
numpy==1.19.5
flask==2.0.1
```

##### b. **Mise à jour des dépendances**

Lorsque vous ajoutez ou mettez à jour des dépendances dans votre environnement virtuel, n’oubliez pas de mettre à jour le fichier `requirements.txt` pour refléter les nouvelles versions des paquets installés :
```bash
pip freeze > requirements.txt
```

#### 5. **Avantages de la gestion des dépendances**

- **Isolément des dépendances** : Chaque projet peut avoir ses propres bibliothèques et versions, ce qui permet d’éviter les conflits.
- **Portabilité** : Vous pouvez facilement partager votre projet avec d’autres développeurs ou déployer sur des serveurs sans craindre des problèmes de dépendances.
- **Facilité de gestion** : Vous pouvez facilement gérer les versions des paquets et installer un ensemble complet de dépendances avec une simple commande `pip install -r requirements.txt`.

#### 6. **Résumé**

- **`pip`** est l'outil principal pour installer et gérer des bibliothèques Python depuis le PyPI.
- **`virtualenv` et `venv`** sont des outils pour créer des environnements virtuels afin d’isoler les dépendances de chaque projet Python.
- Un fichier **`requirements.txt`** permet de spécifier les bibliothèques et leurs versions, et il est utilisé pour installer toutes les dépendances nécessaires avec `pip install -r requirements.txt`.
- Ces outils permettent de travailler sur plusieurs projets Python en parallèle sans conflit et assurent une gestion cohérente des dépendances à travers différentes plateformes et environnements.

Ainsi, la gestion des dépendances est essentielle pour le développement de projets Python bien structurés et faciles à maintenir.

### Chapitre 21 **Mécanismes de concurrence (asyncio)**

Le module `asyncio` de Python permet de créer des programmes asynchrones. Il est principalement utilisé pour gérer la concurrence sans avoir besoin de gérer directement des threads ou des processus. En utilisant des mécanismes non bloquants, `asyncio` permet d'exécuter plusieurs tâches en parallèle dans une seule boucle d'événements, rendant le programme plus efficace, surtout lorsqu'il y a des opérations d'attente longues (comme les requêtes réseau, les lectures de fichiers, etc.).

#### 1. **Introduction à `asyncio`**

`asyncio` repose sur la programmation asynchrone avec des **coroutines**, des fonctions spéciales qui peuvent être suspendues et reprises à des points spécifiques dans le temps. Cette approche permet d'exécuter d'autres tâches pendant que l'une d'elles attend une ressource (par exemple, une réponse réseau).

Les coroutines sont créées avec le mot-clé `async def` et peuvent être "attendues" avec `await`.

#### 2. **Composants principaux de `asyncio`**

1. **Coroutines**
   - Ce sont des fonctions spéciales qui utilisent les mots-clés `async` et `await`.
   - `async def` est utilisé pour définir une fonction asynchrone (coroutine).
   - `await` est utilisé pour appeler une autre coroutine et attendre qu'elle soit terminée sans bloquer l'exécution du programme.

2. **Boucle d'événements (`event loop`)**
   - La boucle d'événements est au cœur d'un programme asynchrone. Elle est responsable de la gestion et de l'exécution des tâches asynchrones.
   - La boucle d'événements s'exécute de manière continue et, chaque fois qu'une tâche asynchrone se termine, elle en démarre une autre.

3. **Tâches (`tasks`)**
   - Une tâche est une coroutine qui a été programmée pour être exécutée dans la boucle d'événements.
   - Les tâches sont créées via `asyncio.create_task()`, et une fois créées, elles sont automatiquement gérées par la boucle d'événements.

4. **Futures**
   - Les futures représentent des résultats qui ne sont pas encore disponibles. Lorsqu'une coroutine effectue une opération asynchrone, elle peut retourner un `Future`, que vous pouvez "attendre" pour obtenir le résultat final.

5. **`asyncio.run()`**
   - Utilisé pour démarrer un programme asynchrone, en exécutant la boucle d'événements principale jusqu'à ce que tout le travail soit terminé.

#### 3. **Création d'un programme asynchrone avec `asyncio`**

Voici les étapes fondamentales pour créer un programme asynchrone :

1. **Définir des coroutines avec `async def`** :
   Une coroutine est une fonction qui peut être mise en pause et reprise à des moments donnés.

2. **Utiliser `await` pour appeler d'autres coroutines** :
   Vous utilisez `await` pour attendre que d'autres coroutines ou futures terminent sans bloquer l'exécution de votre programme.

3. **Exécuter la boucle d'événements avec `asyncio.run()`** :
   Cela permet de démarrer la boucle d'événements, d'exécuter les coroutines et d'attendre que tout le travail soit terminé.

#### 4. **Exemple détaillé de programme asynchrone avec `asyncio`**

Supposons que nous avons une fonction qui simule une requête réseau (une opération asynchrone) :

```python
import asyncio

async def fetch_data():
    print("Début de la récupération des données")
    await asyncio.sleep(2)  # Simule une attente de 2 secondes (par exemple, une requête réseau)
    print("Données récupérées")

async def main():
    # Lance deux coroutines en parallèle
    task1 = asyncio.create_task(fetch_data())
    task2 = asyncio.create_task(fetch_data())

    # Attend que les deux tâches soient terminées
    await task1
    await task2

# Démarre la boucle d'événements et exécute 'main'
asyncio.run(main())
```

#### **Explication de l'exemple** :
1. **`async def fetch_data()`** : Cette fonction est une coroutine qui simule une tâche longue (attente de 2 secondes). Pendant ce temps, la boucle d'événements peut exécuter d'autres tâches.
   
2. **`await asyncio.sleep(2)`** : Cette ligne de code suspend l'exécution de la coroutine `fetch_data()` pendant 2 secondes, sans bloquer l'exécution d'autres tâches dans la boucle d'événements.

3. **`asyncio.create_task()`** : Cette fonction permet de créer une tâche à partir de la coroutine `fetch_data()`. Cela signifie que la coroutine sera exécutée en parallèle avec d'autres tâches.

4. **`await task1` et `await task2`** : Ces lignes attendent que les deux tâches soient terminées avant de continuer.

5. **`asyncio.run(main())`** : C'est le point d'entrée du programme asynchrone. Il démarre la boucle d'événements et exécute la coroutine `main()`.

#### 5. **Gérer plusieurs tâches concurrentes**

Lorsque vous avez plusieurs tâches à exécuter en parallèle, `asyncio` vous permet de gérer efficacement leur exécution. Par exemple, en utilisant `asyncio.gather()`, vous pouvez attendre l'achèvement de plusieurs coroutines en parallèle :

```python
import asyncio

async def task1():
    print("Tâche 1 en cours")
    await asyncio.sleep(1)
    print("Tâche 1 terminée")

async def task2():
    print("Tâche 2 en cours")
    await asyncio.sleep(2)
    print("Tâche 2 terminée")

async def main():
    # Exécute les deux tâches en parallèle et attend leur achèvement
    await asyncio.gather(task1(), task2())

asyncio.run(main())
```

Dans cet exemple, `task1()` et `task2()` sont exécutées en parallèle, et le programme attend leur terminaison avec `asyncio.gather()`.

#### 6. **Gestion des exceptions dans les coroutines**

Comme dans un programme synchrone, vous pouvez gérer les exceptions dans les coroutines en utilisant `try` / `except` :

```python
import asyncio

async def fetch_data():
    try:
        print("Début de la récupération des données")
        await asyncio.sleep(2)
        raise ValueError("Erreur pendant la récupération des données")  # Simuler une erreur
    except ValueError as e:
        print(f"Exception capturée : {e}")

asyncio.run(fetch_data())
```

Dans ce cas, une exception est levée et capturée dans la coroutine, et l'exécution ne bloque pas le programme.

#### 7. **Avantages de `asyncio`**

- **Efficacité en termes de ressources** : Aucun thread supplémentaire n'est nécessaire, ce qui réduit l'overhead lié à la gestion des threads.
- **Non-bloquant** : Permet de gérer plusieurs opérations I/O (comme des requêtes HTTP, des lectures de fichiers) de manière efficace sans bloquer l'exécution du programme.
- **Exécution parallèle** : `asyncio` permet d'exécuter plusieurs tâches simultanément dans une seule boucle d'événements, ce qui est particulièrement utile pour des programmes qui doivent effectuer de nombreuses opérations d'attente.

#### 8. **Limitations et considérations**

- `asyncio` est particulièrement adapté pour les applications I/O-bound (attente de données) mais moins pour les applications CPU-bound (intensives en calculs), où le multithreading ou le multiprocessing peut être plus efficace.
- Certaines bibliothèques existantes ne supportent pas encore nativement les appels asynchrones. Dans ce cas, l'utilisation de threads ou de processus parallèles pourrait être nécessaire.

### **Résumé**
- **`asyncio`** permet de créer des programmes asynchrones en Python, en exécutant plusieurs tâches simultanément sans bloquer l'exécution du programme principal.
- Il repose sur l'utilisation de **coroutines**, qui sont des fonctions spéciales pouvant être suspendues et reprises.
- Les programmes asynchrones sont gérés par une **boucle d'événements**, et les tâches sont créées avec **`asyncio.create_task()`**.
- **`asyncio.run()`** est utilisé pour démarrer et exécuter une boucle d'événements.

### Chapitre 22 **Gestion des versions avec Git**

Git est un système de contrôle de version décentralisé qui permet de suivre l'historique des modifications d'un projet, de gérer des branches et de collaborer avec d'autres développeurs de manière fluide. Il est utilisé pour enregistrer les changements dans les fichiers du projet, et pour permettre à plusieurs personnes de travailler sur un même code sans écraser le travail des autres.

#### 1. **Installation et configuration de Git**

Avant de commencer à utiliser Git, vous devez l'installer sur votre machine. Voici les étapes principales :

1. **Installer Git** :
   - Pour **Windows** : Téléchargez l'installateur depuis [git-scm.com](https://git-scm.com/) et suivez les instructions.
   - Pour **macOS** : Utilisez Homebrew avec la commande `brew install git`, ou téléchargez l'installateur depuis [git-scm.com](https://git-scm.com/).
   - Pour **Linux** : Utilisez le gestionnaire de paquets (par exemple `sudo apt install git` pour Ubuntu).

2. **Configurer Git** : Après l'installation, vous devez configurer Git avec votre nom et votre email pour qu'il puisse suivre les modifications effectuées par vous.
   ```bash
   git config --global user.name "Votre Nom"
   git config --global user.email "votre.email@example.com"
   ```

#### 2. **Initialisation d'un repository Git**

Un repository Git est un dossier où Git va suivre l'historique des fichiers du projet. Vous pouvez initialiser un nouveau repository dans un dossier avec la commande :

```bash
git init
```

Cela crée un dossier `.git` dans votre projet, où Git enregistre l'historique des fichiers.

#### 3. **Commandes de base de Git**

Voici les commandes Git les plus courantes et utiles :

1. **`git status`** : Affiche l'état actuel du repository, c'est-à-dire les fichiers modifiés, ajoutés ou non suivis.
   ```bash
   git status
   ```

2. **`git add`** : Ajoute des fichiers au stage (zone de préparation) avant de les valider dans l'historique.
   ```bash
   git add <fichier>  # Pour ajouter un fichier spécifique
   git add .          # Pour ajouter tous les fichiers modifiés
   ```

3. **`git commit`** : Valide les modifications ajoutées au stage, en incluant un message décrivant les changements.
   ```bash
   git commit -m "Message décrivant les modifications"
   ```

4. **`git log`** : Affiche l'historique des commits du repository.
   ```bash
   git log
   ```

5. **`git diff`** : Affiche les différences entre les fichiers modifiés et les versions précédentes.
   ```bash
   git diff
   ```

6. **`git push`** : Envoie les commits locaux vers un repository distant (par exemple, GitHub).
   ```bash
   git push origin master  # Envoie sur la branche 'master'
   ```

7. **`git pull`** : Récupère et intègre les modifications d'un repository distant dans votre repository local.
   ```bash
   git pull origin master  # Récupère les dernières modifications de la branche 'master'
   ```

#### 4. **Gestion des branches**

Les branches sont des copies indépendantes du code, qui permettent de travailler sur des fonctionnalités ou des corrections sans affecter le code principal (généralement la branche `master` ou `main`). Git facilite la gestion des branches avec les commandes suivantes :

1. **Créer une nouvelle branche** :
   ```bash
   git branch <nom_de_branche>
   ```

2. **Basculer vers une autre branche** :
   ```bash
   git checkout <nom_de_branche>
   ```

3. **Créer et basculer vers une branche en une seule commande** :
   ```bash
   git checkout -b <nom_de_branche>
   ```

4. **Fusionner une branche dans la branche actuelle** :
   Une fois que vous avez terminé les changements dans une branche et que vous souhaitez les intégrer dans la branche principale (par exemple `master`), vous utilisez `git merge`.
   ```bash
   git checkout master  # Basculez sur la branche master
   git merge <nom_de_branche>  # Fusionne la branche dans master
   ```

5. **Supprimer une branche** :
   Une fois une branche fusionnée ou inutilisée, vous pouvez la supprimer.
   ```bash
   git branch -d <nom_de_branche>
   ```

6. **Voir les branches disponibles** :
   ```bash
   git branch  # Liste les branches locales
   git branch -r  # Liste les branches distantes
   ```

#### 5. **Collaboration avec des repositories distants (GitHub, GitLab, etc.)**

Git permet de collaborer sur des projets en utilisant des repositories distants. Voici comment utiliser un repository distant avec Git :

1. **Ajouter un remote (repository distant)** :
   Vous devez d'abord lier votre repository local à un repository distant (par exemple, sur GitHub ou GitLab).
   ```bash
   git remote add origin https://github.com/votre_utilisateur/nom_du_repository.git
   ```

2. **Pousser les changements vers le repository distant** :
   Après avoir effectué un commit, vous pouvez envoyer vos modifications vers le repository distant.
   ```bash
   git push -u origin master
   ```

3. **Cloner un repository distant** :
   Pour travailler sur un projet existant, vous pouvez cloner un repository distant sur votre machine locale.
   ```bash
   git clone https://github.com/votre_utilisateur/nom_du_repository.git
   ```

#### 6. **Résolution des conflits**

Les conflits se produisent lorsqu'il y a des changements contradictoires dans deux branches différentes qui sont fusionnées. Pour résoudre un conflit :

1. **Fusionner deux branches** avec `git merge`.
2. Si un conflit survient, Git marquera les fichiers en conflit. Vous devez alors ouvrir ces fichiers et résoudre manuellement les conflits.
3. Après avoir résolu le conflit, vous devez ajouter à nouveau les fichiers et valider la fusion.
   ```bash
   git add <fichier_conflit>
   git commit
   ```

#### 7. **Tags et versions**

Les tags sont utilisés pour marquer des points spécifiques dans l'historique, souvent pour identifier des versions de code.

1. **Créer un tag** :
   ```bash
   git tag -a v1.0 -m "Version 1.0"
   ```

2. **Lister les tags** :
   ```bash
   git tag
   ```

3. **Pousser un tag vers un repository distant** :
   ```bash
   git push origin v1.0
   ```

#### 8. **Bonnes pratiques avec Git**

- **Commits fréquents et descriptifs** : Faites des commits fréquents pour que l'historique soit facile à comprendre. Chaque commit doit être accompagné d'un message clair et descriptif.
- **Travailler avec des branches** : Utilisez des branches pour travailler sur des fonctionnalités ou corrections spécifiques, puis fusionnez-les une fois qu'elles sont prêtes.
- **Collaborer efficacement** : Avant de pousser vos changements, faites un `git pull` pour vous assurer que vous avez la dernière version du projet. Résolvez les conflits avant de pousser.

### **Résumé**

- **Git** permet de suivre l’historique du code, de collaborer avec d’autres développeurs et de gérer des versions de manière décentralisée.
- Il permet de gérer des **branches**, ce qui facilite l'ajout de nouvelles fonctionnalités sans affecter la version principale du code.
- **GitHub** et d'autres services permettent de collaborer à distance en hébergeant des repositories Git et en facilitant le partage de code.
- Git gère efficacement l'historique du projet, permet de revenir en arrière en cas d'erreurs et favorise un travail collaboratif via des outils comme les **pull requests** et les **merge requests**.

En utilisant **Git** de manière optimale, vous pouvez rendre votre processus de développement plus organisé, cohérent et efficace.

### Chapitre 23 **Optimisation et Compilateurs JIT**

L'optimisation du code est essentielle pour améliorer ses performances, en particulier pour les applications exigeantes en calcul. Python, grâce à ses bibliothèques et outils, offre plusieurs moyens d'analyser et d'accélérer le code. Une des solutions avancées inclut les **compilateurs JIT (Just-In-Time)**, comme **Numba**.

---

#### **1. Profilage de code**

Le profilage permet d'identifier les sections du code qui consomment le plus de temps ou de mémoire. Cela permet de cibler les optimisations.

**a. Utilisation de `timeit`**  

Mesure précise du temps d'exécution d'un morceau de code.
  
```python
import timeit

# Exemple simple
code_to_test = """
result = sum([i for i in range(1000)])
"""
execution_time = timeit.timeit(code_to_test, number=1000)
print(f"Temps d'exécution : {execution_time} secondes")
```

**b. Utilisation de `cProfile`**  

Analyse des performances d'un programme en entier.  
```python
import cProfile

def test_function():
    result = sum([i for i in range(100000)])
    return result

cProfile.run('test_function()')
```

**c. Utilisation de `memory_profiler`**  

Surveillance de l'utilisation de la mémoire (nécessite une installation préalable).  

```bash
pip install memory_profiler
```
Exemple :  
```python
from memory_profiler import profile

@profile
def test_memory():
    data = [i for i in range(1000000)]
    del data

test_memory()
```

---

#### **2. Introduction au compilateur JIT : Numba**

**Numba** est une bibliothèque qui compile du code Python en code machine au moment de l'exécution (**Just-In-Time**), utilisant LLVM pour une accélération des calculs. Il est particulièrement efficace pour les boucles lourdes et les calculs mathématiques.

**Installation** :  
```bash
pip install numba
```

**a. Exemple de base avec Numba**  

Appliquez le décorateur `@jit` pour accélérer une fonction.  

```python
from numba import jit
import numpy as np

@jit
def sum_array(arr):
    result = 0
    for i in arr:
        result += i
    return result

array = np.arange(1_000_000)
print(sum_array(array))  # Exécution rapide grâce à la compilation JIT
```

**b. Mode nopython pour optimiser davantage** 
 
Le mode `nopython=True` force Numba à tout compiler en code machine, excluant l'interprétation Python.  

```python
@jit(nopython=True)
def sum_array_optimized(arr):
    result = 0
    for i in arr:
        result += i
    return result
```

**c. Accélération des boucles imbriquées**  

Les boucles complexes peuvent bénéficier d'améliorations significatives avec Numba.  

```python
@jit(nopython=True)
def matrix_multiplication(A, B):
    rows, cols = A.shape[0], B.shape[1]
    result = np.zeros((rows, cols))
    for i in range(rows):
        for j in range(cols):
            for k in range(A.shape[1]):
                result[i, j] += A[i, k] * B[k, j]
    return result

A = np.random.rand(100, 100)
B = np.random.rand(100, 100)
print(matrix_multiplication(A, B))
```

**d. Comparaison avec Python pur**  
Comparez les performances avant et après l'utilisation de Numba pour visualiser l'amélioration.

---

#### **3. Techniques supplémentaires pour l'optimisation**

- **Vectorisation avec NumPy** : Préférez les opérations vectorisées aux boucles explicites.  

  ```python
  import numpy as np

  # Calcul vectorisé
  array = np.arange(1_000_000)
  result = np.sum(array)  # Plus rapide qu'une boucle Python
  ```

- **Multithreading et multiprocessing** : Combinez Numba avec des techniques de parallélisation pour maximiser les performances.

- **Caching avec Numba** : Conservez les compilations pour éviter de les recalculer à chaque exécution.  

  ```python
  @jit(nopython=True, cache=True)
  def cached_function(arr):
      return np.sum(arr)
  ```

---

### **Résumé**

- **Profilage** : Utilisez `timeit`, `cProfile`, et `memory_profiler` pour identifier les goulots d'étranglement en termes de temps et de mémoire.
- **Numba** : Simplifiez l'accélération des calculs intensifs avec un compilateur JIT. Ses points forts sont les calculs numériques et les boucles.
- **Optimisation combinée** : Combinez Numba avec NumPy et d'autres outils pour maximiser les performances.
  
En exploitant ces techniques, vous pouvez considérablement accélérer vos programmes Python tout en gardant un code lisible et efficace.

### Chapitre 24 **Interopérabilité et Extensions : Connecter Python avec C/C++**

Python, bien que puissant, peut parfois manquer de performances pour des tâches nécessitant des calculs intensifs. Dans de tels cas, il est possible d'exploiter des bibliothèques écrites en C ou C++ pour améliorer les performances tout en utilisant Python comme interface. **SWIG** et **PyBind11** sont deux outils populaires pour créer cette interopérabilité.

---

### **1. SWIG : Simplified Wrapper and Interface Generator**

SWIG est un outil qui permet de générer automatiquement du code de liaison entre des bibliothèques écrites en C/C++ et des langages comme Python. Il est utilisé pour exposer des bibliothèques complexes de manière simple.

#### **a. Installation de SWIG**

Assurez-vous d'avoir SWIG installé sur votre système.

```bash
sudo apt-get install swig    # Sous Linux
brew install swig            # Sous macOS
choco install swig           # Sous Windows
```

#### **b. Structure de base d'un projet SWIG**
Un projet SWIG typique comprend :
- Un fichier C ou C++ contenant la logique principale.
- Un fichier d'interface `.i` utilisé par SWIG pour générer les liaisons.

#### **c. Exemple simple : Fonction C**

**Fichier `example.c` :**

```c
#include <math.h>

double square(double x) {
    return x * x;
}
```

**Fichier d'interface SWIG `example.i` :**

```swig
%module example

%{
#include "example.c"
%}

double square(double x);
```

**Commande pour générer les liaisons :**
```bash
swig -python -o example_wrap.c example.i
gcc -shared -o _example.so -fPIC example.c example_wrap.c -I/usr/include/python3.8
```

Le fichier `_example.so` généré peut être importé directement dans Python :

```python
import example
print(example.square(4))  # Affiche 16.0
```

#### **d. Avantages de SWIG**
- Prend en charge plusieurs langages (Python, Java, etc.).
- Facile à configurer pour des fonctions simples.

#### **e. Limites de SWIG**
- Peut devenir complexe à gérer pour des projets très grands ou avancés.
- Nécessite parfois des ajustements manuels dans le fichier d'interface.

---

### **2. PyBind11 : Interface moderne pour Python et C++**

**PyBind11** est une bibliothèque moderne pour lier C++ à Python. Elle est particulièrement utile pour exposer des classes et des fonctions C++ en Python avec un minimum de surcharge.

#### **a. Installation de PyBind11**

Installez PyBind11 avec pip ou à partir des sources :

```bash
pip install pybind11
```

#### **b. Structure d'un projet PyBind11**
Un projet PyBind11 typique inclut :
- Du code C++ avec la logique principale.
- Un fichier d'extension écrit avec PyBind11.

#### **c. Exemple simple : Fonction C++**

**Fichier `example.cpp` :**

```cpp
#include <pybind11/pybind11.h>

double square(double x) {
    return x * x;
}

PYBIND11_MODULE(example, m) {
    m.doc() = "Module PyBind11 d'exemple";
    m.def("square", &square, "Calcule le carré d'un nombre");
}
```

**Compilation avec PyBind11 :**

Utilisez la commande suivante pour compiler avec le compilateur GCC :

```bash
c++ -O3 -Wall -shared -std=c++11 -fPIC $(python3 -m pybind11 --includes) example.cpp -o example$(python3-config --extension-suffix)
```

**Utilisation en Python :**

```python
import example
print(example.square(4))  # Affiche 16.0
```

#### **d. Exposition des classes**

PyBind11 permet également de lier des classes C++ :

```cpp
#include <pybind11/pybind11.h>

class Point {
public:
    Point(double x, double y) : x(x), y(y) {}
    double distance_to_origin() const {
        return sqrt(x * x + y * y);
    }

private:
    double x, y;
};

PYBIND11_MODULE(example, m) {
    pybind11::class_<Point>(m, "Point")
        .def(pybind11::init<double, double>())
        .def("distance_to_origin", &Point::distance_to_origin);
}
```

En Python :

```python
import example
p = example.Point(3, 4)
print(p.distance_to_origin())  # Affiche 5.0
```

#### **e. Avantages de PyBind11**
- Interface moderne et intuitive pour C++11 et versions ultérieures.
- Gestion naturelle des exceptions et des types Python/C++.
- Support natif des fonctionnalités avancées comme les surcharges et les classes.

#### **f. Limites de PyBind11**
- Ne prend en charge que Python (contrairement à SWIG).
- Moins adapté pour les très grandes bibliothèques sans refactoring.

---

### **3. Comparaison SWIG vs PyBind11**

| Critère                 | SWIG                         | PyBind11                   |
|-------------------------|------------------------------|----------------------------|
| **Facilité d'utilisation** | Moyen                      | Très élevé                 |
| **Langages pris en charge** | Python, Java, Ruby, etc.   | Python uniquement          |
| **Documentation moderne**   | Moyenne                   | Excellente                 |
| **Adaptation aux grands projets** | Adapté pour de gros projets | Idéal pour des modules spécifiques |
| **Performance**         | Bonne                       | Très bonne (C++ moderne)   |

---

### **Résumé**

1. **SWIG** est un outil polyvalent pour connecter Python à C/C++ et d'autres langages. Idéal pour les projets interlangages complexes.
2. **PyBind11** offre une solution moderne et intuitive pour intégrer des bibliothèques C++ dans Python, particulièrement adaptée pour les projets C++ récents et les besoins spécifiques.  
3. Combinez ces outils avec des tests et des optimisations pour tirer le meilleur parti des performances de C/C++ tout en exploitant la simplicité de Python.

### Chapitre 25 **Programmation à Grande Échelle : Gestion des Workflows et Calcul Distribué**

La programmation à grande échelle se concentre sur l'optimisation des workflows complexes et sur la gestion efficace des ressources pour traiter des quantités massives de données ou exécuter des tâches asynchrones en parallèle. **Celery** et **Dask** sont deux outils puissants pour répondre à ces besoins.

---

### **1. Gestion de Workflows Asynchrones avec Celery**

Celery est une bibliothèque Python de gestion de tâches distribuées, souvent utilisée pour exécuter des tâches asynchrones dans des systèmes distribués, comme l'envoi d'e-mails, le traitement de fichiers ou les calculs de fond.

#### **a. Installation de Celery**

Installez Celery avec un backend comme Redis ou RabbitMQ pour la gestion des files d'attente :
```bash
pip install celery[redis]
```

#### **b. Exemple simple : Tâche asynchrone**

**Structure du projet :**
```
my_project/
├── tasks.py
├── celery_app.py
```

**Fichier `celery_app.py` :**

```python
from celery import Celery

# Configuration de l'application Celery avec Redis comme backend

app = Celery('my_project', broker='redis://localhost:6379/0', backend='redis://localhost:6379/0')
```

**Fichier `tasks.py` :**

```python
from celery_app import app

@app.task
def add(x, y):
    return x + y
```

**Exécution de la tâche :**

- Lancez le worker Celery :

  ```bash
  celery -A celery_app worker --loglevel=info
  ```

- Appelez la tâche dans un script Python :

  ```python
  from tasks import add
  result = add.delay(4, 6)
  print(result.get())  # Affiche 10
  ```

#### **c. Avantages de Celery**
- Conception modulaire pour la gestion de workflows complexes.
- Compatible avec plusieurs backends comme Redis, RabbitMQ, et Amazon SQS.
- Permet l'exécution planifiée des tâches avec `celery-beat`.

#### **d. Cas d'utilisation**
- Traitement en arrière-plan (e-mails, notifications).
- Analyse des données en lot.
- Orchestration des workflows en microservices.

---

### **2. Calcul Distribué avec Dask**

Dask est une bibliothèque Python conçue pour le calcul parallèle et distribué, particulièrement utile pour traiter de grandes données sur des machines locales ou dans des clusters.

#### **a. Installation de Dask**

Installez Dask avec ses modules principaux :

```bash
pip install dask[complete]
```

#### **b. Concepts de base**
Dask introduit des **graphes de tâches** pour représenter les calculs et les exécuter efficacement sur plusieurs cœurs ou machines.

**Exemple : Traitement parallèle d'une liste**

```python
import dask
from dask import delayed

@delayed
def square(x):
    return x ** 2

@delayed
def sum_squares(squares):
    return sum(squares)

data = [1, 2, 3, 4]
squares = [square(x) for x in data]
result = sum_squares(squares)

print(result.compute())  # Exécute les tâches et affiche 30
```

#### **c. Manipulation de données avec Dask DataFrame**

Dask fournit des structures similaires à pandas mais optimisées pour des jeux de données volumineux :

```python
import dask.dataframe as dd

# Chargement d'un fichier CSV volumineux
df = dd.read_csv('large_dataset.csv')

# Traitement parallèle
filtered_df = df[df['column'] > 10]
result = filtered_df.groupby('another_column').mean()

# Exécution
print(result.compute())
```

#### **d. Gestion des clusters**

Dask peut fonctionner sur un cluster distribué :

- Installez le planificateur Dask :

  ```bash
  dask-scheduler
  ```
- Connectez les travailleurs (workers) :
  ```bash
  dask-worker <adresse_du_scheduler>
  ```

#### **e. Avantages de Dask**
- Extensible : fonctionne aussi bien sur un ordinateur personnel que sur des clusters massifs.
- Compatible avec pandas, NumPy et scikit-learn.
- Aucune modification majeure du code existant pour le paralléliser.

---

### **3. Comparaison Celery vs Dask**

| **Critère**              | **Celery**                      | **Dask**                      |
|--------------------------|----------------------------------|--------------------------------|
| **Objectif principal**   | Gestion de workflows asynchrones | Calcul parallèle et distribué |
| **Backend nécessaire**   | Redis, RabbitMQ, etc.           | Facultatif (ou cluster)       |
| **Complexité des tâches**| Tâches indépendantes            | Tâches interconnectées        |
| **Domaines d'application** | Tâches d'arrière-plan          | Calcul intensif               |

---

### **Résumé**

1. **Celery** est idéal pour orchestrer des workflows asynchrones, notamment dans des applications web ou des systèmes distribués où les tâches sont relativement indépendantes.
2. **Dask** est mieux adapté pour des charges de travail nécessitant un calcul intensif ou des analyses massives de données, avec une scalabilité naturelle sur plusieurs machines.
3. Ces outils peuvent être combinés pour des pipelines complexes, par exemple, en utilisant Celery pour l'orchestration et Dask pour le traitement des données.

### Chapitre 26 **Gestion des Bases de Données en Python**

La gestion des bases de données est essentielle dans le développement d'applications modernes. Python offre plusieurs outils pour interagir avec des bases relationnelles (SQL) ou non relationnelles (NoSQL). Voici un aperçu des techniques courantes :

---

### **1. MongoDB avec PyMongo**

MongoDB est une base de données NoSQL orientée documents, idéale pour gérer des données semi-structurées.

#### **a. Installation**

Installez la bibliothèque `pymongo` pour interagir avec MongoDB :

```bash
pip install pymongo
```

#### **b. Exemple simple : Connexion et opérations de base**

**Connexion à une base MongoDB :**

```python
from pymongo import MongoClient

# Connexion au serveur MongoDB local
client = MongoClient('mongodb://localhost:27017/')

# Accéder à une base de données et une collection
db = client.my_database
collection = db.my_collection
```

**Insertion de documents :**

```python
document = {"name": "Alice", "age": 25, "city": "Paris"}
collection.insert_one(document)

documents = [
    {"name": "Bob", "age": 30, "city": "Lyon"},
    {"name": "Charlie", "age": 35, "city": "Marseille"}
]
collection.insert_many(documents)
```

**Requêtes simples :**

```python
# Trouver un document
result = collection.find_one({"name": "Alice"})
print(result)

# Trouver plusieurs documents
for doc in collection.find({"age": {"$gte": 30}}):
    print(doc)
```

**Mise à jour et suppression :**

```python
# Mettre à jour un document
collection.update_one({"name": "Alice"}, {"$set": {"age": 26}})

# Supprimer un document
collection.delete_one({"name": "Bob"})
```

#### **c. Avantages de MongoDB**
- Flexible pour des schémas dynamiques.
- Performant pour des applications en temps réel.

---

### **2. Redis comme Cache avec redis-py**

Redis est une base de données NoSQL en mémoire utilisée comme cache rapide ou système de message.

#### **a. Installation**

Installez le client Python pour Redis :

```bash
pip install redis
```

#### **b. Exemple simple : Connexion et stockage de données**

**Connexion à Redis :**

```python
import redis

# Connexion au serveur Redis local
r = redis.Redis(host='localhost', port=6379, db=0)
```

**Stockage et récupération :**

```python
# Ajouter une clé-valeur
r.set('key1', 'value1')

# Récupérer la valeur associée à une clé
value = r.get('key1')
print(value.decode('utf-8'))  # Affiche 'value1'
```

**Incrémentation et expiration :**

```python
# Incrémenter une clé numérique
r.set('counter', 1)
r.incr('counter')  # Résultat : 2

# Ajouter une clé avec expiration
r.setex('temp_key', 10, 'temp_value')  # Expire après 10 secondes
```

**Utilisation comme cache pour des calculs coûteux :**

```python
def cached_function(key, compute_func):
    if r.exists(key):
        return r.get(key).decode('utf-8')
    else:
        result = compute_func()
        r.set(key, result, ex=3600)  # Cache pour 1 heure
        return result
```

---

### **3. ORM de Base avec SQLAlchemy ou Peewee**

Les ORM (Object-Relational Mapping) permettent de manipuler des bases SQL via des objets Python, simplifiant l'interaction avec les bases relationnelles comme MySQL ou PostgreSQL.

#### **a. SQLAlchemy**

**Installation :**

```bash
pip install sqlalchemy
```

**Connexion et définition d'un modèle :**

```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# Connexion à SQLite
engine = create_engine('sqlite:///example.db', echo=True)
Base = declarative_base()

# Définir un modèle
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    age = Column(Integer)

# Créer les tables
Base.metadata.create_all(engine)

# Créer une session
Session = sessionmaker(bind=engine)
session = Session()
```

**Insertion et requêtes :**

```python
# Ajouter un utilisateur
new_user = User(name="Alice", age=25)
session.add(new_user)
session.commit()

# Requêter des utilisateurs
users = session.query(User).filter_by(age=25).all()
for user in users:
    print(user.name)
```

#### **b. Peewee**

**Installation :**

```bash
pip install peewee
```

**Exemple avec Peewee :**

```python
from peewee import SqliteDatabase, Model, CharField, IntegerField

# Connexion à SQLite
db = SqliteDatabase('example.db')

# Définir un modèle
class User(Model):
    name = CharField()
    age = IntegerField()

    class Meta:
        database = db

# Créer la table
db.connect()
db.create_tables([User])

# Ajouter un utilisateur
user = User.create(name="Alice", age=25)

# Requêtes
for user in User.select().where(User.age > 20):
    print(user.name)
```

---

### **Comparaison des Approches**

| **Critère**            | **MongoDB avec PyMongo**    | **Redis avec redis-py**       | **ORM (SQLAlchemy / Peewee)** |
|-------------------------|-----------------------------|--------------------------------|--------------------------------|
| **Type de base**        | NoSQL (documents)          | NoSQL (clé-valeur en mémoire) | SQL (relationnel)             |
| **Cas d'utilisation**   | Données flexibles, volumineuses | Cache rapide, sessions       | Données structurées           |
| **Langage de requête**  | Requêtes JSON              | Commandes simples             | Abstraction Pythonique        |
| **Scalabilité**         | Haute                     | Très haute (en mémoire)       | Variable (dépend du SQL)      |

---

### **Résumé**

- **MongoDB (PyMongo)** : Idéal pour des données semi-structurées et des schémas dynamiques.
- **Redis (redis-py)** : Parfait pour la mise en cache, le stockage temporaire, ou les systèmes de messagerie rapide.
- **ORM (SQLAlchemy, Peewee)** : Simplifie l'interaction avec des bases relationnelles tout en restant robuste pour les projets nécessitant des structures fixes.

Ces outils peuvent être combinés dans une application : par exemple, Redis pour le cache, MongoDB pour stocker des données non relationnelles, et SQLAlchemy pour les relations complexes.

### Chapitre 27 **Automatisation et DevOps avec Python**

L'automatisation et les pratiques DevOps permettent de simplifier les déploiements, de gérer les infrastructures de manière efficace, et de maintenir la cohérence des environnements. Python est un langage clé dans cet écosystème grâce à sa polyvalence et ses bibliothèques.

---

### **1. Automatisation de Déploiements avec Ansible**

Ansible est un outil open-source d'automatisation qui facilite la gestion des configurations, le déploiement des applications et l'orchestration des tâches. Python est à la base de son fonctionnement.

#### **a. Installation et configuration d'Ansible**

1. Installez Ansible :

   ```bash
   pip install ansible
   ```
2. Configurez un inventaire pour définir les serveurs cibles dans un fichier `inventory.ini` :
   ```ini
   [webservers]
   server1 ansible_host=192.168.1.10 ansible_user=ubuntu ansible_ssh_private_key_file=~/.ssh/id_rsa
   ```

#### **b. Création d'un playbook**

Un playbook Ansible est un fichier YAML décrivant les tâches à exécuter.

Exemple : Installation d'un serveur Nginx

```yaml
- name: Installer et configurer Nginx
  hosts: webservers
  become: yes
  tasks:
    - name: Mettre à jour les paquets
      apt:
        update_cache: yes

    - name: Installer Nginx
      apt:
        name: nginx
        state: present

    - name: Activer et démarrer Nginx
      service:
        name: nginx
        state: started
        enabled: yes
```

**Exécution du playbook :**

```bash
ansible-playbook -i inventory.ini playbook.yml
```

#### **c. Avantages**
- **Idempotence** : Les tâches sont répétables et ne causent pas de doublons.
- **Simplicité** : Syntaxe lisible et facile à comprendre.
- **Extensibilité** : Compatible avec des modules Python personnalisés.

---

### **2. Conteneurisation avec Docker**

Docker est un outil essentiel pour packager les applications avec toutes leurs dépendances, garantissant qu'elles s'exécutent de manière cohérente sur tous les environnements.

#### **a. Installation et configuration de Docker**
1. Installez Docker : [Documentation officielle](https://docs.docker.com/get-docker/).
2. Vérifiez l'installation :
   ```bash
   docker --version
   ```

#### **b. Création d'un Dockerfile**
Un `Dockerfile` décrit comment construire une image Docker pour votre application.

Exemple : Application Flask

```dockerfile
# Utiliser une image Python comme base
FROM python:3.10-slim

# Définir le répertoire de travail
WORKDIR /app

# Copier les fichiers nécessaires
COPY requirements.txt requirements.txt
COPY app.py app.py

# Installer les dépendances
RUN pip install --no-cache-dir -r requirements.txt

# Exposer le port 5000
EXPOSE 5000

# Commande pour lancer l'application
CMD ["python", "app.py"]
```

**Build et exécution :**
```bash
# Construire l'image Docker
docker build -t my-flask-app .

# Exécuter un conteneur
docker run -p 5000:5000 my-flask-app
```

#### **c. Gestion des conteneurs**

Quelques commandes Docker utiles :

- **Lister les conteneurs :**

  ```bash
  docker ps -a
  ```

- **Arrêter un conteneur :**

  ```bash
  docker stop <container_id>
  ```

- **Supprimer un conteneur :**

  ```bash
  docker rm <container_id>
  ```

#### **d. Utilisation avancée avec Docker Compose**
Docker Compose permet de définir et gérer plusieurs conteneurs dans un fichier `docker-compose.yml`.

Exemple : Application Flask avec une base de données PostgreSQL

```yaml
version: '3.8'
services:
  web:
    build: .
    ports:
      - "5000:5000"
    depends_on:
      - db
  db:
    image: postgres:latest
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: flaskdb
```

**Lancer l'ensemble :**

```bash
docker-compose up
```

---

### **Comparaison entre Ansible et Docker**

| **Critère**              | **Ansible**                             | **Docker**                              |
|--------------------------|------------------------------------------|-----------------------------------------|
| **Objectif principal**   | Automatisation des configurations        | Conteneurisation des applications       |
| **Étendue**              | Gère les serveurs et les applications    | Isoler les applications et leurs dépendances |
| **Persistant**           | Oui (applique des changements permanents) | Non (conteneurs éphémères par défaut)   |
| **Facilité de configuration** | Requiert un inventaire et des playbooks | Requiert un Dockerfile                  |

---

### **Applications pratiques**

- **Ansible** : Installer automatiquement des outils de monitoring (Prometheus, Grafana) sur un cluster de serveurs.
- **Docker** : Déployer une application web en environnement isolé avec ses services associés.

---

### **Résumé**

- **Ansible** est idéal pour automatiser les déploiements, gérer les configurations, et maintenir des infrastructures cohérentes.
- **Docker** simplifie la conteneurisation des applications, en garantissant leur portabilité entre différents environnements.

### Chapitre 28 **Introduction aux Expressions Régulières avec le Module `re`**

Les expressions régulières (regex) sont des outils puissants pour rechercher, valider ou manipuler des chaînes de caractères en Python. Le module `re` de la bibliothèque standard fournit les fonctions nécessaires pour travailler avec ces patterns.

---

### **1. Concepts de base**

- **Expression régulière** : Une séquence de caractères décrivant un modèle (pattern) de recherche.
- **Utilisation courante** : 
  - Recherche de sous-chaînes.
  - Validation de formats (e-mails, numéros de téléphone, etc.).
  - Remplacement ou modification de contenu.

---

### **2. Fonctions principales du module `re`**

#### **a. Recherche avec `re.search`**

Recherche le premier endroit où le pattern correspond dans une chaîne.

```python
import re

texte = "Mon numéro est 123-456-7890."
match = re.search(r"\d{3}-\d{3}-\d{4}", texte)
if match:
    print(f"Numéro trouvé : {match.group()}")
```

#### **b. Validation avec `re.match`**

Vérifie si une chaîne entière correspond à un pattern.

```python
pattern = r"^\d{3}-\d{3}-\d{4}$"
chaine = "123-456-7890"
if re.match(pattern, chaine):
    print("Format valide")
else:
    print("Format invalide")
```

#### **c. Recherche multiple avec `re.findall`**

Renvoie toutes les correspondances sous forme de liste.

```python
texte = "Voici deux numéros : 123-456-7890 et 987-654-3210."
matches = re.findall(r"\d{3}-\d{3}-\d{4}", texte)
print("Numéros trouvés :", matches)
```

#### **d. Substitution avec `re.sub`**

Remplace toutes les correspondances d'un pattern par une autre chaîne.

```python
texte = "Mon numéro est 123-456-7890."
texte_modifie = re.sub(r"\d{3}-\d{3}-\d{4}", "XXX-XXX-XXXX", texte)
print(texte_modifie)
```

---

### **3. Cas pratiques**

#### **a. Validation d'adresses e-mail**

```python
email = "exemple@test.com"
pattern = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"
if re.match(pattern, email):
    print("Adresse e-mail valide")
else:
    print("Adresse e-mail invalide")
```

#### **b. Extraction d'informations (dates)**

```python
texte = "Les événements ont lieu le 10/01/2025 et le 15/02/2025."
dates = re.findall(r"\d{2}/\d{2}/\d{4}", texte)
print("Dates extraites :", dates)
```

#### **c. Transformation de texte (formatage de numéros de téléphone)**

```python
texte = "1234567890 et 9876543210 sont mes numéros."
formatted = re.sub(r"(\d{3})(\d{3})(\d{4})", r"\1-\2-\3", texte)
print("Numéros formatés :", formatted)
```

---

### **4. Options et Modificateurs**

- **`re.IGNORECASE` (`re.I`)** : Ignore la casse lors de la recherche.
- **`re.MULTILINE` (`re.M`)** : Permet de rechercher sur plusieurs lignes.
- **`re.DOTALL` (`re.S`)** : Permet au point (`.`) de correspondre aux sauts de ligne.
  
Exemple :
```python
texte = "Bonjour\nMONDE"
match = re.search(r"monde", texte, re.IGNORECASE)
if match:
    print("Correspondance trouvée :", match.group())
```

---

### **5. Structure des Patterns**

| **Pattern**       | **Description**                          |
|--------------------|------------------------------------------|
| `.`               | N'importe quel caractère sauf un saut de ligne. |
| `\d`              | Un chiffre (`0-9`).                     |
| `\w`              | Un caractère alphanumérique ou `_`.      |
| `\s`              | Un espace, tabulation ou saut de ligne.  |
| `*`               | Répète 0 ou plusieurs fois.             |
| `+`               | Répète 1 ou plusieurs fois.             |
| `{n}`             | Exactement `n` occurrences.             |
| `[abc]`           | Un des caractères dans `abc`.           |
| `[^abc]`          | Aucun des caractères dans `abc`.        |

---

### **6. Optimisation et Bonnes Pratiques**

- **Compilations préalables avec `re.compile`** :
  Permet de réutiliser un pattern compilé pour optimiser les performances.
  ```python
  pattern = re.compile(r"\d{3}-\d{3}-\d{4}")
  print(pattern.search("Numéro : 123-456-7890"))
  ```

- **Tester vos regex** :
  Utilisez des outils comme [regex101](https://regex101.com) pour tester vos patterns.

- **Éviter les patterns trop complexes** :
  Décomposez les regex compliquées pour les rendre plus lisibles.

---

### **Résumé**

Les expressions régulières sont indispensables pour traiter et analyser les chaînes de caractères en Python. Grâce au module `re`, vous pouvez rechercher, valider, et transformer facilement du texte. Toutefois, leur puissance nécessite de bien comprendre les patterns et d'utiliser des pratiques optimisées.

### Chapitre 29 **Gestion des Fichiers Avancée avec les Modules `os` et `shutil`**

La gestion avancée des fichiers en Python repose sur les modules `os` et `shutil`, qui offrent une multitude de fonctionnalités pour manipuler, copier, déplacer, et gérer les fichiers et répertoires.

---

### **1. Module `os` : Manipulation de Chemins et Fichiers**

#### **a. Gestion des chemins**
Le module `os` fournit des fonctions pour manipuler les chemins de fichiers, détecter leur existence, ou créer des répertoires.

- **Vérification de l'existence d'un fichier ou dossier** :

  ```python
  import os

  chemin = "mon_fichier.txt"
  if os.path.exists(chemin):
      print("Le fichier existe.")
  else:
      print("Le fichier n'existe pas.")
  ```

- **Joindre des chemins de manière portable** :

  ```python
  chemin_complet = os.path.join("dossier", "sous_dossier", "fichier.txt")
  print(chemin_complet)
  ```

- **Récupérer le nom du fichier ou du répertoire parent** :

  ```python
  chemin = "/chemin/vers/fichier.txt"
  print("Nom du fichier :", os.path.basename(chemin))
  print("Répertoire parent :", os.path.dirname(chemin))
  ```

#### **b. Création et suppression**

- **Créer un répertoire** :

  ```python
  os.makedirs("nouveau_dossier/sous_dossier", exist_ok=True)
  print("Dossier créé.")
  ```

- **Supprimer un fichier ou répertoire vide** :

  ```python
  os.remove("fichier_a_supprimer.txt")  # Supprime un fichier
  os.rmdir("dossier_vide")             # Supprime un répertoire vide
  ```

---

### **2. Module `shutil` : Opérations Avancées sur les Fichiers**

Le module `shutil` est idéal pour des opérations complexes comme la copie, le déplacement ou la compression de fichiers.

#### **a. Copier des fichiers**

- **Copier un fichier** :

  ```python
  import shutil

  shutil.copy("source.txt", "destination.txt")
  print("Fichier copié.")
  ```

- **Copier un fichier avec ses métadonnées** :

  ```python
  shutil.copy2("source.txt", "destination.txt")
  ```

#### **b. Déplacement et renommage**

- **Déplacer un fichier ou un dossier** :

  ```python
  shutil.move("source.txt", "nouveau_dossier/")
  ```

#### **c. Suppression de dossiers entiers**

- **Supprimer un répertoire et tout son contenu** :

  ```python
  shutil.rmtree("dossier_a_supprimer")
  print("Dossier supprimé.")
  ```

#### **d. Création d'archives**

- **Créer une archive ZIP ou TAR** :

  ```python
  shutil.make_archive("mon_archive", "zip", "dossier_a_compresser")
  print("Archive créée.")
  ```

---

### **3. Cas Pratiques**

#### **a. Liste des fichiers dans un répertoire**

```python
chemin = "mon_dossier"
fichiers = os.listdir(chemin)
print("Fichiers et dossiers :", fichiers)
```

#### **b. Rechercher des fichiers avec une extension spécifique**

```python
chemin = "mon_dossier"
for fichier in os.listdir(chemin):
    if fichier.endswith(".txt"):
        print("Fichier texte trouvé :", fichier)
```

#### **c. Vérifier la taille d'un fichier**

```python
chemin = "mon_fichier.txt"
taille = os.path.getsize(chemin)
print(f"Taille du fichier : {taille} octets")
```

---

### **4. Bonnes Pratiques**

- **Vérification préalable** :
  Toujours vérifier l'existence d'un fichier ou répertoire avant d'y accéder ou de le supprimer.
  
- **Utilisation de chemins absolus ou relatifs portables** :
  Utilisez `os.path.join` pour garantir la compatibilité multiplateforme.

- **Gestion des exceptions** :

  Manipuler les fichiers peut entraîner des erreurs (fichiers non trouvés, permissions insuffisantes). Utilisez `try/except` pour une gestion sécurisée.

  ```python
  try:
      os.remove("fichier_inexistant.txt")
  except FileNotFoundError:
      print("Fichier introuvable.")
  ```

- **Nettoyage des ressources** :
  Pour garantir une bonne gestion des ressources, utilisez des contextes (`with`) lorsque vous ouvrez ou manipulez des fichiers.

---

### **Résumé**

- Le module `os` gère principalement les chemins, la création/suppression de fichiers et dossiers.
- Le module `shutil` offre des fonctionnalités avancées comme la copie, le déplacement, et la compression.
- Ces outils combinés permettent une gestion fine et puissante des fichiers dans des projets Python.

### Chapitre 30 **Concepts de Classe Avancée en Python**

La programmation orientée objet (POO) en Python permet de structurer et de gérer des programmes complexes en utilisant des classes et des objets. Les concepts avancés incluent l'utilisation de méthodes spéciales, l'héritage approfondi et d'autres mécanismes qui enrichissent les fonctionnalités des classes.

---

### **1. Méthodes Spéciales**
Les méthodes spéciales, ou "méthodes magiques", permettent de personnaliser le comportement des objets dans certains contextes spécifiques. Elles sont reconnaissables par leur double underscore (`__`).

#### **a. `__str__` et `__repr__` : Représentation des objets**
- **`__str__`** : Retourne une représentation lisible pour les utilisateurs (souvent utilisée dans `print`).
- **`__repr__`** : Retourne une représentation officielle destinée aux développeurs (idéalement exécutable).

```python
class Personne:
    def __init__(self, nom, age):
        self.nom = nom
        self.age = age

    def __str__(self):
        return f"{self.nom}, {self.age} ans"

    def __repr__(self):
        return f"Personne(nom='{self.nom}', age={self.age})"

personne = Personne("Alice", 30)
print(str(personne))   # Alice, 30 ans
print(repr(personne))  # Personne(nom='Alice', age=30)
```

---

#### **b. `__eq__` : Comparaison d'objets**
Permet de définir le comportement de l'opérateur `==`.

```python
class Personne:
    def __init__(self, nom, age):
        self.nom = nom
        self.age = age

    def __eq__(self, autre):
        return self.nom == autre.nom and self.age == autre.age

personne1 = Personne("Alice", 30)
personne2 = Personne("Alice", 30)
print(personne1 == personne2)  # True
```

---

#### **c. Autres méthodes utiles**
- **`__lt__`, `__le__`, `__gt__`, `__ge__`** : Comparaisons `<`, `<=`, `>`, `>=`.
- **`__add__`, `__sub__`, `__mul__`, etc.** : Surcharge des opérateurs arithmétiques.
- **`__len__`** : Définir le comportement de `len()` pour un objet.
- **`__call__`** : Rendre un objet "appelable" comme une fonction.

```python
class Addition:
    def __init__(self, valeur):
        self.valeur = valeur

    def __call__(self, autre):
        return self.valeur + autre

add = Addition(5)
print(add(10))  # 15
```

---

### **2. Héritage Avancé**
L'héritage permet à une classe d'hériter des attributs et des méthodes d'une autre classe.

#### **a. Héritage simple**
Une classe dérive d'une seule classe parente.

```python
class Animal:
    def parler(self):
        print("L'animal fait un bruit.")

class Chien(Animal):
    def parler(self):
        print("Le chien aboie.")

chien = Chien()
chien.parler()  # Le chien aboie.
```

---

#### **b. Héritage multiple**
Une classe peut hériter de plusieurs classes parentes. Cela nécessite de gérer les conflits éventuels via l'ordre de résolution des méthodes (MRO, Method Resolution Order).

```python
class A:
    def dire(self):
        print("Classe A")

class B:
    def dire(self):
        print("Classe B")

class C(A, B):
    pass

c = C()
c.dire()  # Classe A (ordre de MRO : C -> A -> B)
```

Pour voir l'ordre de résolution des méthodes :
```python
print(C.mro())  # [<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]
```

---

### **3. Concepts Avancés**
#### **a. Héritage avec super()**
La fonction `super()` permet d'accéder aux méthodes ou attributs des classes parentes, même dans le cas d'un héritage multiple.

```python
class Parent:
    def __init__(self, nom):
        self.nom = nom

class Enfant(Parent):
    def __init__(self, nom, age):
        super().__init__(nom)
        self.age = age

enfant = Enfant("Alice", 10)
print(enfant.nom, enfant.age)  # Alice 10
```

---

#### **b. Classes abstraites**
Les classes abstraites servent de modèles et ne peuvent pas être instanciées. Elles utilisent le module `abc`.

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def parler(self):
        pass

class Chat(Animal):
    def parler(self):
        print("Le chat miaule.")

chat = Chat()
chat.parler()  # Le chat miaule.
```

---

### **4. Cas Pratique : Polymorphisme**
Le polymorphisme permet d'utiliser un même nom de méthode pour différents comportements.

```python
class Chien:
    def parler(self):
        print("Le chien aboie.")

class Chat:
    def parler(self):
        print("Le chat miaule.")

animaux = [Chien(), Chat()]
for animal in animaux:
    animal.parler()
# Le chien aboie.
# Le chat miaule.
```

---

### **Résumé**
- Les **méthodes spéciales** enrichissent le comportement des objets.
- L'**héritage simple** est utile pour organiser le code, et l'**héritage multiple** doit être utilisé avec précaution.
- Le **polymorphisme** et les **classes abstraites** facilitent l'évolutivité et la flexibilité du code.

### Chapitre 31 **Threading de Base en Python**

Le **multithreading** permet d'exécuter plusieurs tâches simultanément au sein d'un programme. Il est particulièrement utile pour les tâches d'I/O (lecture/écriture de fichiers, requêtes réseau) où les threads peuvent s'exécuter en parallèle pour améliorer les performances. Python fournit le module **`threading`** pour gérer les threads.

---

### **1. Concepts de Base**
Un **thread** est une unité d'exécution indépendante qui partage les ressources (comme la mémoire) avec les autres threads du même processus.

#### **Avantages :**
- Permet des exécutions simultanées.
- Idéal pour les tâches d'I/O.

#### **Limites :**
- En Python, le **GIL (Global Interpreter Lock)** limite l'exécution simultanée de threads pour le code Python pur. Cela impacte les tâches intensives en calcul.

---

### **2. Création d'un Thread**
#### **Méthode 1 : Utilisation de `threading.Thread`**
Créer un thread en définissant une fonction à exécuter.

```python
import threading
import time

def dire_bonjour():
    for i in range(5):
        print("Bonjour!")
        time.sleep(1)

# Créer un thread
thread = threading.Thread(target=dire_bonjour)

# Démarrer le thread
thread.start()

# Continuer l'exécution principale
print("Tâche principale continue.")
```

---

#### **Méthode 2 : Hériter de `threading.Thread`**
Créer une classe personnalisée pour plus de contrôle.

```python
class MonThread(threading.Thread):
    def __init__(self, nom):
        super().__init__()
        self.nom = nom

    def run(self):
        for i in range(5):
            print(f"Thread {self.nom} en cours d'exécution.")
            time.sleep(1)

# Créer et démarrer un thread
mon_thread = MonThread("A")
mon_thread.start()
```

---

### **3. Cas d'Utilisation Pratique**
#### **Exemple : Téléchargement de fichiers en parallèle**
Imaginons une tâche où plusieurs fichiers doivent être téléchargés simultanément.

```python
import threading
import time

def telecharger_fichier(nom_fichier, duree):
    print(f"Téléchargement de {nom_fichier} commencé.")
    time.sleep(duree)
    print(f"Téléchargement de {nom_fichier} terminé.")

fichiers = [("Fichier1", 3), ("Fichier2", 5), ("Fichier3", 2)]

threads = []
for nom, duree in fichiers:
    thread = threading.Thread(target=telecharger_fichier, args=(nom, duree))
    threads.append(thread)
    thread.start()

# Attendre la fin de tous les threads
for thread in threads:
    thread.join()

print("Tous les téléchargements sont terminés.")
```

---

### **4. Synchronisation avec `Lock`**
Lorsque plusieurs threads accèdent aux mêmes ressources, des **verrous (`Lock`)** permettent d'éviter des conflits.

#### **Exemple : Incrémentation sécurisée**
Sans verrou, plusieurs threads pourraient modifier la même variable simultanément, entraînant des résultats imprévisibles.

```python
import threading

compteur = 0
lock = threading.Lock()

def incrementer():
    global compteur
    for _ in range(1000):
        with lock:  # Section critique
            compteur += 1

threads = [threading.Thread(target=incrementer) for _ in range(10)]

for thread in threads:
    thread.start()

for thread in threads:
    thread.join()

print(f"Valeur finale du compteur : {compteur}")
```

---

### **5. Limitations du GIL**
Pour des tâches intensives en calcul (comme le traitement de données), le GIL empêche l'exécution parallèle des threads Python. Dans ce cas, **`multiprocessing`** ou des bibliothèques comme **Numba** ou **Cython** sont préférables.

---

### **Résumé**
- **`threading.Thread`** permet de créer des threads pour exécuter des tâches simultanées.
- Utilisez **`Lock`** pour synchroniser les accès à des ressources partagées.
- Le threading est particulièrement utile pour les tâches I/O, mais pour les tâches intensives en calcul, privilégiez le **multiprocessing**.

### Chapitre 32 **Fonctions Anonymes et Programmation Fonctionnelle de Base en Python**

Python propose des outils puissants pour la **programmation fonctionnelle**, un paradigme qui se concentre sur l’utilisation de fonctions comme blocs de construction du programme. Les fonctions **anonymes (`lambda`)** et des outils comme **`map()`**, **`filter()`**, et **`reduce()`** permettent de manipuler efficacement des données sans écrire de boucles explicites.

---

### **1. Fonctions Anonymes (`lambda`)**
Une **fonction lambda** est une fonction anonyme définie en une seule ligne. Elle est souvent utilisée pour des fonctions simples ou temporaires.

#### **Syntaxe :**

```python
lambda arguments: expression
```

#### **Exemple :**

Additionner deux nombres :

```python
addition = lambda x, y: x + y
print(addition(3, 5))  # Sortie : 8
```

#### **Cas d'utilisation :**
Les fonctions lambda sont souvent utilisées avec d'autres fonctions comme `map()`, `filter()`, ou des fonctions de tri.

---

### **2. La fonction `map()`**
**`map()`** applique une fonction donnée à chaque élément d'une séquence (liste, tuple, etc.) et retourne un **itérable**.

#### **Syntaxe :**

```python
map(function, iterable)
```

#### **Exemple : Conversion de températures Celsius en Fahrenheit**

```python
celsius = [0, 20, 30, 40]
fahrenheit = list(map(lambda x: (x * 9/5) + 32, celsius))
print(fahrenheit)  # Sortie : [32.0, 68.0, 86.0, 104.0]
```

---

### **3. La fonction `filter()`**
**`filter()`** retourne les éléments d'un itérable qui satisfont une condition (fonction renvoyant `True`).

#### **Syntaxe :**

```python
filter(function, iterable)
```

#### **Exemple : Filtrer les nombres pairs**

```python
nombres = [1, 2, 3, 4, 5, 6]
pairs = list(filter(lambda x: x % 2 == 0, nombres))
print(pairs)  # Sortie : [2, 4, 6]
```

---

### **4. La fonction `reduce()`**
**`reduce()`** (dans le module `functools`) applique une fonction cumulativement à une séquence pour réduire cette dernière à une seule valeur.

#### **Syntaxe :**

```python
from functools import reduce
reduce(function, iterable)
```

#### **Exemple : Calcul du produit de tous les nombres**

```python
from functools import reduce

nombres = [1, 2, 3, 4]
produit = reduce(lambda x, y: x * y, nombres)
print(produit)  # Sortie : 24
```

---

### **5. Cas Pratiques**

#### **Exemple 1 : Trier une liste de dictionnaires par une clé**

Trier des étudiants par leurs notes :

```python
etudiants = [{'nom': 'Alice', 'note': 85}, {'nom': 'Bob', 'note': 92}, {'nom': 'Charlie', 'note': 78}]
tri = sorted(etudiants, key=lambda x: x['note'], reverse=True)
print(tri)
# Sortie : [{'nom': 'Bob', 'note': 92}, {'nom': 'Alice', 'note': 85}, {'nom': 'Charlie', 'note': 78}]
```

#### **Exemple 2 : Calculer la somme des carrés des nombres pairs**

```python
nombres = [1, 2, 3, 4, 5, 6]
somme_carre_pairs = reduce(lambda x, y: x + y, map(lambda x: x**2, filter(lambda x: x % 2 == 0, nombres)))
print(somme_carre_pairs)  # Sortie : 56 (2² + 4² + 6²)
```

#### **Exemple 3 : Trouver le mot le plus long dans une liste**

```python
mots = ["chat", "éléphant", "chien", "oiseau"]
mot_plus_long = reduce(lambda x, y: x if len(x) > len(y) else y, mots)
print(mot_plus_long)  # Sortie : "éléphant"
```

---

### **6. Comparaison avec des Boucles**

Les fonctions comme `map()` et `filter()` rendent le code plus concis et lisible, mais elles ne remplacent pas toujours les boucles, surtout pour des logiques complexes. Comparez :

#### **Avec `map()` :**

```python
nombres = [1, 2, 3, 4]
carres = list(map(lambda x: x**2, nombres))
print(carres)  # Sortie : [1, 4, 9, 16]
```

#### **Avec une boucle :**

```python
nombres = [1, 2, 3, 4]
carres = [x**2 for x in nombres]
print(carres)  # Sortie : [1, 4, 9, 16]
```

---

### **Résumé**
- Les **fonctions anonymes (`lambda`)** sont pratiques pour des opérations simples et temporaires.
- **`map()`** et **`filter()`** offrent une manière concise de transformer ou filtrer des itérables.
- **`reduce()`** est utile pour combiner tous les éléments d'une séquence en une seule valeur.
- Ces outils conviennent particulièrement aux tâches fonctionnelles et aux pipelines de traitement de données.

### Chapitre 33 **Itérateurs et Générateurs en Python**

Les **itérateurs** et **générateurs** permettent de manipuler des séquences de données efficacement. Ils sont particulièrement utiles pour gérer de grandes quantités de données ou pour créer des flux de données en temps réel, tout en réduisant l'utilisation de la mémoire.

---

### **1. Itérateurs**

Un **itérateur** est un objet qui implémente les méthodes spéciales **`__iter__()`** et **`__next__()`**, permettant de parcourir une séquence un élément à la fois.

#### **Création d'un itérateur personnalisé**

Voici un exemple simple pour créer un itérateur qui génère les nombres d'une séquence jusqu'à une limite donnée.

```python
class Compteur:
    def __init__(self, limite):
        self.limite = limite
        self.courant = 0

    def __iter__(self):
        return self  # Un itérateur doit retourner lui-même.

    def __next__(self):
        if self.courant < self.limite:
            valeur = self.courant
            self.courant += 1
            return valeur
        else:
            raise StopIteration  # Indique que l'itération est terminée.

# Utilisation
compteur = Compteur(5)
for nombre in compteur:
    print(nombre)  # Sortie : 0, 1, 2, 3, 4
```

---

### **2. Générateurs**

Un **générateur** est une fonction spéciale qui produit un itérateur sans avoir besoin d'implémenter manuellement les méthodes `__iter__()` et `__next__()`. Au lieu d'utiliser `return`, un générateur utilise **`yield`**, ce qui permet de suspendre et reprendre son exécution.

#### **Création d'un générateur**

Un générateur pour produire une séquence de Fibonacci :

```python
def fibonacci(limite):
    a, b = 0, 1
    while a < limite:
        yield a  # Génère la valeur actuelle et suspend l'exécution.
        a, b = b, a + b

# Utilisation
for nombre in fibonacci(10):
    print(nombre)  # Sortie : 0, 1, 1, 2, 3, 5, 8
```

---

### **3. Différences entre itérateurs et générateurs**

| **Aspect**         | **Itérateur**                                                  | **Générateur**                     |
|---------------------|---------------------------------------------------------------|-------------------------------------|
| **Création**        | Implémentation manuelle avec `__iter__()` et `__next__()`.     | Utilisation d'une fonction avec `yield`. |
| **Mémoire**         | Les données peuvent être stockées en mémoire.                 | Génère les valeurs à la demande (lazy evaluation). |
| **Complexité**      | Peut être plus complexe à implémenter.                        | Plus simple et concis.              |

---

### **4. Générateurs vs Listes**

Un générateur **ne stocke pas tous les éléments en mémoire**, contrairement à une liste. Cela permet de gérer des flux de données infinis ou de très grandes séquences.

#### **Exemple : Liste vs Générateur**

Avec une liste :

```python
nombres = [x**2 for x in range(10)]
print(nombres)  # Sortie : [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

Avec un générateur :

```python
nombres = (x**2 for x in range(10))
print(list(nombres))  # Sortie : [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

Le générateur ne calcule les valeurs qu'au moment où elles sont demandées.

---

### **5. Utilisation Avancée : Générateurs Infinis**

Un générateur infini qui génère des nombres pairs :

```python
def nombres_pairs():
    n = 0
    while True:
        yield n
        n += 2

# Utilisation
pairs = nombres_pairs()
for _ in range(5):
    print(next(pairs))  # Sortie : 0, 2, 4, 6, 8
```

---

### **6. Cas Pratiques**

#### **Exemple 1 : Lecture de fichiers ligne par ligne**

Les générateurs sont très utiles pour traiter de grands fichiers sans les charger entièrement en mémoire.

```python
def lire_fichier_en_lignes(nom_fichier):
    with open(nom_fichier, 'r') as fichier:
        for ligne in fichier:
            yield ligne.strip()

# Utilisation
for ligne in lire_fichier_en_lignes("example.txt"):
    print(ligne)
```

#### **Exemple 2 : Pipeline de traitement de données**
				
Créer des générateurs pour chaque étape d'un pipeline de traitement.

```python
def charger_donnees():
    for i in range(10):
        yield i

def transformer_donnees(donnees):
    for valeur in donnees:
        yield valeur**2

def filtrer_donnees(donnees):
    for valeur in donnees:
        if valeur % 2 == 0:
            yield valeur

# Chaînage des générateurs
pipeline = filtrer_donnees(transformer_donnees(charger_donnees()))
print(list(pipeline))  # Sortie : [0, 4, 16, 36, 64]
```

---

### **Résumé**
- Les **itérateurs** offrent un contrôle manuel sur l'itération.
- Les **générateurs**, grâce à `yield`, fournissent une alternative simple pour créer des séquences paresseuses.
- Ces outils sont essentiels pour **gérer efficacement la mémoire** et **traiter des flux de données** en temps réel.

### Chapitre 34 **Manipulation des fichiers avancée en Python**

La manipulation avancée des fichiers implique le travail avec différents formats de données courants (CSV, JSON, etc.) et des opérations sur le système de fichiers (par exemple, gestion des répertoires, copie de fichiers). Python offre des modules puissants comme **os**, **shutil**, **csv**, et **json** pour accomplir ces tâches.

---

### **1. Travail avec des fichiers CSV**

Le module **`csv`** facilite la lecture et l'écriture de fichiers au format CSV (Comma-Separated Values).

#### **Lecture d'un fichier CSV**

```python
import csv

# Lecture d'un fichier CSV
with open('exemple.csv', mode='r') as fichier:
    lecteur_csv = csv.reader(fichier)
    for ligne in lecteur_csv:
        print(ligne)
```

#### **Écriture dans un fichier CSV**

```python
# Écriture dans un fichier CSV
with open('sortie.csv', mode='w', newline='') as fichier:
    ecrivain_csv = csv.writer(fichier)
    ecrivain_csv.writerow(['Nom', 'Âge', 'Ville'])
    ecrivain_csv.writerow(['Alice', 30, 'Paris'])
    ecrivain_csv.writerow(['Bob', 25, 'Lyon'])
```

#### **Utilisation de `DictReader` et `DictWriter`**

```python
# Lecture avec DictReader
with open('exemple.csv', mode='r') as fichier:
    lecteur_csv = csv.DictReader(fichier)
    for ligne in lecteur_csv:
        print(ligne)

# Écriture avec DictWriter
with open('sortie.csv', mode='w', newline='') as fichier:
    colonnes = ['Nom', 'Âge', 'Ville']
    ecrivain_csv = csv.DictWriter(fichier, fieldnames=colonnes)
    ecrivain_csv.writeheader()
    ecrivain_csv.writerow({'Nom': 'Alice', 'Âge': 30, 'Ville': 'Paris'})
    ecrivain_csv.writerow({'Nom': 'Bob', 'Âge': 25, 'Ville': 'Lyon'})
```

---

### **2. Travail avec des fichiers JSON**

Le module **`json`** permet de travailler avec des données au format JSON (JavaScript Object Notation).

#### **Lecture d'un fichier JSON**

```python
import json

# Lecture d'un fichier JSON
with open('exemple.json', mode='r') as fichier:
    donnees = json.load(fichier)
    print(donnees)
```

#### **Écriture dans un fichier JSON**

```python
# Écriture dans un fichier JSON
donnees = {
    "Nom": "Alice",
    "Âge": 30,
    "Ville": "Paris"
}

with open('sortie.json', mode='w') as fichier:
    json.dump(donnees, fichier, indent=4)  # `indent=4` pour une écriture lisible
```

---

### **3. Utilisation des modules `os` et `shutil`**

Ces modules permettent de manipuler le système de fichiers : création de répertoires, copie, déplacement, suppression de fichiers, etc.

#### **Module `os`**

- **Liste des fichiers dans un répertoire**
```python
import os

# Liste des fichiers
repertoire = './'
fichiers = os.listdir(repertoire)
print(fichiers)
```

- **Création et suppression de répertoires**

```python
# Création
os.mkdir('nouveau_dossier')

# Suppression
os.rmdir('nouveau_dossier')
```

- **Manipulation des chemins**

```python
chemin = os.path.join('dossier', 'fichier.txt')
print(chemin)  # Sortie : 'dossier/fichier.txt' (ou adapté selon l'OS)

# Vérification si un fichier ou un répertoire existe
print(os.path.exists(chemin))
```

#### **Module `shutil`**

- **Copie et déplacement de fichiers**

```python
import shutil

# Copie de fichier
shutil.copy('source.txt', 'destination.txt')

# Déplacement de fichier
shutil.move('fichier.txt', 'nouveau_repertoire/')
```

- **Suppression de fichiers ou répertoires**

```python
# Suppression d'un fichier
os.remove('fichier.txt')

# Suppression d'un répertoire non vide
shutil.rmtree('dossier_non_vide')
```

---

### **4. Travail avec d'autres formats de fichiers**

#### **Manipulation de fichiers texte**

```python
# Lecture
with open('exemple.txt', mode='r') as fichier:
    contenu = fichier.read()
    print(contenu)

# Écriture
with open('exemple.txt', mode='w') as fichier:
    fichier.write('Bonjour, monde!')
```

#### **Manipulation de fichiers XML**

Pour les fichiers XML, utilisez le module **`xml.etree.ElementTree`**.

```python
import xml.etree.ElementTree as ET

# Lecture d'un fichier XML
arbre = ET.parse('exemple.xml')
racine = arbre.getroot()
print(racine.tag)

# Écriture d'un fichier XML
nouvel_element = ET.Element('note')
nouvel_element.text = 'Ceci est un test'
ET.ElementTree(nouvel_element).write('nouveau.xml')
```

---

### **5. Conseils pratiques**
1. Toujours utiliser `with` pour ouvrir des fichiers afin de s'assurer qu'ils sont correctement fermés.
2. Vérifier l'existence des fichiers avant d'y accéder pour éviter des erreurs (`os.path.exists`).
3. Utiliser des modules spécifiques comme **`pandas`** pour des manipulations complexes de données CSV ou JSON.

---

### **Résumé**
- Le module **`csv`** facilite le travail avec des fichiers tabulaires.
- Le module **`json`** permet de manipuler des structures complexes de données au format JSON.
- Les modules **`os`** et **`shutil`** permettent une gestion avancée des fichiers et répertoires.
- Python prend en charge de nombreux formats courants et offre une API intuitive pour leur manipulation.

### Chapitre 35 **Expressions régulières (module `re`)**

Les **expressions régulières (regex)** permettent de rechercher, valider, et manipuler des chaînes de caractères grâce à des motifs complexes. Python fournit le module **`re`** pour exploiter ces fonctionnalités.

---

### **1. Concepts de base des expressions régulières**

- **Recherche** : Identifier des motifs spécifiques dans une chaîne.
- **Substitution** : Remplacer des motifs par d'autres valeurs.
- **Validation** : Vérifier si une chaîne correspond à un motif donné.

---

### **2. Fonctions principales du module `re`**

#### **`re.search()`**

Recherche le **premier** motif correspondant dans une chaîne.

```python
import re

texte = "Bonjour, mon numéro est 123-456-7890."
resultat = re.search(r'\d{3}-\d{3}-\d{4}', texte)  # Motif : numéro de téléphone
if resultat:
    print("Numéro trouvé :", resultat.group())
```

#### **`re.findall()`**

Renvoie **toutes les occurrences** du motif sous forme de liste.

```python
texte = "Voici deux dates : 12/05/2023 et 14/06/2024."
resultats = re.findall(r'\d{2}/\d{2}/\d{4}', texte)  # Motif : dates au format DD/MM/YYYY
print("Dates trouvées :", resultats)
```

#### **`re.sub()`**

Remplace toutes les occurrences d'un motif par une autre chaîne.

```python
texte = "Prix : 10$, 20$, 30$"
nouveau_texte = re.sub(r'\$\d+', 'XX€', texte)  # Remplace les prix en dollars par "XX€"
print(nouveau_texte)
```

#### **`re.match()`**

Teste si un motif correspond au **début** d'une chaîne.

```python
texte = "abc123"
if re.match(r'abc', texte):
    print("Motif trouvé au début de la chaîne !")
```

#### **`re.split()`**

Divise une chaîne en fonction d'un motif.

```python
texte = "Nom: Alice; Âge: 30; Ville: Paris"
resultats = re.split(r';\s*', texte)  # Séparateurs : point-virgule suivi d'espaces
print(resultats)
```

---

### **3. Métacaractères courants et leurs significations**

| Métacaractère | Signification                              | Exemple                       |
|---------------|--------------------------------------------|-------------------------------|
| `.`           | N'importe quel caractère sauf une nouvelle ligne | `a.b` correspond à "acb", "a0b" |
| `^`           | Début de la chaîne                        | `^Bonjour` correspond à "Bonjour, monde" |
| `$`           | Fin de la chaîne                          | `monde$` correspond à "Bonjour, monde" |
| `*`           | 0 ou plusieurs occurrences                | `ab*` correspond à "a", "ab", "abb" |
| `+`           | 1 ou plusieurs occurrences                | `ab+` correspond à "ab", "abb" |
| `?`           | 0 ou 1 occurrence                         | `ab?` correspond à "a", "ab" |
| `{n}`         | Exactement `n` occurrences                | `a{3}` correspond à "aaa" |
| `{n,}`        | Au moins `n` occurrences                  | `a{2,}` correspond à "aa", "aaa" |
| `{n,m}`       | Entre `n` et `m` occurrences              | `a{2,4}` correspond à "aa", "aaa", "aaaa" |
| `[]`          | Classe de caractères                      | `[abc]` correspond à "a", "b", "c" |
| `|`           | OU logique                                | `a|b` correspond à "a" ou "b" |
| `\`           | ÉChapitrepement des caractères spéciaux       | `\.` correspond à un point littéral |

---

### **4. Cas pratiques**

#### **Validation d'une adresse e-mail**

```python
email = "exemple@mail.com"
motif = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
if re.match(motif, email):
    print("Adresse e-mail valide !")
else:
    print("Adresse e-mail invalide.")
```

#### **Recherche de mots commençant par une lettre spécifique**

```python
texte = "Python est puissant, précis, et performant."
mots = re.findall(r'\bp\w*', texte, re.IGNORECASE)  # Mots commençant par "p" (non sensible à la casse)
print("Mots trouvés :", mots)
```

#### **Extraire les numéros de téléphone**

```python
texte = "Contacts : +33-6-12345678, +33-7-98765432."
motif = r'\+33-\d{1}-\d{8}'
numeros = re.findall(motif, texte)
print("Numéros extraits :", numeros)
```

#### **Remplacement de mots spécifiques**

```python
texte = "Le chat dort. Le chat mange. Le chat joue."
nouveau_texte = re.sub(r'\bchat\b', 'chien', texte)
print(nouveau_texte)
```

---

### **5. Flags utiles dans `re`**

- **`re.IGNORECASE` ou `re.I`** : Rend la recherche insensible à la casse.
- **`re.DOTALL` ou `re.S`** : Permet à `.` de correspondre aux nouvelles lignes.
- **`re.MULTILINE` ou `re.M`** : Permet à `^` et `$` de fonctionner sur chaque ligne.

```python
texte = """Bonjour.
Bienvenue au tutoriel regex."""
resultats = re.findall(r'^.+$', texte, re.MULTILINE)
print(resultats)  # Chaque ligne est traitée individuellement
```

---

### **6. Conseils pratiques**
1. **Tester les motifs** : Utilisez des outils en ligne comme [regex101](https://regex101.com/) pour construire et tester vos expressions régulières.
2. **Documenter vos motifs** : Les regex complexes deviennent rapidement difficiles à lire. Ajoutez des commentaires ou utilisez des motifs lisibles.
3. **Éviter les cas d'utilisation abusifs** : Les regex ne sont pas adaptées pour tout (ex. : analyse syntaxique de HTML/XML).

---

### **Résumé**
- Les expressions régulières sont puissantes pour manipuler et analyser des chaînes.
- Les fonctions principales incluent `search`, `findall`, `sub`, `match`, et `split`.
- Bien comprendre les métacaractères et utiliser les flags selon le besoin.
- Les regex bien écrites permettent d'automatiser des tâches complexes avec efficacité.
